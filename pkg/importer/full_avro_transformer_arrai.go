// Package avro ...
// AUTOGENERATED. DO NOT EDIT.
package importer

// nolint
const avroTransformerScript = `### ------------------------------------------------------------------------ ###
###  avro_util.arrai                                                         ###
### ------------------------------------------------------------------------ ###

# Utilities

# Transforms Avro primitive types to Sysl ones.
let transformPrimitiveType = \type
    cond type {
        'null': 'null',
        'boolean': 'bool',
        'int': 'int32',
        'long': 'int64',
        'float': 'float32',
        'double': 'float64',
        'bytes': 'bytes',
        'string': 'string',
        _: 'NonPrimitiveType'              
    }
;

let transformLogicalTypes = \type
    cond type('logicalType').s {
        'decimal': $`+"`"+`decimal(${type('precision')}.${type('scale')})`+"`"+`,
        'uuid': 'string',
        'date': 'date',
        'time-millis': 'int32',
        'time-micros': 'int64',
        'timestamp-millis': 'datetime',
        'timestamp-micros': 'datetime',
        'local-timestamp-millis': 'datetime',
        'local-timestamp-micros': 'datetime',
        'duration': 'bytes',
        _: 'NonLogicalType'  
    }
;

let isFirstLetterUppercase = \str
    let fLetter = str where .@ = 0;
    //str.upper(fLetter) = fLetter
;

# TODO: Check if it is sysl keywords with isValidIdentifier in /pkg/arrai/util.arrai.
# Now there is an issue in /pkg/arrai/concat_go.arrai which can't import /pkg/arrai/util.arrai 
# to the final arrai Go file.
let shouldCorrectName = \name    
    cond transformPrimitiveType(name) {
        'NonPrimitiveType': # Doesn't capitalize first letter if it is primitive type.
                !(//seq.has_prefix('set of', name) || //seq.has_prefix('sequence of', name)) 
                    && !isFirstLetterUppercase(name)
        ,
    }
;

let getAnnotationS = \item \name
    let annotation = cond item {
        (:s): s,
        _: item(name)?.s:'',
    };
    cond annotation {
        '': '',
        _: cond name {
            'name': cond {
                shouldCorrectName(annotation): $'name="${annotation}"',
                _: ''
            },
            'doc': $`+"`"+`description="${annotation}"`+"`"+`, 
            _: $`+"`"+`${name}="${annotation}"`+"`"+`,
        }
    }
;

# Returns a string representation of an annotation array of the form:
# [union=['string', 'null'], description="Relationship end date", default="null"].
let prettyAnnotations = \annotationArray
    let str = $`+"`"+`${annotationArray where .@item rank (:.@)::, }`+"`"+`;
    str && $`+"`"+`[${str}]`+"`"+`
;

let correctName = \name
    let type = transformPrimitiveType(name);
    cond type {
        'NonPrimitiveType': # Doesn't capitalize first letter if it is primitive type.
            cond {
                //seq.has_prefix('set of', name) || //seq.has_prefix('sequence of', name): name,
                _: //str.title(name),
            },
        _: type
    }
;

# Get type name from types which looks like:
# ['null', 'string'], ['string', 'int'] or ['null', {'type':'record', ...}] etc.
# param t is type.
let getTypeName = \t
    cond t {
        (:s): 
            (s: correctName(s), type_S: correctName(s)),
        {'type': _, 'items': items, ...}:
            cond items {
                (:s):
                    let name = correctName(s); (s: $`+"`"+`${name}Sequence`+"`"+`, type_S: $`+"`"+`sequence of ${name}`+"`"+`),
                {'type': _, 'name': (s: initName), ...}:
                    let name = correctName(initName); (s: $`+"`"+`${name}Sequence`+"`"+`, type_S: $`+"`"+`sequence of ${name}`+"`"+`),
            },
        {'type': _, 'values': values, ...}:
            cond values {
                (:s):
                    let name = correctName(s); (s: $`+"`"+`String${//str.title(name)}Item`+"`"+`, type_S: $`+"`"+`set of String${//str.title(name)}Item`+"`"+`),
                {'type': _, 'name': (s: initName), ...}:
                    let name = correctName(initName); (s: $`+"`"+`String${name}Item`+"`"+`, type_S: $`+"`"+`set of String${name}Item`+"`"+`),
            },
        {'type': _, 'name': (:s), ...}: # This pattern matching must be in the end. 
            (s: correctName(s), type_S: correctName(s)),
    }
;

# Produces combined types, for example "type": ["int", "string", "null"],
# it will be processed to final type `+"`"+`Int32String?`+"`"+`.
let combineTypes = \types \handler
    let fullTypeNames = types >> getTypeName(.);
    let types = fullTypeNames >> .s;
    cond {
        //seq.contains(['null'], types):
            let typeNames = fullTypeNames where .@item.s != 'null' rank (:.@);
            cond types count {
                2: //seq.concat(typeNames >> handler(.)) + '?', # ['string', 'null'] -> string? .
                _: //seq.concat(typeNames => //str.title(.@item.s) orderby .) + '?' # ['string', 'null', 'int'] -> IntString? .
            }
        ,
        _:
            cond types count {
                1: $`+"`"+`${//str.title(//seq.concat(types))}Item`+"`"+`, # ['string'] -> StringItem .   
                _: //seq.concat(types => //str.title(.@item) orderby .), # ['string', 'int'] -> IntString .
            } 
    }
;

let transformType = \type
    cond type {
        # (s: 'string') etc.
        (s: typeName):
            cond correctName(typeName) {
                'null': 'string[~null]',
                name: name,
            },
        (a: typeArray):
            # Type can be ['null', 'string'], ['string', 'int'] or ['null', {'type':'record', ...}] etc.
            # [(s: 'null'), (s: 'string')] to ['null', 'string'].
            combineTypes(typeArray, \type cond type {(:type_S, ...): type_S, _: type.s}),
        {'logicalType': logicalTypeName, 'type': typeName, ...}: # Must be before {'type': typeName, ...}.
            transformLogicalTypes(type), 
        {'type': typeName, ...}:
            # It is array, map.
            cond typeName.s {
                'array': 
                    'sequence of ' + cond type('items') {
                                        {'name': (:s), ...}: correctName(s), 
                                        (:s): correctName(s),
                                    },
                'map': 
                    'set of ' + cond type('values') {
                                    {'name': (:s), ...}: 'String' + correctName(s) + 'Item', 
                                    (:s): 'String' + //str.title(s) + 'Item', # Primitive.
                                },
                _: correctName(type('name').s)
            },
    }
;

let defaultVal = \item
    let default = item('default')?:''; 
    cond default {
        '': cond item {
                {'type': {'type': (s: 'map'), ...}, ...}: 'default="{}"', # Map's default value is {}.
                _: '',
            },
        ():'default="null"', 
        (b: true): $`+"`"+`default="true"`+"`"+`,
        (b: false): $`+"`"+`default="false"`+"`"+`,
        (a: {}): $`+"`"+`default="[]"`+"`"+`,
        (a: [(:s), ...]): $`+"`"+`default="${default.a >> .s}"`+"`"+`,
        {...}: $`+"`"+`default="${default >> .s}"`+"`"+`,
        (:s): $`+"`"+`default="${s}"`+"`"+`,
        _: $`+"`"+`default="${default}"`+"`"+`,
    } 
;

let avro_util_arrai = 
(
    :prettyAnnotations,
    :transformType,
    :getAnnotationS,
    :getTypeName,
    :defaultVal,
    :combineTypes,
    :correctName,
);

### ------------------------------------------------------------------------ ###
###  to_sysl_alias.arrai                                                     ###
### ------------------------------------------------------------------------ ###

let util = avro_util_arrai;

let transformer = \aliasItem
    cond aliasItem {
        {'type': (s: 'fixed'), 'name': (s: name), "logicalType": (s: "duration"), ...}:
            '', # Ignore logicalType duration.
        {'type': (s: 'fixed'), 'name': (s: name), ...}: $`+"`"+`
            !alias ${util.correctName(name)}${
                let annotations = util.prettyAnnotations(
                    ['~fixed', $`+"`"+`fixed_size="${aliasItem('size')}"`+"`"+`] ++ (['namespace', 'name'] >> util.getAnnotationS(aliasItem, .))
                );
                cond {annotations: ' ' + $`+"`"+`${annotations}`+"`"+`}
            }:
                bytes
            ${
                let aliases = aliasItem('aliases')? .a:[];
                cond {
                    aliases count > 0: $`+"`"+`
                        
                        ${aliases >> \alias $`+"`"+`
                            !alias ${util.correctName(alias.s)}${
                                let annotations = util.prettyAnnotations([util.getAnnotationS(alias, 'name')]);
                                cond {annotations: ' ' + $`+"`"+`${annotations}`+"`"+`}
                            }:
                                ${util.correctName(name)}
                        `+"`"+`::\n\n}
                    `+"`"+`,
                }
            }
        `+"`"+`,
        # Double check.
        {'type': (s: 'array'), 'items': (s: itemsType), ...}: $`+"`"+`
            !alias ${util.correctName(itemsType)}Sequence${
                util.prettyAnnotations([util.defaultVal(.)])
            }:
                sequence of ${itemsType}
        `+"`"+`,
    }
;

let to_sysl_alias_arrai = 
transformer;

### ------------------------------------------------------------------------ ###
###  to_sysl_enum.arrai                                                      ###
### ------------------------------------------------------------------------ ###

# Transform Avro enum to Sysl enum.
let util = avro_util_arrai;

let transformer = \enumItem
    $`+"`"+`
        !enum ${util.correctName(enumItem('name').s)}${
                    let annotations = util.prettyAnnotations(['name', 'namespace', 'default', 'doc'] >> util.getAnnotationS(enumItem, .));
                    cond {annotations: ' ' + $`+"`"+`${annotations}`+"`"+`}
                }:
            ${enumItem('symbols').a >>> \i \(s: item)  $`+"`"+`${item}: ${i}`+"`"+`::\i}

        ${
            enumItem('aliases')?.a:[] >> $`+"`"+`
                !alias ${util.correctName(.s)}${
                            let annotations = util.prettyAnnotations([util.getAnnotationS(., 'name')]);
                            cond {annotations: ' ' + $`+"`"+`${annotations}`+"`"+`}
                        }: 
                    ${util.correctName(enumItem('name').s)}
            `+"`"+`::\n\n}
    `+"`"+`
;

let to_sysl_enum_arrai = 
transformer;

### ------------------------------------------------------------------------ ###
###  to_sysl_type.arrai                                                      ###
### ------------------------------------------------------------------------ ###

# Transform Avro record to Sysl record.
let util = avro_util_arrai;

# Build type annotation like [union=["int32", "null", "string"]].
let buildTypeAnnotation = \type
    cond type {
        (a: typeArray):
            let types = (typeArray >> util.getTypeName(.)) >> .type_S;
            cond types {
                ['null', ...]: 
                    # Types like ['null', 'string', 'int'].
                    cond {types count > 2: 
                        $'union=${types}',
                    },
                _: $'union=${types}', # Types like ['string', 'int32', 'null'] or ['string', 'null'].
            },
    }
;

let buildLogicalTypeAnnotation = \type
    let t = type('type');
    cond t {
        {'type': typeName, 'logicalType': logicalTypeName, ...}:
            cond logicalTypeName.s {
                'uuid': ['~uuid'],
                'date': '',
                'time-millis': ['~time-millis'],
                'time-micros': ['~time-micros'],
                'timestamp-millis': ['~timestamp-millis'],
                'timestamp-micros': ['~timestamp-micros'],
                'local-timestamp-millis': ['~local-timestamp-millis'],
                'local-timestamp-micros': ['~local-timestamp-micros'],
                'duration': ['~fixed', $`+"`"+`fixed_size="${t('size')}"`+"`"+`, '~duration', $`+"`"+`name="${t('name').s}"`+"`"+`],
            },
    }
;

let buildAnnotations = \type
    buildLogicalTypeAnnotation(type) ++ 
    [
        buildTypeAnnotation(type('type')),
        util.getAnnotationS(type, 'doc'),
        util.defaultVal(type),
        util.getAnnotationS(type, 'order'),
    ]
;

let printMapType = \record
    cond record {
        # Sample {'isMap': (s: 'true'), 'values': (s: 'string'), 'type': (s: 'map')}.
        {'values': (:s), ...}: $`+"`"+`
            !type String${//str.title(s)}Item ${util.prettyAnnotations(['json_map_key="key"', util.defaultVal(record)])}:
                key <: string
                value <: ${util.correctName(s)}
        `+"`"+`,
        {'type': (s: 'record'), ...}: $`+"`"+`
            !type String${util.transformType(record)}Item ${util.prettyAnnotations(['json_map_key="key"', util.defaultVal(record)])}:
                key <: string
                value <: ${util.transformType(record)}
        `+"`"+`
    }
;

let transformer = \record
    # Display map item.
    $`+"`"+`
        ${(record('isMap')?:()).s?:{} = 'true' && (printMapType(record) + '\n')}
        ${
            cond record {
                {'type': (s: 'record'), ...}:
                    $`+"`"+`
                        !type ${util.correctName(record('name').s)}${
                            let annotations = util.prettyAnnotations(['namespace', 'name', 'doc'] >> util.getAnnotationS(record, .));
                            cond {annotations: ' ' + $`+"`"+`${annotations}`+"`"+`}
                        }:
                            ${ # List fields.
                                let fields = record('fields')?.a:[]; 
                                fields >> \field $`+"`"+`
                                    ${field('name').s} <: ${util.transformType(field('type'))} ${util.prettyAnnotations(buildAnnotations(field))}${
                                        let aliases = field('aliases')?.a:[];
                                        cond {
                                            aliases: '\n' + $`+"`"+`
                                                ${aliases >> \alias $`+"`"+`
                                                    ${alias.s} <: ${util.transformType(field('type'))} ${
                                                        let aliasAnnotaions = 
                                                            util.prettyAnnotations(buildAnnotations(field) + [$`+"`"+`alias_of="${field('name').s}"`+"`"+`]);
                                                        aliasAnnotaions
                                                    }
                                                `+"`"+`::\n}
                                            `+"`"+`,
                                        }                                            
                                    }
                                `+"`"+`::\n}
                        ${ # List records's aliases.
                            let aliases = record('aliases')?.a:[];
                            cond {
                                aliases: '\n' + $`+"`"+`
                                    ${aliases >> \alias $`+"`"+`
                                        !alias ${util.correctName(alias.s)}${
                                            let annotations = util.prettyAnnotations([util.getAnnotationS(alias, 'name')]);
                                            cond {annotations: ' ' + $`+"`"+`${annotations}`+"`"+`}
                                        }:
                                            ${util.correctName(record('name').s)}
                                    `+"`"+`::\n\n}
                                `+"`"+` + '\n',
                            }
                        }
                    `+"`"+`
            }
        }`+"`"+`
;

let to_sysl_type_arrai = 
transformer;

### ------------------------------------------------------------------------ ###
###  to_sysl_union.arrai                                                     ###
### ------------------------------------------------------------------------ ###

# Transform Avro union to Sysl union.
let util = avro_util_arrai;

let printUnion = \union
    let types = union >> util.getTypeName(.) >> cond . {(:type_S, ...): type_S, _: .s};
    $`+"`"+`
        !union ${//seq.sub('?', '', util.combineTypes(union, \. .s))}:
            ${types where .@item != 'null' rank (:.@) => .@item orderby .::\n}
    `+"`"+`
;

let transformer = \union
    let types = union >> util.getTypeName(.) >> .s;
    cond {
        //seq.contains(['null'], types):
            cond {
                types count > 2: printUnion(union),
            }
        ,
        _: printUnion(union)
    }
;

let to_sysl_union_arrai = 
transformer;

### ------------------------------------------------------------------------ ###
###  transformer.arrai                                                       ###
### ------------------------------------------------------------------------ ###

let util = avro_util_arrai;

# Extra items transformed to Sysl type !enum .
let rec extraEnums = \schema
  cond schema {
    {'type': (s: 'enum'), 'name': name, ...}:
      {schema},
    {'type': (s: 'record'), 'name': name, 'fields': (a : fields), ...}:
      //rel.union(fields => extraEnums(.@item('type'))),
    {'type': type, 'items': items, ...}: # Array.
      cond items {
        (a: types): //rel.union(types => extraEnums(.@item)), # Array.
        (:s): {}, # Primitive.
        _: extraEnums(items),
      },
    {'type': type, 'values': values, ...}: # Map or array.
      cond values {
        (a: types): //rel.union(types => extraEnums(.@item)), # Array.
        (:s): {}, # Primitive.
        _: extraEnums(values),
      },  
    {'type': (a: types)}: # Type is an array.
      //rel.union(types => extraEnums(.@item)),  
    (a: types): # Root is json array.
      //rel.union(types => extraEnums(.@item)),
  }
;

# Extra items transformed to Sysl type !type .
let rec extraTypes = \schema
  cond schema {
    {'type': (s: 'record'), 'fields': (a : fields), ...}:
      {schema} | //rel.union(fields => extraTypes(.@item('type'))),
    {'type': (s: type), 'items': items, ...}: # Array.
      cond items {
        # Array.
        (a: types): //rel.union(types => extraTypes(.@item)),
        _: extraTypes(items), 
      },
    {'type': (s: type), 'values': values, ...}: # Map.
      cond values {
        # Array.
        (a: types): //rel.union(types => extraTypes(.@item)),
        # Field values is primitive or customized type like {'type': (s: 'map'), 'items': (s: 'string'), ...}.
        (:s):
          cond {
            'map': {schema | {'isMap': (s: 'true')}},
          },
        _:
          cond type {
            # Field values is customized type like 'type': {'type': (s: 'record'), ...}.
            'map': extraTypes(values |  {'isMap': (s: 'true')}),
            _: extraTypes(values),
          }, 
      },
    {'type': (a: types)}: # Type is an array.
      //rel.union(types => extraTypes(.@item)),  
    (a: types): # Root is json array.
      //rel.union(types => extraTypes(.@item)),
  }
;

# Extra items transformed to Sysl type !alias .
let rec extraAliases = \schema
  cond schema {
    {'type': (s: 'record'), 'name': (s: name), 'fields': (a : fields), ...}:
      //rel.union(fields => extraAliases(.@item('type'))),
    {'type': type, 'items': items, ...}: # Array.
      cond items {
        (:a): //rel.union(a => extraAliases(.@item)), # Array.
        (:s): {}, # Primitive.
        _: extraAliases(items)
      },
    {'type': type, 'values': values, ...}: # Map.
      cond values {
        (:a): //rel.union(a => extraAliases(.@item)), # Array.
        (:s): {}, # Primitive.
        _: extraAliases(values)
      },
    {'type': (:a), ...}: # Type is an array.
      //rel.union(a => extraAliases(.@item)),  
    (:a): # Root is json array. 
      //rel.union(a => extraAliases(.@item)),
    {'type': (:s), ...}: # Fixed.
      {schema},
  }
;

# Extra item transformed to Sysl type !union .
let rec extraUnions = \schema
  cond schema {
    (a: types):
      cond types {
        [(s: 'null'), ...]: cond {types count > 2: {types} | //rel.union(types => extraUnions(.@item))}, # Ignore types like ['null', 'string'].
        _: {types} | //rel.union(types => extraUnions(.@item)),
      }, 
    {'type': (s: 'record'), 'fields': (a : fields), ...}:
      //rel.union(fields => extraUnions(.@item('type'))),
    {'type': type, 'items': items, ...}: # Array.
      cond items {
        (a: types): //rel.union(types => extraUnions(.@item)), # Array.
        (:s): {}, # Primitive.
        _: extraUnions(items),
      },
    {'type': type, 'values': values, ...}: # Map.
      cond values {
        (a: types): //rel.union(types => extraUnions(.@item)), # Array.
        (:s): {}, # Primitive.
        _: extraUnions(values),
      },
    {'type': (a: types)}: # Type is an array.
      //rel.union(types => extraUnions(.@item)),  
    (a: types): # Root is json array. 
      //rel.union(types => extraUnions(.@item)),    
  }
;

let avroTransformer = \schema \appName \packageName
  # Load Avro spec whose format is protobuf.
  let schema = //encoding.json.decode(schema);

$`+"`"+`
  ##########################################
  ##                                      ##
  ##  AUTOGENERATED CODE -- DO NOT EDIT!  ##
  ##                                      ##
  ##########################################

  ${appName}${util.prettyAnnotations(['avro_spec="1.0"',$`+"`"+`${cond packageName {'':'', _:$`+"`"+`package="${packageName}"`+"`"+`}}`+"`"+`])}:
    ${extraTypes(schema) => to_sysl_type_arrai(.) orderby . ::\n}
    ${extraEnums(schema) => to_sysl_enum_arrai(.) orderby . ::\n}
    ${extraAliases(schema) => to_sysl_alias_arrai(.) orderby . ::\n}
    ${extraUnions(schema) => to_sysl_union_arrai(.) orderby . ::\n\n}
`+"`"+`
;

avroTransformer
`
