let size = \length
    cond {
        length = 'MAX': '',
        length > 0: $`(${length})`,
        _: '',
    };

# attributePatternToken returns the token based on attribute value
let attributePatternToken = \entity \attr \token
    cond {
        (attr.options?:{}): token,
        ({attr.name} & entity.primary_key): token,
        let fks = entity.foreign_keys => .foreign_keys => .attribute; ({attr.name} & fks): token,
        (attr.length = 'MAX'): token,
        (//seq.has_prefix('0x', attr.length)): token,
        _: '',
    };

# entityPatternToken returns the token based on entity value
let entityPatternToken = \entity \model \token
    cond {
        (entity.primary_key | entity.foreign_keys | entity.cluster | model.indexes): token,
        _: '',
    };

# attributePattern generates the pattern constituents depending on the mode
let attributePattern = \entity \attr \mode
    cond {
        (mode = 0 && ({attr.name} & entity.primary_key)): '~pk',
        let fks = entity.foreign_keys => .foreign_keys => .attribute; (mode = 1 && ({attr.name} & fks)): '~fk',
        (mode = 2 && attr.options): attr.options,
        (mode = 3 && attr.length = 'MAX'): '~max',
        (mode = 4 && //seq.has_prefix('0x', attr.length)): '~hex',
        _: '',
    };

# entityPattern generates the pattern constituents depending on the mode
let entityPattern = \entity \model \mode
    cond {
        (mode = 0 && entity.primary_key count > 1):
            'primary_key="' ++ //seq.join(", ", entity.primary_key orderby .) ++ '"',
        (mode = 1 && entity.cluster):
            //seq.join('', entity.cluster >> 'interleave_in_parent="' ++
            .interleaved_in ++ '", interleave_on_delete="' ++ .on_delete ++ '"'),
        (mode = 2 && entity.foreign_keys):
            'foreign_keys=[' ++ //seq.join(', ',(entity.foreign_keys => \keys '[' ++ //seq.join(', ', (keys.foreign_keys =>
            '"constraint:' ++ keys.constraint_name ++
            '","columns:' ++ .attribute ++ '"')
             orderby .) ++ ']' ) orderby .) ++ ']',
        let relatedIndices = ((model.indexes orderby .) where .@item.table_name = entity.name); (mode = 3 && model.indexes && relatedIndices):
            'indexes=[' ++ //seq.join(', ', ((model.indexes orderby .) where .@item.table_name = entity.name) >>
            '"name:' ++ .table_name ++
            '","unique:' ++ (cond {(.unique = 'UNIQUE'):'true', _:'false'}) ++
            '","null_filtered:' ++ (cond {(.nullfiltered = 'NULL_FILTERED'):'true', _:'false'}) ++
            '","key_parts:' ++ .key_part ++
            cond {(.storing_col): '","storing:' ++ (//seq.join(', ',.storing_col))}  ++
            '","interleave_in:' ++ .table_name) ++ '"]',
        _: '',
    };

# allEntityPatterns generates the pattern string for an entity
let allEntityPatterns = \entity \model
    $`${entityPatternToken(entity, model, '[')}${cond {
        entityPatternToken(entity, model, true):
        //seq.join(', ',[entityPattern(entity, model, 0), entityPattern(entity, model, 1),
        entityPattern(entity, model, 2), entityPattern(entity, model, 3)] where .@item != '')
    }}${entityPatternToken(entity, model, ']')}`;

# allAttributePatterns generates the pattern string for an entity attribute
let allAttributePatterns = \entity \attr
    $`${attributePatternToken(entity,attr,'[')}${cond {
        attributePatternToken(entity,attr,true):
        //seq.join(', ',[attributePattern(entity,attr,2), attributePattern(entity,attr,0), attributePattern(entity,attr,1),
        attributePattern(entity,attr,3), attributePattern(entity,attr,4)] where .@item != '')
    }}${attributePatternToken(entity,attr,']')}`;

# transformModel translates the empty model into sysl file
let transformModel = \model
    # sysl specification
    # https://github.com/anz-bank/sysl/blob/master/pkg/sysl/sysl.proto
    $`
        //   THIS IS AUTOGENERATED BY sysl   //
        ${model.schema => $`
            ${.name}:
            ${//seq.sub('#>>>\n', '')($`
            ${(model.entities => \entity $`
            #>>>
                !table ${entity.name}${allEntityPatterns(entity, model)}:
                    ${entity.attributes =>
                        $`
                            ${.name}  ${.type}${size(.length)}${cond {.nullable:'?'}}${allAttributePatterns(entity, .)}
                                ` orderby .::\i:
                        }`
                    )
                    orderby .::\i\n:
            }
            `)}
        ` orderby .::\i\n:}
    `;

# exports
(
    :transformModel,

)
