# Transforms that generate sysl from an arr.ai-based SQL model.

# size returns the size of an attribute.
let size = \length
    cond {
        length = 'MAX': '',
        //seq.has_prefix('0x', length): $`(${//seq.trim_prefix('0x', length)})`,
        length > 0: $`(${length})`,
    };

# hasAttributePattern checks whether an attribute has associated patterns.
let hasAttributePattern = \entity \attr
    (attr.type = 'bytes' && attr.length > 0)
    || attr.options?:{}
    || (entity.primary_key where //seq.contains(attr.name, .))
    || attr.length = 'MAX' || //seq.has_prefix('0x', attr.length)
    || ((entity.foreign_keys =>
        ((.foreign_keys where .attribute = attr.name) => .reference_attribute orderby .)) where .);

# hasEntityPattern checks whether an entity has associated patterns.
let hasEntityPattern = \entity \model
    entity.primary_key | entity.foreign_keys | entity.cluster | model.indexes;

# sortingOrder determines and appends sorting order.
let sortingOrder = \e \attr
    let re = //re.compile($`${attr.name}\((asc|desc)\)`);
    let keyOrder = e.primary_key => (re.match(.)(0)?(1)?:{} rank (:.@)) where .;
    cond keyOrder {{x}: $`~${x}`};

# compareColumnOrder compares the col order between primary key and table.
let compareColumnOrder = \entity
    let pk = (entity.primary_key orderby (. => .@ orderby .)(0)) >> //seq.split('(', .)(0);
    pk !(<=) (entity.attributes >> .name);

# matchingFKs returns the foreign keys matching attribute name.
let matchingFKs = \entity \attr
    entity.foreign_keys => (.foreign_keys where .attribute = attr.name) where .;

# attributePatterns generates the patterns for an attribute.
let attributePatterns = \entity \attr
    let options = cond {
        attr.options:
            let [k, v, ...] = //seq.split('=', attr.options);
            $`${k}="${v}"`,
        };
    let pk = cond {
        (entity.primary_key where //seq.contains(attr.name, .)):
            $`~pk${cond {sortingOrder(entity, attr): $`, ${sortingOrder(entity, attr)}`}}`
    };
    let fk = cond { matchingFKs(entity, attr): '~fk' };
    let length = cond { attr.length = 'MAX': '~max' };
    let hexPrefix = cond { //seq.has_prefix('0x', attr.length): '~hex' };
    let byteLength = cond {
        attr.type = 'bytes' && attr.length > 0 && attr.length != 'MAX': $`length="${attr.length}"`
    };
    //seq.join(', ', [options, byteLength, pk, fk, length, hexPrefix] where .@item);

# entityPatterns generates the patterns for an entity.
let entityPatterns = \entity \model
    let pk = cond {
        entity.primary_key count > 1 && compareColumnOrder(entity):
            $`primary_key="${entity.primary_key orderby .::, }"`,
    };
    let cluster = cond {
        entity.cluster:
            //seq.join('', entity.cluster >>
            $`interleave_in_parent="${.interleaved_in}", interleave_on_delete="${.on_delete}"`),
    };
    let fk = cond {
        entity.foreign_keys: $`
            foreign_keys=[${(entity.foreign_keys => \keys $`
                ["constraint:${keys.constraint_name}","columns:${keys.foreign_keys => .attribute orderby .::, }"]
            `) orderby .::, }]
        `,
    };
    let indx = model.indexes where .table_name = entity.name => ([
        $`"name:${.table_name}"`,
        $`"unique:${.unique}"`,
        $`"null_filtered:${.nullfiltered}"`,
        $`"key_parts:${.key_part orderby .::,}"`,
        cond {.storing_col: $`"storing:${.storing_col::,}"`},
        cond {.interleaved_table: $`"interleave_in:${.interleaved_table}"`},
    ] where .@item) => //seq.join(',', .);
    //seq.join(', ', [pk, cluster, fk, cond { indx: $`indexes=[${indx orderby . ::}]` }] where .@item);

# appendEntityPatterns returns a pattern for the entity patterns together.
let appendEntityPatterns = \entity \model cond { hasEntityPattern(entity, model): $`[${entityPatterns(entity, model)}]`};

# appendAttributePatterns returns a pattern for the attribute patterns together.
let appendAttributePatterns = \entity \attr cond { hasAttributePattern(entity, attr): $`[${attributePatterns(entity, attr)}]`};

# typeInfo generates the type info for an attribute.
let typeInfo = \entity \attr \type \isArray
    let fkAttr = cond {
        matchingFKs(entity, attr):  matchingFKs(entity, attr) => .reference_attribute
    };
    let fkTable = cond {
        matchingFKs(entity, attr):  matchingFKs(entity, attr) => .reference_table
    };
    cond {
        fkAttr && fkTable: $`${fkTable orderby . ::}.${fkAttr orderby . ::}`,
        isArray: $`sequence of ${type}`,
        _: type,
    };

# transformModel translates the empty model into sysl file.
let transformModel = \model \package
    # sysl specification
    # https://github.com/anz-bank/sysl/blob/master/pkg/sysl/sysl.proto
    $`
        ##########################################
        ##                                      ##
        ##  AUTOGENERATED CODE -- DO NOT EDIT!  ##
        ##                                      ##
        ##########################################
        ${model.schema => $`
            ${.name}${cond {package: $`[spanner_spec="1.0", package="${package}"]`} }:
            ${//seq.sub('#>>>\n', '')($`
            ${(model.entities => \entity $`
            #>>>
                !table ${entity.name} ${appendEntityPatterns(entity, model)}:
                    ${entity.attributes >>
                        $`
                            ${.name} <: ${typeInfo(entity, ., .type ++ cond {.type != 'bytes': size( .length)}, .array)}${cond {.nullable:'?'}} ${appendAttributePatterns(entity, .)}` ::\i:
                        }`
                    )
                    orderby .::\i:
            }
            `)}
        ` orderby .::}
    `;
(
    :transformModel,
)
