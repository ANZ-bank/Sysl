let util = //{./util};

# Extra items transformed to Sysl type !enum
let rec extraEnums = \schema
  cond schema {
    {'type': (s: 'enum'), 'name': name, ...}:
      {schema},
    {'type': (s: 'record'), 'name': name, "fields": (a : fields), ...}:
      //rel.union(fields => extraEnums(.@item("type"))),
    {'type': type, 'items': items, ...}: # Map or array
      cond items {
        (a: types): //rel.union(types => extraEnums(.@item)), # array
        (:s): extraEnums(items.s), # primitive
        _: extraEnums(items),
      }
  }
;

# Extra items transformed to Sysl type !type 
let rec extraTypes = \schema
  cond schema {
    {"type": (s: "record"), "name": (s: name), "fields": (a : fields), ...}:
      {schema} | //rel.union(fields => extraTypes(.@item("type"))),
    {'type': (s: 'array'), 'items': {'type': (s: 'record'), "fields": (a : fields), ...}, ...}: # record array
      {schema('items')} | //rel.union(fields => extraTypes(.@item("type"))),
    {'type': (s: 'map'), 'items': {'type': (s: 'record'), "fields": (a : fields), ...}, ...}: # record map
      {schema('items') | {'isMap': (s: 'true')}} | //rel.union(fields => extraTypes(.@item("type"))),
    {'type': (a: types)}: # type is an array
      //rel.union(types => .@item => extraTypes(.)),  
    (a: types): 
      //rel.union(types => .@item => extraTypes(.)),
};

# Extra items transformed to Sysl type !alias
let rec extraAliases = \schema
  cond schema {
    {'type': (s: 'fixed'), ...}: # fixed type
      {schema},
    {"type": (s: "record"), "name": (s: name), "fields": (a : fields), ...}:
      //rel.union(fields => extraAliases(.@item("type"))),
    {'type': type, 'items': items, ...}: # array or map
      cond items {
        (a: types): //rel.union(types => extraAliases(.@item)), # array
        (:s): extraAliases(items.s), # primitive
        _: extraAliases(items),
      }
};

# Extra item transformed to Sysl type !union
let rec extraUnions = \schema
  cond schema {
    (a: types): {types} | //rel.union(types => extraUnions(.@item)),
    {'type': (s: 'record'), "fields": (a : fields), ...}:
      //rel.union(fields => extraUnions(.@item("type"))),
    {'type': type, 'items': items, ...}: # array or map
      cond items {
        (a: types): //rel.union(types => extraUnions(.@item)), # array
        (:s): extraUnions(items.s), # primitive
        _: extraUnions(items),
      },  
  }
;

let avroTransform = \schema \appName \packageName
  # Load Avro spec whose format is protobuf 
  let schema = //encoding.json.decode(//os.file(schema));

$'
##########################################
##                                      ##
##  AUTOGENERATED CODE -- DO NOT EDIT!  ##
##                                      ##
##########################################
${appName}${util.prettyAnnotations(['avro_spec="1.0"',$'${cond packageName {'':'', _:$'package="${packageName}"'}}'])}:
${util.indent}# Types
${extraTypes(schema) => //{./transformToSyslType}(.) orderby . ::}
${util.indent}# Aliases
${extraAliases(schema) => //{./transformToSyslAlias}(.) orderby . ::}
${util.indent}# Unions
${
# It applies //{./transformUnionToSysl}(.) to every item and will remove duplidated items if //{./transformUnionToSysl}(.)
# produces, as it iterates set.
extraUnions(schema) => //{./transformToSyslUnion}(.) orderby . ::}
${util.indent}# Enums
${extraEnums(schema) => //{./transformToSyslEnum}(.) orderby . ::}
'
;avroTransform