let util = //{./util};

# Extra type enum
let rec extraEnums = \schema
  cond schema {
    {'type': (s: 'enum'), 'name':(s: name), ...}:
      {schema},
    {'type': (s: 'record'), 'name':(s: name), "fields": (a : fields), ...}:
      //rel.union(fields => extraEnums(.@item("type"))),
    {'type': (s: 'array'), 'items': {'type': (s: 'record'), "fields": (a : fields), ...}, ...}: # record array
      //rel.union(fields => extraEnums(.@item("type"))),
    {'type': (s: 'map'), 'items': {'type': (s: 'record'), "fields": (a : fields), ...}, ...}: # record map
      //rel.union(fields => extraEnums(.@item("type"))), 
    (a: types):
      //rel.union(types => .@item => extraEnums(.))
  }
;

# Extra type record
let rec extraRecords = \schema 
  cond schema {
    {"type": (s: "record"), "name": (s: name), "fields": (a : fields), ...}:
      {schema} | //rel.union(fields => extraRecords(.@item("type"))),
    {'type': (s: 'array'), 'items': {'type': (s: 'record'), "fields": (a : fields), ...}, ...}: # record array
      {schema('items')} | //rel.union(fields => extraRecords(.@item("type"))),
    {'type': (s: 'map'), 'items': {'type': (s: 'record'), "fields": (a : fields), ...}, ...}: # record map
      {schema('items') | {'isMap': (s: 'true')}} | //rel.union(fields => extraRecords(.@item("type"))),
    {'type': (a: types)}: # type is an array
      //rel.union(types => .@item => extraRecords(.)),  
    (a: types): 
      //rel.union(types => .@item => extraRecords(.)),
};

# Extra type union
let rec extraUnions = \schema
  cond schema {
    (a:[...]):
      {schema.a} | //rel.union(
        schema.a => .@item => \.
          cond . {
              {'type': (s: 'record'), "fields": (a : fields), ...}:
                //rel.union(fields => extraUnions(.@item("type"))),
              {'type': (s: 'array'), 'items': {'type': (s: 'record'), "fields": (a : fields), ...}, ...}: # record array
                //rel.union(fields => extraUnions(.@item("type"))),
              {'type': (s: 'map'), 'items': {'type': (s: 'record'), "fields": (a : fields), ...}, ...}: # record map
                //rel.union(fields => extraUnions(.@item("type"))),
          }
        ),
    {'type': (s: 'record'), "fields": (a : fields), ...}:
      //rel.union(fields => extraUnions(.@item("type"))),
    {'type': (s: 'array'), 'items': {'type': (s: 'record'), "fields": (a : fields), ...}, ...}: # record array
      //rel.union(fields => extraUnions(.@item("type"))),
    {'type': (s: 'map'), 'items': {'type': (s: 'record'), "fields": (a : fields), ...}, ...}: # record map
      //rel.union(fields => extraUnions(.@item("type"))),
  }
;

let avroTransform = \schema \appName \packageName
  # Load Avro spec whose format is protobuf 
  let schema = //encoding.json.decode(//os.file(schema));

$'
##########################################
##                                      ##
##  AUTOGENERATED CODE -- DO NOT EDIT!  ##
##                                      ##
##########################################
${appName}${util.prettyAnnotations(['avro_spec="1.0"',$'${cond packageName {'':'', _:$'package="${packageName}"'}}'])}:
${util.indent}# Types
${extraRecords(schema) => //{./transformRecordToSysl}(.) orderby . ::}
${util.indent}# Unions
${
# It applies //{./transformUnionToSysl}(.) to every item and will remove duplidated items if //{./transformUnionToSysl}(.)
# produces, as it iterates set.
extraUnions(schema) => //{./transformUnionToSysl}(.) orderby . ::}
${util.indent}# Enums
${extraEnums(schema) => //{./transformEnumToSysl}(.) orderby . ::}
'
;avroTransform
