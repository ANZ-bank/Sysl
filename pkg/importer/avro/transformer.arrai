let util = //{./avro_util};

# Extra items transformed to Sysl type !enum
let rec extraEnums = \schema
  cond schema {
    {'type': (s: 'enum'), 'name': name, ...}:
      {schema},
    {'type': (s: 'record'), 'name': name, "fields": (a : fields), ...}:
      //rel.union(fields => extraEnums(.@item("type"))),
    {'type': type, 'items': items, ...}: # Map or array
      cond items {
        (a: types): //rel.union(types => extraEnums(.@item)), # array
        (:s): extraEnums(s), # primitive
        _: extraEnums(items),
      },
    {'type': (a: types)}: # type is an array
      //rel.union(types => extraEnums(.@item)),  
    (a: types): # root is json array 
      //rel.union(types => extraEnums(.@item)),
  }
;

# Extra items transformed to Sysl type !type 
let rec extraTypes = \schema
  cond schema {
    {"type": (s: "record"), "fields": (a : fields), ...}:
      {schema} | //rel.union(fields => extraTypes(.@item("type"))),
    {'type': (s: type), 'items': items, ...}: # array or map
      cond items {
        (a: types): //rel.union(types => extraTypes(.@item)), # array
        (:s): {}, # primitive
        _:
          cond type {
            'map': extraTypes(items |  {'isMap': (s: 'true')}),
            _: extraTypes(items),
          } 
      },
    {'type': (a: types)}: # type is an array
      //rel.union(types => extraTypes(.@item)),  
    (a: types): # root is json array 
      //rel.union(types => extraTypes(.@item)),
  }
;

# Extra items transformed to Sysl type !alias
let rec extraAliases = \schema
  cond schema {
    {"type": (s: "record"), "name": (s: name), "fields": (a : fields), ...}:
      //rel.union(fields => extraAliases(.@item("type"))),
    {'type': type, 'items': items, ...}: # array or map
      cond items {
        (:a): //rel.union(a => extraAliases(.@item)), # array
        (:s): {schema}, # primitive
      },
    {'type': (:a), ...}: # type is an array
      //rel.union(a => extraAliases(.@item)),  
    (:a): # root is json array 
      //rel.union(a => extraAliases(.@item)),
    {'type': (:s), ...}:
      {s},
    (:s):
      {s},
};

# Extra item transformed to Sysl type !union
let rec extraUnions = \schema
  cond schema {
    (a: types): {types} | //rel.union(types => extraUnions(.@item)),
    {'type': (s: 'record'), "fields": (a : fields), ...}:
      //rel.union(fields => extraUnions(.@item("type"))),
    {'type': type, 'items': items, ...}: # array or map
      cond items {
        (a: types): //rel.union(types => extraUnions(.@item)), # array
        (:s): extraUnions(s), # primitive
        _: extraUnions(items),
      },
    {'type': (a: types)}: # type is an array
      //rel.union(types => extraUnions(.@item)),  
    (a: types): # root is json array 
      //rel.union(types => extraUnions(.@item)),    
  }
;

let avroTransformer = \schema \appName \packageName
  # Load Avro spec whose format is protobuf 
  let schema = //encoding.json.decode(schema);

$`
##########################################
##                                      ##
##  AUTOGENERATED CODE -- DO NOT EDIT!  ##
##                                      ##
##########################################
${appName}${util.prettyAnnotations(['avro_spec="1.0"',$'${cond packageName {'':'', _:$'package="${packageName}"'}}'])}:
${util.indent}# Types
${extraTypes(schema) => //{./to_sysl_type}(.) orderby . ::\n}
${util.indent}# Aliases
${extraAliases(schema) => //{./to_sysl_alias}(.) orderby . ::\n}
${util.indent}# Unions
${extraUnions(schema) => //{./to_sysl_union}(.) orderby . ::\n}
${util.indent}# Enums
${extraEnums(schema) => //{./to_sysl_enum}(.) orderby . ::\n}
`;
avroTransformer
