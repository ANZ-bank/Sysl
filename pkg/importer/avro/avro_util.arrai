# Utilities

# Transform Avro primitive types to Sysl ones
let transformPrimitiveType = \type
    cond type {
        'null': 'null',
        'boolean': 'bool',
        'int': 'int32',
        'long': 'int64',
        'float': 'float32',
        'double': 'float64',
        'bytes': "bytes",
        'string': 'string',
        _: 'NonPrimitiveType'              
    }
;

let transformLogicalTypes = \type
    cond type('logicalType').s {
        'decimal': $'decimal(${type('precision')}.${type('scale')})',
        'uuid': 'string',
        'date': 'date',
        'time-millis': 'int32',
        'time-micros': 'int64',
        'timestamp-millis': 'datetime',
        'timestamp-micros': 'datetime',
        'local-timestamp-millis': 'datetime',
        'local-timestamp-micros': 'datetime',
        'duration': 'bytes',
        _: 'NonLogicalType'  
    }
;

let isSyslReserved = \str
    {}
;

let isFirstLetterUppercase = \str
    let letter = str where .@ = 0;
    //str.upper(letter) = letter
;

let shouldCorrectName = \name
    cond transformPrimitiveType(name) {
        'NonPrimitiveType':
                !(//seq.has_prefix("set of", name) || //seq.has_prefix("sequence of", name)) 
                    && !isFirstLetterUppercase(name)
                    && !isSyslReserved(name)
        ,
    }
;

let getAnnotationS = \item \name
    let annotation = item(name)? .s:"";
    let annotationTxt = 
        cond annotation {
            "": "",
            _: cond name {
                'name': cond {
                    shouldCorrectName(annotation): $'name="${annotation}"',
                },
                'doc': $'description="${annotation}"', 
                _: $'${name}="${annotation}"',
            }
        };
    annotationTxt
;

# Pretty annotation array
let prettyAnnotations = \annotationArray
    let str = $'${let a = annotationArray where .@item != "" rank (:.@); a >>> \i \item item::, }';
    cond str {'':$'', _:$'[${str}]'}
;

let correctName = \name
    let primitive = transformPrimitiveType(name);
    cond primitive {
        'NonPrimitiveType': 
            cond {
                //seq.has_prefix("set of", name) || //seq.has_prefix("sequence of", name): name,
                _: //str.title(name),
            },
        _: primitive
    }
;

# Get type name from types which looks like:
# ['null', 'string'], ['string', 'int'] or ['null', {'type':'record', ...}] etc.
let getTypeName = \t
    cond t {
        (:s): (s: correctName(s)),
        {'type': (s: type), 'items': (:s), ...}:
            cond type {
                'map': (s: $'${correctName(t('items').s)}Set', type_S: $'set of ${correctName(t('items').s)}'), # will be displayed in union definition
                'array': (s: $'${correctName(t('items').s)}Sequence', type_S: $'sequence of ${correctName(t('items').s)}'), # will be displayed in union definition
            },
        {'type': (s: type), 'items': {'type': (:s), ...}, ...}:
            cond type {
                'map': (s: $'${correctName(t('items')('name').s)}Set', type_S: $'set of ${correctName(t('items')('name').s)}'), # will be displayed in union definition
                'array': (s: $'${correctName(t('items')('name').s)}Sequence', type_S: $'sequence of ${correctName(t('items')('name').s)}'), # will be displayed in union definition
            },
        {'type': (:s), ...}: (s : correctName(t('name').s)),
    }
;

let combineTypes = \types \handler
    let fullTypeNames = types >> getTypeName(.);
    let types = fullTypeNames >> .s;
    cond //seq.contains(['null'], types) {
        true:
            let typeNames = fullTypeNames where .@item.s != 'null' rank (:.@);
            cond types count {
                2: //seq.concat(typeNames >> handler(.)) + '?',
                _: //seq.concat(typeNames >> //str.title(.s) orderby .@item >> .@item) + '?'
            }
        ,
        _: //seq.concat(types >> //str.title(.) orderby .@item >> .@item)
    }
;

let transformType = \type
    cond type {
        # (s: 'string') etc.
        (s: typeName):
            let correctedName = correctName(typeName);
            cond correctedName {
                "null": "string[~null]",
                _: correctedName,
            },
        (a: typeArray):
            # type can be ['null', 'string'], ['string', 'int'] or ['null', {'type':'record', ...}] etc.
            # [(s: 'null'), (s: 'string')] to ['null', 'string']
            combineTypes(typeArray, \. cond . {(type_S:type_S, ...): type_S, _: .s}),
        {'logicalType': logicalTypeName, 'type': typeName, ...}: # Must be before {'type': typeName, ...}
            transformLogicalTypes(type), 
        {'type': typeName, ...}:
            # it is array, map
            cond typeName.s {
                'array': 'sequence of ' + cond type('items') {{'name': (:s), ...}: correctName(s), (:s): correctName(s),},
                'map': 'set of ' + cond type('items') {{'name': (:s), ...}: 'String' + correctName(s) + 'Item', (:s): correctName(s),},
                _: correctName(type('name').s)
            },
    }
;

let getDefaultVal = \.
    let default = .('default')?:""; 
    cond default {
        "": "",
        ():'default="null"', 
        (b: true): $'default="true"',
        (b: false): $'default="false"',
        (a: {}): $'default="[]"',
        (a: [(:s), ...]): $'default="${default.a >> .s}"',
        _: $'default="${default}"'
    } 
;

let util = (
    : prettyAnnotations,
    : transformType,
    : getAnnotationS,
    : getTypeName,
    : getDefaultVal,
    : combineTypes,
    : correctName,
);
util
