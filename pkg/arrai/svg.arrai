# Functions for working with SVG documents.

let (:ranked, ...) = //{./util};

let comment = \k \v k = "comment";
let at = \k \v //seq.has_prefix("@", k);
# Filters out nodes of an AST that are keyed by "comment" or "@*".
let pred = \k \v !comment(k, v) && !at(k, v);

# SVG attributes that have numeric values.
let nums = {'x', 'y', 'x1', 'x2', 'y1', 'y2', 'cx', 'cy', 'rx', 'ry',
    'textLength', 'font-size'};

# Transforms an SVG AST into a more natural arr.ai structure.
let transformDoc = \ast
    let rec transformNode = \node (
        @tag: node.tag.name.'',
        attrs: node.attr?:{} => \(@item:a, ...)
            let @ = ranked(a.name.'');
            let v = a.value.'';
            (:@, @value: cond {{@} & nums: //eval.value(v), _: v}),
        text: //seq.join("", node.text?:{} >> .''),
        children: node.node?:{} >> transformNode(.),
    );
    (header: //seq.join(' ', ast.header?.'':{}), root: transformNode(ast.node))
;

# Serializes an SVG model to SVG XML.
let toSvg = \m
    let attrToString = \as $`${as => $`${.@}="${.@value}"` orderby .:: }`;
    let rec toString = \n
        cond {
            n.children?:{}: $`
                <${n.@tag} ${attrToString(n.attrs)}>
                    ${n.children >> toString(.)::\i}${n.text}
                </${n.@tag}>
            `,
            _: $`<${n.@tag} ${attrToString(n.attrs)}>${n.text}</${n.@tag}>`,
        }
    ;

    $`
        ${m.header?:''}
        ${toString(m.root)}
    `
;

# Manipulation functions

# Returns the ranked tag of the node.
let tag = \node ranked(node.@tag);
# Returns the first g node.
let g = \svg ranked(svg.root.children where tag(.@item) = 'g')(0);
# Returns all nodes with the given tag.
let byTag = \svg \t (g(svg).children where tag(.@item) = t) => .@item;

# Returns the uppermost y coordinate of the node.
let getY = \n 
    let py = \poly //eval.value(//seq.split(',', poly.attrs('points'))(1));
    n.attrs('y')?:{} || n.attrs('y1')?:{} || py(n)
;

# Returns the nodes most closely associated with the given text.
let byText = \svg \text
    let texts = byTag(svg, 'text') where ranked(.text) = ranked(text);
    //rel.union({'line', 'polygon'} => \t
        let elts = byTag(svg, t) orderby getY(.);
        texts => getY(.) => \y ranked(elts where getY(.@item) > y)(0)
    ) | texts
;

# Returns the SVG with the text colored.
let colored = \svg \color \nodes
    let tags = nodes => .@tag;
    let strokeRe = //re.compile('stroke: [^;]+');
    let strokeWidthRe = //re.compile('stroke-width: [^;]+');
    svg +> (root: svg.root +> (children: svg.root.children >>
        cond tag(.) {'g': . +> (children: .children >>
            cond {{.@tag} & tags: . +> (attrs: .attrs >>> \k \v
                cond k {
                    'style': strokeWidthRe.sub('stroke-width: 2.0', strokeRe.sub($`stroke: ${color}; cursor: pointer`, v)),
                    'fill': color,
                    _: v,
                }),
                _: .,
            }),
        _: .,
    }))
;

(
    macro: (
        @grammar: //{./svg_grammar},
        @transform: (doc: transformDoc),
    ),
    :toSvg,
    :byText,
    :colored,
)
