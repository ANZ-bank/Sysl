# Generates a CSV data dictionary for model.sysl.

let syslDescriptor = //encoding.proto.descriptor(//os.file('sysl.pb'));
let model = //encoding.proto.decode(syslDescriptor, 'Module' , //os.file('model.pb'));

# Returns the description attribute of the given type.
let getDescription = \type //seq.trim_suffix('\n', type.attrs?('description')?.s:{});

# Transforms a type specification into a set of field specifications.
let toFields = \type
    let fields = type.tuple?.attr_defs:{};
    fields => \(@:fieldName, @value:field) (
        typeDesc:  getDescription(type) || '?',
        :fieldName,
        fieldType:  field.primitive?:'?',
        fieldDesc:  getDescription(field) || '?',
    )
;

# Returns the type of an application (DB or API).
let appType = \app cond app {(attrs: {'~db': ...}, ...): 'DB', _: 'API'};

# Transforms a module to a data dictionary.
let toDataDict = \m 
    let typedApps = m.apps where .@value.types?:{};
    //rel.union(typedApps => \(@:appName, @value:app)
        cond appName {
            # Exclude uninteresting apps.
            'google_api': {},
            'google_protobuf': {},
            _: //rel.union(app.types => \(@:typeName, @value:type)
                toFields(type) => \(:typeDesc, :fieldName, :fieldType, :fieldDesc)
                    # TODO: Correctly populate dummy fields.
                    (
                        action: '?',
                        plat: '?',
                        tech: '?',
                        :fieldName,
                        objType: cond appType(app) {'DB': 'Table', 'API': 'API', _: '?'},
                        container: appName,
                        :typeName,
                        :typeDesc,
                        fieldTerm: '?',
                        :fieldDesc,
                        :fieldType,
                    )
            )
        }
    )
;

# Transforms a data dictionary into a CSV file per the Metadata Template.
let toCsv = \dd 
    let cols = [
        (key: 'action',    label:'Action'),
        (key: 'plat',      label:'Platform Name'),
        (key: 'tech',      label:'Technology Name'),
        (key: 'fieldName', label:'Physical Attribute Name'),
        (key: 'objType',   label:'Physical Object Type'),
        (key: 'container', label:'Physical Object Container Name'),
        (key: 'typeName',  label:'Physical Object Name'),
        (key: 'typeDesc',  label:'Physical Object Description'),
        (key: 'fieldTerm', label:'Business Term'),
        (key: 'fieldDesc', label:'Attribute Business Description'),
    ];
    let headings = $`${cols >> .label::, }`;

    let rows = (dd orderby [.container, .fieldName]) >>
        $`${.action}, ${.plat}, ${.tech}, ${.fieldName}, ${.objType}, ${.container}, ${.typeName}, ${.typeDesc}, ${.fieldTerm}, ${.fieldDesc}`;
    $`${(rows | {(@: -1, @item: headings)}) >> . ::\n}`
;

toCsv(toDataDict(model))
