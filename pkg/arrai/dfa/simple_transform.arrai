let sysl = //{./../sysl};
let model = sysl.normalize(sysl.polish(sysl.load('out/model.pb')));

let dataflow = \stmt stmt.ret?.payload.attr?.dataflow?:{};

let split = \str
    //{./../util}.invokeMacro((
        @grammar: {://grammar.lang.wbnf:str -> a=\w+ ("." b=\w+)*; .wrapRE -> /{\s*()\s*};:},
        @transform: (str: \s [s.a.''] ++ (s.b?:{} >> .'') ++ [{},{}]),
    ), str)
;
let extract = \m \(:appName, :type, ...)
    let [a, b, c, ...] = split(type);
    cond {
        {a} & (m.apps => .appName): (appName: a, typeName: b, fieldName: c),
        {a} & (m.types => .typeName): (:appName, typeName: a, fieldName: b),
        _: (:appName, typeName: {}, fieldName: {}),
    }
;

let transforms = \m //rel.union(
    m.stmts where .stmt.ret?:{} =>
        let (:appName, :epName, :stmt, ...) = .;
        let extract = \type extract(m, (:appName, :type));
        let df = dataflow(stmt);
        let base = (:appName, :epName, to: extract(stmt.ret.payload.type));
        cond df {
            {}: m.fields <&> (m.types where (:.appName, :.typeName) = (:base.to.appName, :base.to.typeName)) => 
                let to = base.to +> (:.fieldName);
                base +> (:to, from: to, description: '1:1 transform'),
            _: (df => \(@:toField, @value:fromFields)
                let enhance = \fromField
                    base +> (
                            to: base.to +> extract(toField),
                            from: extract(fromField),
                            description: '???',
                    );
                cond fromFields {
                    [...]: fromFields => enhance(.@item),
                    _:     {enhance(fromFields)},
            }) -> //rel.union(.)
        }
);

transforms(model)
