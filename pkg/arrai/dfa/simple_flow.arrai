let sysl = //{./../sysl};
let model = sysl.normalize(sysl.polish(sysl.load('out/model.pb')));

let transforms = //{./simple_transform};

# Returns a model of the lineage of a field.
let flow = \m \query
    # True if app and type names match, and field names match iff present in a.
    # Note: order matters.
    let equalish = \a \b
        a.appName = b.appName && a.typeName = b.typeName &&
        (!a.fieldName || a.fieldName = b.fieldName);
    
    # Truthy if transform t1 can "feed into" t2 by way of a call.
    let isEdge = \m \t1 \t2 
        equalish(t2.from, t1.to) &&
        (m.calls where
            (.to.appName = t1.appName || !t1.appName) &&
            (.to.epName = t1.epName || !t1.epName) &&
            .from.appName = t2.appName &&
            .from.epName = t2.epName
        )
    ;
    let rec join = \explored \frontier
        let explored = explored | frontier;
        # Find downstream transforms: places where the explored outputs are used.
        let newFrontier = (frontier => \f
            transforms where isEdge(m, f, .) => 
                . +> (in: (:f.appName, :f.epName))
                    +> cond {!f.to.fieldName: (from: .from +> (fieldName: {})), _: ()}
        ) -> //rel.union(.) &~ explored;
        cond {
            newFrontier: join(explored, newFrontier),
            _: explored,
        }
    ;

    let sources = transforms where equalish(.to, query);
    join({}, sources)
;

# Returns the PlantUML for a diagram illustrating the flow.
let draw = \flow \query
    let label = \. $`${.appName}.${.typeName}${cond {.fieldName: $`.${.fieldName}`}}`;
    $`
        @startuml
        title ${label(query)}
        ${(flow where \x x.in?:{}) => $`
            [${.in.appName}] "${.in.epName}" --> "${.epName}" [${.appName}] : ${label(.from)}
        ` orderby .::\i}
        @enduml
    `
;

let query = (appName: 'Source', typeName: 'Foo', fieldName: 'x');
draw(flow(model, query), query)
