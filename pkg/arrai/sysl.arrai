# Performs transformations of Sysl models, producing "better" Sysl models.

# Loads and returns a Sysl model.
let load = \path
    let syslDescriptor = //encoding.proto.descriptor(//os.file('sysl.pb'));
    //encoding.proto.decode(syslDescriptor, 'Module' , //os.file(path));

# Extracts the set of pattern attributes of an element.
let patterns = \x x.attrs?('patterns')?.a.elt:{} => .@item.s;

# A macro to convert `ret` statement payload string to structured tuples.
# TODO: handle dynamic type (int, float etc)
let payloadMacro = (
    @grammar: {://grammar.lang.wbnf:
        payload -> (status ("<:" type)? | (status "<:")? type) attr?;
        type -> [^\[\n]*;
        status -> ("ok"|"error"|[1-5][0-9][0-9]);
        attr -> %!Array(nvp|modifier);
        nvp_item -> ('"' ([^"\\] | [\\][\\brntu'"])* '"' | "'" ([^''])* "'") | array=%!Array(nvp_item) | dict=%!Dict(nvp_item);
        nvp ->  name=\w+ "=" nvp_item;
        modifier -> "~" name=[\w\+]+;
        .wrapRE -> /{\s*()\s*};
        .macro Array(child) {
            "[" (child):"," "]"
        }
        .macro Dict(child) {
            "{" entry=(key=child ":" value=child):"," "}"
        }
    :},
    @transform: (payload: //{./util}.simpleTransform),
);

# TODO: this is assuming that attribute values are similar to arrai strings
let rec buildNvp = \nvp cond nvp {
    (array: (nvp_item: i, ...), ...): (a: i => (:.@, @item: buildNvp(.@item))),
    (dict: (entry: i, ...), ...): (d: i => (
        @     : buildNvp(.@item.key.nvp_item),
        @value: buildNvp(.@item.value.nvp_item)
    )),
    _: //eval.value(//seq.join('', nvp.''))
};

let name = //{./util}.remOffset;

# tries to fix type without full reference
let fixType = \apps \appName \typePayload
    # add trim whitespace function
    let typePayload = //{./util}.trimWhitespace(typePayload);
    let (:app, :type, :field) = //{./util}.unpackType(typePayload);
    let pack = //{./util}.packType;
    cond app {
        (''): pack((app: appName, :type, :field)),
        _: cond {
            (app <: apps): typePayload,
            _: pack((app: appName, type: [app] ++ type, :field))
        }
    }
;
# Converts a return statement payload into a tuple of its parts.
let parseReturn = \payload \apps \currApp
    let ret = //{./util}.invokeMacro(payloadMacro, payload);
    let retType = ret.type?:'';
    ret +> (
        type: fixType(apps, currApp, retType),
        attr: //grammar -> .parse(payloadMacro.@grammar, 'payload', payload).attr?:() -> \attr
                (
                    nvp: attr.nvp?:{} => (@: name(.@item.name.''), @value: buildNvp(.@item.nvp_item)),
                    modifier: attr.modifier?:{} => name(.@item.name.'')
                )
    )
;

# Replaces all `ret` payloads with structured tuples.
let polishReturns = \m
    let apps = m.apps => .@;
    let tweak = \. \currApp
        . +> (ret: .ret +> (payload: parseReturn(.ret.payload, apps, currApp)));

    m +> (apps: m.apps?:{} >>> \currApp \a
        a +> (endpoints: a.endpoints?:{} >> \p
            p +> (stmt: p.stmt?:[] >> \s
                cond s.ret?:{} {{}: s, _: tweak(s, currApp)}
            )
        )
    )
;

# Applies polish functions to the appropriate elements of a Sysl model.
let polish = \m
    polishReturns(m)
    # TODO: More polish.
;

# Returns a normalised, relational model of a Sysl model.
let normalize = \m
    let apps = m.apps => \(@:appName, @value:app)
        (
            :appName,
            appPatterns: patterns(app),
        )
    ;
    let endpoints = (m.apps => \(@:appName, @value:app)
        app.endpoints?:{} => \(@:epName, ...)
            (
                :appName,
                :epName,
            )
    ) -> //rel.union(.);
    let stmts = (m.apps => \(@:appName, @value:app)
        (app.endpoints?:{} => \(@:epName, @value:ep)
            ep.stmt?:{} =>
                (
                    :appName,
                    :epName,
                    stmt: .@item +> (
                        # TODO: Use stmt.source_context once populated by parser.
                        # https://github.com/anz-bank/sysl/issues/990
                        source_context: ep.source_context +> (:.@),
                    ),
                )
        ) -> //rel.union(.)
    ) -> //rel.union(.);
    let calls = stmts where .stmt.call?:{} => \(:appName, :epName, :stmt)
        (
            from: (
                :appName,
                :epName,
            ),
            to: (
                appName: stmt.call.target.part.@item,
                epName: stmt.call.endpoint,
            ),
            :stmt.source_context,
        )
    ;
    let types = (m.apps => \(@:appName, @value:app)
        app.types?:{} => \(@:typeName, @value: t)
            (
                :appName,
                :typeName,
            )
        ) -> //rel.union(.) where .
    ;
    let fields = (m.apps => \(@:appName, @value:app)
        (app.types?:{} => \(@:typeName, @value:type)
            type.relation?.attr_defs?:{} => \(@:fieldName, @value:field)
                let patterns = patterns(field);
                (
                    :appName,
                    :typeName,
                    :fieldName,
                    fieldType: cond field {
                        (primitive:p, ...): p,
                        (type_ref:(ref:(path:p), ...), ...): //seq.join('.', p),
                        _: '?',
                    },
                    fk: cond field.type_ref?.ref.path:{} {
                        [t, f]: (:appName, typeName: t, fieldName: f)
                    },
                    :patterns,
                    pk: !!({'pk'} & patterns),
                    opt: field.opt?:{},
                )
        ) -> //rel.union(.) where .
    ) -> //rel.union(.);
    let transforms = //{./dfa/transforms}(m.apps);
    (
        :apps,
        :endpoints,
        :calls,
        :types,
        :fields,
        :transforms,
        # TODO:
        # :annotations, (aka attributes)
        :stmts,
        # :tags, (aka patterns)
    )
;

# Export the functions from the module.
(
    :load,
    :normalize,
    :parseReturn,
    :patterns,
    :polish,
)
#  -> //fmt.pretty(.polish(.load('out/model.pb')))
#  -> //fmt.pretty(parseReturn('ok <: Foo [dataflow={"a.b.c": "b", "c": ["d", "e"]}]'))
