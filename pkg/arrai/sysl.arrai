# Performs transformations of Sysl models, producing "better" Sysl models.

# Extracts the set of pattern attributes of an element.
let patterns = \x x.attrs?('patterns')?.a.elt:{} => .@item => .@item.s;

# A macro to convert `ret` statement payload string to structured tuples.
let payloadMacro = (
    @grammar: {://grammar.lang.wbnf:
        payload -> (status=("ok"|"error"|[1-5][0-9][0-9]) "<:"?)? type=[^ \t\[]*;
        .wrapRE -> /{\s*()\s*};
    :},
    @transform: (payload: //{./util}.simpleTransform),
);

# Converts a return statement payload into a tuple of its parts.
let parseReturn = \payload //{./util}.invokeMacro(payloadMacro, payload);

# Replaces all `ret` payloads with structured tuples.
let polishReturns = \m
    let tweak = \.
        . +> (@item: .@item +> 
                    (ret: .@item.ret +> 
                         (payload: parseReturn(.@item.ret.payload))));

    m.apps?:{} >> \a a.endpoints?:{} >> \p p.stmt?:[] >> 
        cond {
            .@item.ret?:{}: tweak(.),
            _: .,
        }
;

# Applies polish functions to the appropriate elements of a Sysl model.
let polish = \m
    polishReturns(m)
    # TODO: More polish.
;

# Returns a normalised, relational model of a Sysl model.
let normalize = \m
    let apps = m.apps => \(@:appName, @value:app, ...)
        (
            :appName,
        )
    ;
    let endpoints = //rel.union(m.apps => \(@:appName, @value:app, ...)
        app.endpoints?:{} => \(@:epName, @value:ep)
            (
                :appName,
                :epName,
            )
    );
    let calls = //rel.union(m.apps => \(@:appName, @value:app, ...)
        //rel.union(
            app.endpoints?:{} => \(@:epName, @value:e, ...)
                e.stmt?:{} => 
                    (
                        from: (
                            app: appName,
                            endpoint: epName,
                        ),
                        to: (
                            app: .@item.@item.call?.target.part.@item.@item:{},
                            endpoint: .@item.@item.call?.endpoint:{},
                        ),
                    )
        )
    ) where .to.endpoint;
    let types = //rel.union(m.apps => \(@:appName, @value:app)
        app.types?:{} => \(@:typeName, @value: t)
            (
                :appName,
                :typeName,
            )
        ) where .
    ;
    let fields = //rel.union(m.apps => \(@:appName, @value:app)
        //rel.union(app.types?:{} => \(@:typeName, @value:type)
            (type.relation).attr_defs?:{} => \(@:fieldName, @value:f)
                let patterns = patterns(f);
                (
                    :appName,
                    :typeName,
                    :fieldName,
                    fieldType: cond f {
                        (primitive:p, ...): p,
                        (type_ref:(ref:(path:p)), ...): //seq.join('.', p => .@item),
                        _: '?',
                    },
                    fk: cond f.type_ref?.ref.path:{} {
                        [a, b]: (type:$`${appName}.${a.@item}`, field:b.@item)
                    },
                    :patterns,
                    pk: !!({'pk'} & patterns),
                    opt: f.opt?:{},
                )
        ) where .
    );

    (
        :apps,
        :endpoints,
        :calls,
        :types,
        :fields,
    )
;

# Export the functions from the module.
(
    :parseReturn,
    :polish,
    :normalize,
)
#.normalize(//{./load_model})
