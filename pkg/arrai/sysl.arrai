# Performs transformations of Sysl models, producing "better" Sysl models.

# A macro to convert `ret` statement payload string to structured tuples.
let payloadMacro = (
    @grammar: {://grammar.lang.wbnf:
        payload -> (status=("ok"|"error"|[1-5][0-9][0-9]) "<:"?)? type=[^ \t\[]*;
        .wrapRE -> /{\s*()\s*};
    :},
    @transform: (payload: //{./util}.simpleTransform),
);

# Converts a return statement payload into a tuple of its parts.
let parseReturn = \payload //{./util}.invokeMacro(payloadMacro, payload);

# Replaces all `ret` payloads with structured tuples.
let polishReturns = \m
    let tweak = \.
        . +> (@item: .@item +> 
                    (ret: .@item.ret +> 
                         (payload: parseReturn(.@item.ret.payload))));

    m.apps?:{} >> \a a.endpoints?:{} >> \p p.stmt?:[] >> 
        cond {
            .@item.ret?:{}: tweak(.),
            _: .,
        }
;

# Applies polish functions to the appropriate elements of a Sysl model.
let polish = \m
    polishReturns(m)
    # TODO: More polish.
;

# Returns a normalised, relational model of a Sysl model.
let normalize = \m
    let apps = m.apps => \(@:name, @value:app, ...)
        (
            :name,
        )
    ;
    let endpoints = //rel.union(m.apps => \(@:appName, @value:app, ...)
        app.endpoints?:{} => \(@:epName, @value:ep)
            (
                app: appName,
                name: epName,
            )
    );
    let calls = //rel.union(m.apps => \(@:appName, @value:app, ...)
        //rel.union(
            app.endpoints?:{} => \(@:epName, @value:e, ...)
                e.stmt?:{} => 
                    (
                        from: (
                            app: appName,
                            endpoint: epName,
                        ),
                        to: (
                            app: .@item.@item.call?.target.part.@item.@item:{},
                            endpoint: .@item.@item.call?.endpoint:{},
                        ),
                    )
        )
    ) where .to.endpoint;
    (
        :apps,
        :endpoints,
        :calls,
    )
;

# Export the functions from the module.
(
    :parseReturn,
    :polish,
    :normalize,
)
