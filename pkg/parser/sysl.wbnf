.import stmt.wbnf
.import endpoints.wbnf
.import views.wbnf

// Sysl grammar

sysl_file -> (import | EOL)* (application | EOL)+
           | (import | EOL)+ (application | EOL)*;


// -------------- Imports --------------- //
import  -> "import"  prefix=("//"|"/")? PATH ( "as"  reference)? ("~" mode=NAME)? ;


// -------------- Events --------------- //

event  ->  "<->" APPNAME params? attribs? ":" COMMENT*
        ( SHORTCUT | %!Indented(stmt));
subscribe  ->  APPNAME "->" NAME params? attribs? ":" COMMENT*
        ( SHORTCUT | %!Indented(stmt));

// -------------- Enums --------------- //

enum  -> "!enum" name=NAME attribs? ":" COMMENT* (SHORTCUT COMMENT_NO_NL*| %!Indented(enumeration | COMMENT_NO_NL)) {
        enumeration -> name=NAME ":" DIGITS COMMENT_NO_NL*;
};

// -------------- Mixin --------------- //

mixin -> "-|>" APPNAME;

// -------------- Applications --------------- //
application ->  APPNAME QSTRING?
        attribs? ":" COMMENT*  %!Indented(app_decl) EOL?;

app_decl   -> annotation
            | COMMENT_NO_NL
            | SHORTCUT
            | type_decl
            | endpoint
            | event
            | subscribe
            | view
            | mixin;


// -------------- Types --------------- //

type_decl -> table | facade | alias | union | enum;

table -> mode=("!table"|"!type") NAME attribs?  ":" COMMENT*
     (SHORTCUT | %!Indented(COMMENT_NO_NL | table_row COMMENT_NO_NL?)) {
        table_row -> COMMENT_NO_NL
                   | table_field
                   | annotation
                   | table
                   | SHORTCUT;

        table_field -> field optional="?"? attribs? (":" annotations)?;
     };
facade -> "!wrap" NAME  ":" COMMENT*
     %!Indented(("!table"|"!type"|"!union") NAME inplace_table_def?) {
            inplace_table_def -> ":"  %!Indented(NAME attribs?);
        };

alias -> "!alias" NAME attribs?  ":" COMMENT*
        (indented_alias_def | inline_alias_def) {
        inline_alias_def -> annotation* (collection_type | type_spec);

        indented_alias_def -> (annotations INDENT_SEP | \n+ INDENT)
                          (collection_type | type_spec)
                          (INDENT_SEP annotation:INDENT_SEP)?;
};

union -> "!union" NAME attribs?  ":"
    ( SHORTCUT |
         %!Indented(COMMENT_NO_NL | user_defined_type=NAME | annotation | SHORTCUT )
    );

collection_type -> ("set"|"sequence") "of" type_spec;


// -------------- Common Rules --------------- //
attribs     ->  "[" @:"," "]"
             > pattern=("~" NAME:"+")
             | attr=(NAME "=" ( array_of_array | array_of_strings | QSTRING));
array_of_strings -> "[" (QSTRING:",")? "]";
array_of_array   -> "[" (array_of_strings:",")? "]";

array_size -> "(" min=("0"|DIGITS) ".." max=DIGITS? ")";

annotation -> "@" var_name=([a-zA-Z_][-\w.]*) "=" value=(QSTRING | array_of_strings | multi_line_docstring);

annotations -> %!Indented(annotation);

multi_line_docstring -> ":" %!Indented("|" TEXT);

http_path_var_with_type -> "{" var=(NAME | DIGITS) "<:" type=(NativeDataTypes | reference) "}";

http_path_part  ->  (NAME | DIGITS | [-._~] | ("%" [0-9a-fA-F]{2}))+ { .wrapRE -> /{()};};
http_path -> "/" ((http_path_part | http_path_var_with_type):"/")?;

type_spec -> (NativeDataTypes | reference)
             SizeSpec=("(" \d+ (array=".."|sized=".")? \d* ")")?;

// -------------- Tokens --------------- //
NAME    -> [a-zA-Z_][-a-zA-Z0-9_]*;
PATH    -> /{[a-zA-Z0-9._-]+}:"/";
DIGITS -> [1-9][0-9]*;
TEXT -> [^(\r?\n)]+;
TEXT_LINE -> /{\s* ( [^\s:(] [^(\r\n:]* [^\s\r\n(:] )};
APPNAME -> (pkg=@):"." > (app=@):"::" > APPNAME_PART;
APPNAME_PART -> (/{[a-zA-Z_][-\w]*(?:[-\t\_]*\w+)*} | QSTRING)+;
PREDICATE -> [^\r\n:]+;
SHORTCUT -> "...";
HTTP_VERBS -> /{\b(GET | POST | DELETE | PUT | PATCH)\b};
NativeDataTypes -> /{\b(int32 | int64 | int |
                float | string | datetime | date |
                bool | decimal)\b};

reference ->  pkg=(NAME:"::" ".")? APPNAME;

COMMENT_NO_NL -> "#" [^\n]*;
COMMENT -> COMMENT_NO_NL "\n";
EOL     -> (COMMENT+ | [\_\t]*\n);
QSTRING -> /{ " (?: \\. | [^\\"] )* "
           | ' (?: \\. | [^\\'] )* '
           };

.wrapRE -> /{(\n (?:[\_\t]+ \n)?)+} | \n+ | \s+ | /{[\_\t]*()[\_\t]*};

INDENT      -> %level="" \s+;
INDENT_SEP  -> /{(\n (?:[\_\t]+ \n)?)+} %level;

.macro Indented(child) {/{(\n (?:[\_\t]+ \n)?)+} level=INDENT child:INDENT_SEP}
