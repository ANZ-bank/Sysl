package mermaid

import (
	"errors"
	"fmt"
	"regexp"

	"github.com/anz-bank/sysl/pkg/sysl"
)

const projDir = "../../"

var startElse = regexp.MustCompile("^else.*")
var isElse = regexp.MustCompile("^else$")
var isLoop = regexp.MustCompile("^loop.*")

func GenerateMermaidSequenceDiagram(m *sysl.Module, appname string, epname string,
	previousapp string, indent int, thestart bool) (string, error) {
	var result string
	if thestart {
		result = "%% AUTOGENERATED CODE -- DO NOT EDIT!\n\nsequenceDiagram\n"
		if err := validAppnameAndEndpoint(m, appname, epname); err != nil {
			return "", err
		}
		result += fmt.Sprintf(" %s->>%s: %s\n", previousapp, appname, epname)
	}
	statements := m.Apps[appname].Endpoints[epname].GetStmt()
	result += printStatements(m, statements, appname, previousapp, indent, thestart)
	return result, nil
}

func printStatements(m *sysl.Module, statements []*sysl.Statement, appname string,
	previousapp string, indent int, thestart bool) string {
	var result string
	count := 0
	for _, statement := range statements {
		switch c := statement.Stmt.(type) {
		case *sysl.Statement_Group:
			result += fmt.Sprintf("%s%s\n", addIndent(indent), c.Group.Title)
			result += printStatements(m, c.Group.Stmt, appname, previousapp, indent+1, thestart)
			isloop := isLoop.MatchString(c.Group.Title)
			iselse := isElse.MatchString(c.Group.Title)
			if isloop || iselse {
				result += fmt.Sprintf("%send\n", addIndent(indent))
			}
		case *sysl.Statement_Call:
			nextapp := c.Call.Target.Part[0]
			nextep := c.Call.Endpoint
			result += callStatement(appname, nextep, nextapp, indent)
			previous := appname
			out, err := GenerateMermaidSequenceDiagram(m, nextapp, nextep, previous, indent, false)
			if err != nil {
				panic("Error in generating sequence diagram")
			}
			result += out
		case *sysl.Statement_Ret:
			retep := c.Ret.Payload
			result += retStatement(appname, retep, previousapp, indent, thestart)
		case *sysl.Statement_Action:
			result += actionStatement(appname, c.Action.Action, indent)
		case *sysl.Statement_Cond:
			result += fmt.Sprintf("%salt %s\n", addIndent(indent), c.Cond.Test)
			result += printStatements(m, c.Cond.Stmt, appname, previousapp, indent+1, thestart)
			if count+1 < len(statements) {
				switch temp := statements[count+1].Stmt.(type) {
				case *sysl.Statement_Group:
					ok := startElse.MatchString(temp.Group.Title)
					if !ok {
						result += fmt.Sprintf("%send\n", addIndent(indent))
					}
				default:
					result += fmt.Sprintf("%send\n", addIndent(indent))
				}
			} else {
				result += fmt.Sprintf("%send\n", addIndent(indent))
			}
		default:
			panic("Unrecognised statement type")
		}
		count++
	}
	return result
}

func validAppnameAndEndpoint(m *sysl.Module, appname string, epname string) error {
	if _, ok := m.Apps[appname]; !ok {
		return errors.New("invalid app name")
	}
	if _, ok := m.Apps[appname].Endpoints[epname]; !ok {
		return errors.New("invalid endpoint")
	}
	return nil
}

func callStatement(appname string, epname string, nextapp string, indent int) string {
	var out = addIndent(indent)
	out += fmt.Sprintf("%s->>+%s: %s\n", appname, nextapp, epname)
	return out
}

func retStatement(appname string, epname string, previousapp string, indent int, thestart bool) string {
	var out = addIndent(indent)
	if thestart {
		out += fmt.Sprintf("%s-->>%s: %s\n", appname, previousapp, epname)
	} else {
		out += fmt.Sprintf("%s-->>-%s: %s\n", appname, previousapp, epname)
	}
	return out
}

func actionStatement(appname string, action string, indent int) string {
	var out = addIndent(indent)
	out += fmt.Sprintf("%s->>%s: %s\n", appname, appname, action)
	return out
}

func addIndent(indent int) string {
	var out string
	for i := 0; i < indent; i++ {
		out += " "
	}
	return out
}
