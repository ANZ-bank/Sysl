package datamodeldiagram

import (
	"fmt"
	"strings"

	"github.com/anz-bank/sysl/pkg/sysl"
	"github.com/anz-bank/sysl/pkg/syslwrapper"
)

type externalLink struct {
	firstType, secondType string
}

func GenerateDataModelDiagram(m *sysl.Module) (string, error) {
	mapper := syslwrapper.MakeAppMapper(m)
	mapper.IndexTypes()
	mapper.ConvertTypes()
	return generateDataModelDiagramHelper(mapper.SimpleTypes, &[]externalLink{})
}

func generateDataModelDiagramHelper(mapper map[string]*syslwrapper.Type, externalLinks *[]externalLink) (string, error) {
	var result string
	result = "%% AUTOGENERATED CODE -- DO NOT EDIT!\n\nclassDiagram\n"
	for appType, value := range mapper {
		switch value.Type {
			case "relation", "tuple":
				result += fmt.Sprintf(" class %s{\n", cleanString(appType))
				result += printProperties(value.Properties, appType, externalLinks)
				result += " }\n"
			case "enum":
				result += fmt.Sprintf(" class %s{\n", cleanString(appType))
				result += printEnum(value.Enum)
				result += " }\n"
		default:
			panic("Unrecognised type")
		}
	}
	for _, eLink := range *externalLinks {
		result += fmt.Sprintf("%s <-- %s\n", eLink.firstType, eLink.secondType)
	}
	return result, nil
}

func printProperties(properties map[string]*syslwrapper.Type, appType string, externalLinks *[]externalLink) string {
	var result string
	if properties != nil {
		//TODO: sort elements in map for uniformity
		for typeName, value := range properties {
			switch value.Type {
				case "int", "bool", "float", "decimal", "string", "string_8", "bytes", "date", "datetime", "xml", "uuid":
					result += fmt.Sprintf("  %s %s\n", value.Type, cleanString(typeName))
				case "ref":
					pair := externalLink{cleanString(appType), cleanString(value.Reference)}
					if !externalLinksContain(*externalLinks, pair) {
						*externalLinks = append(*externalLinks, pair)
					}
					result += fmt.Sprintf("  %s %s\n", cleanString(value.Reference), cleanString(typeName))
				case "list", "set":
					//TODO: check if list of lists is possible
					if value.Items[0].Type == "ref" {
						pair := externalLink{cleanString(appType), cleanString(value.Items[0].Reference)}
						if !externalLinksContain(*externalLinks, pair) {
							*externalLinks = append(*externalLinks, pair)
						}
						result += fmt.Sprintf("  List<%s> %s\n", cleanString(value.Items[0].Reference), cleanString(typeName))
					} else {
						result += fmt.Sprintf("  List<%s> %s\n", cleanString(value.Items[0].Type), cleanString(typeName))
					}
				case "map":
					result += ""
			default:
				panic("Unrecognised type")
			}
		}
	}
	return result
}

func printEnum(enum map[int64]string) string {
	var result string
	if enum != nil {
		//TODO: sort keys in map for uniformity
		for key, value := range enum {
			result += fmt.Sprintf("  %s %d\n", value, key)
		}
	}
	return result
}

func externalLinksContain(f []externalLink, s externalLink) bool {
	for _, a := range f {
		if a == s {
			return true
		}
	}
	return false
}

func cleanString(temp string) string {
	temp = strings.ReplaceAll(temp, " ", "")
	temp = strings.ReplaceAll(temp, "{", "_")
	temp = strings.ReplaceAll(temp, "}", "_")
	temp = strings.ReplaceAll(temp, "[", "_")
	temp = strings.ReplaceAll(temp, "]", "_")
	temp = strings.ReplaceAll(temp, "\"", "")
	temp = strings.ReplaceAll(temp, "~", "")
	temp = strings.ReplaceAll(temp, ":", "_")
	return temp
}
