// Code generated by "Ï‰BNF gen" DO NOT EDIT.
// $ wbnf gen --grammar pkg/parser/sysl.wbnf --pkg parser --start sysl_file --output cmd/syslwbnf/parser/wbnfoutput.go
package parser

import (
	"github.com/arr-ai/wbnf/ast"
	"github.com/arr-ai/wbnf/parser"
)

func Grammar() parser.Parsers {
	return parser.Grammar{".wrapRE": parser.Oneof{parser.RE(`\n+`),
		parser.RE(`\s+`),
		parser.RE(`[ ]*()[ ]*`)},
		"APPNAME": parser.Stack{parser.Delim{Term: parser.Eq(`pkg`,
			parser.At),
			Sep: parser.S(`.`)},
			parser.Delim{Term: parser.Eq(`app`,
				parser.At),
				Sep: parser.S(`::`)},
			parser.Rule(`APPNAME_PART`)},
		"APPNAME_PART": parser.Some(parser.Oneof{parser.RE(`[a-zA-Z_][-\w]*(?:[-\t ]*\w+)*`),
			parser.Rule(`QSTRING`)}),
		"COMMENT": parser.Seq{parser.Rule(`COMMENT_NO_NL`),
			parser.CutPoint{parser.S(`
`)}},
		"COMMENT_NO_NL": parser.Seq{parser.CutPoint{parser.S(`#`)},
			parser.RE(`[^\n]*`)},
		"DIGITS": parser.RE(`[1-9][0-9]*`),
		"EOL": parser.Oneof{parser.Some(parser.Rule(`COMMENT`)),
			parser.RE(`[ \t]*\n`)},
		"HTTP_VERBS": parser.Oneof{parser.CutPoint{parser.S(`GET`)},
			parser.CutPoint{parser.S(`POST`)},
			parser.CutPoint{parser.S(`DELETE`)},
			parser.CutPoint{parser.S(`PUT`)},
			parser.CutPoint{parser.S(`PATCH`)}},
		"INDENT": parser.Seq{parser.REF{Ident: `level`,
			Default: parser.S(``)},
			parser.RE(`\s+`)},
		"INDENT_SEP": parser.Seq{parser.RE(`\n+`),
			parser.REF{Ident: `level`}},
		"NAME": parser.RE(`[a-zA-Z_][-a-zA-Z0-9_]*`),
		"NativeDataTypes": parser.Oneof{parser.CutPoint{parser.S(`int32`)},
			parser.CutPoint{parser.S(`int64`)},
			parser.CutPoint{parser.S(`int`)},
			parser.CutPoint{parser.S(`float`)},
			parser.CutPoint{parser.S(`string`)},
			parser.CutPoint{parser.S(`datetime`)},
			parser.CutPoint{parser.S(`date`)},
			parser.CutPoint{parser.S(`bool`)},
			parser.CutPoint{parser.S(`decimal`)}},
		"PATH": parser.Delim{Term: parser.RE(`[a-zA-Z0-9._-]+`),
			Sep: parser.S(`/`)},
		"PREDICATE": parser.RE(`[^\r\n:]+`),
		"QSTRING":   parser.RE(`"(?:\\.|[^\\"])*"|'(?:\\.|[^\\'])*'`),
		"SHORTCUT":  parser.CutPoint{parser.S(`...`)},
		"TEXT":      parser.RE(`[^(\r?\n)]+`),
		"TEXT_LINE": parser.RE(`\s*([^\s:(][^(\r\n:]*[^\s\r\n(:])`),
		"agg_func": parser.Seq{parser.Eq(`func`,
			parser.Oneof{parser.CutPoint{parser.S(`sum`)},
				parser.CutPoint{parser.S(`min`)},
				parser.CutPoint{parser.S(`max`)},
				parser.CutPoint{parser.S(`average`)}}),
			parser.S(`(`),
			parser.Opt(parser.Eq(`scopevar`,
				parser.Seq{parser.Rule(`NAME`),
					parser.S(`:`)})),
			parser.Delim{Term: parser.Eq(`args`,
				parser.Rule(`expr`)),
				Sep: parser.S(`,`)},
			parser.S(`)`)},
		"alias": parser.Seq{parser.CutPoint{parser.S(`!alias`)},
			parser.Rule(`NAME`),
			parser.Opt(parser.Rule(`attribs`)),
			parser.S(`:`),
			parser.Any(parser.Rule(`COMMENT`)),
			parser.Oneof{parser.Seq{parser.RE(`\n+`),
				parser.Eq(`level`,
					parser.Rule(`INDENT`)),
				parser.Delim{Term: parser.Rule(`alias_line`),
					Sep: parser.Rule(`INDENT_SEP`)}},
				parser.Rule(`alias_line`)}},
		"alias_line": parser.Seq{parser.Any(parser.Rule(`annotation`)),
			parser.Oneof{parser.Rule(`collection_type`),
				parser.Rule(`type_spec`)}},
		"annotation": parser.Seq{parser.CutPoint{parser.S(`@`)},
			parser.Eq(`var_name`,
				parser.Rule(`NAME`)),
			parser.S(`=`),
			parser.Eq(`value`,
				parser.Oneof{parser.Rule(`QSTRING`),
					parser.Rule(`array_of_strings`),
					parser.Rule(`multi_line_docstring`)})},
		"annotations": parser.Seq{parser.RE(`\n+`),
			parser.Eq(`level`,
				parser.Rule(`INDENT`)),
			parser.Delim{Term: parser.Rule(`annotation`),
				Sep: parser.Rule(`INDENT_SEP`)}},
		"any_func": parser.Seq{parser.Eq(`func`,
			parser.CutPoint{parser.S(`any`)}),
			parser.S(`(`),
			parser.Rule(`expr`),
			parser.S(`)`)},
		"app_decl": parser.Oneof{parser.Rule(`annotation`),
			parser.Rule(`COMMENT_NO_NL`),
			parser.Rule(`SHORTCUT`),
			parser.Rule(`type_decl`),
			parser.Rule(`endpoint`),
			parser.Rule(`event`),
			parser.Rule(`subscribe`),
			parser.Rule(`view`)},
		"application": parser.Seq{parser.Rule(`APPNAME`),
			parser.Opt(parser.Rule(`QSTRING`)),
			parser.Opt(parser.Rule(`attribs`)),
			parser.S(`:`),
			parser.Any(parser.Rule(`COMMENT`)),
			parser.Seq{parser.RE(`\n+`),
				parser.Eq(`level`,
					parser.Rule(`INDENT`)),
				parser.Delim{Term: parser.Rule(`app_decl`),
					Sep: parser.Rule(`INDENT_SEP`)}},
			parser.Opt(parser.Rule(`EOL`))},
		"array_of_array": parser.Seq{parser.S(`[`),
			parser.Opt(parser.Delim{Term: parser.Rule(`array_of_strings`),
				Sep: parser.S(`,`)}),
			parser.S(`]`)},
		"array_of_strings": parser.Seq{parser.S(`[`),
			parser.Opt(parser.Delim{Term: parser.Rule(`QSTRING`),
				Sep: parser.S(`,`)}),
			parser.S(`]`)},
		"array_size": parser.Seq{parser.S(`(`),
			parser.Eq(`min`,
				parser.Oneof{parser.CutPoint{parser.S(`0`)},
					parser.Rule(`DIGITS`)}),
			parser.S(`..`),
			parser.Opt(parser.Eq(`max`,
				parser.Rule(`DIGITS`))),
			parser.S(`)`)},
		"atom": parser.Oneof{parser.Rule(`expr_func`),
			parser.Eq(`set`,
				parser.Seq{parser.S(`{`),
					parser.Delim{Term: parser.Rule(`expr`),
						Sep: parser.S(`,`)},
					parser.S(`}`)}),
			parser.Eq(`atoms`,
				parser.Seq{parser.S(`[`),
					parser.Delim{Term: parser.Rule(`expr`),
						Sep: parser.S(`,`)},
					parser.S(`]`)}),
			parser.Eq(`empty_tuple`,
				parser.CutPoint{parser.S(`{:}`)}),
			parser.Seq{parser.S(`(`),
				parser.Rule(`expr`),
				parser.S(`)`)},
			parser.Eq(`literal`,
				parser.Oneof{parser.Eq(`decimal`,
					parser.RE(`[0-9]+[.][0-9]+`)),
					parser.Eq(`digits`,
						parser.RE(`[0-9]+`)),
					parser.Eq(`quote`,
						parser.Oneof{parser.Eq(`single`,
							parser.RE(`['][^']*[']`)),
							parser.Eq(`double`,
								parser.RE(`["]([^"\\]|[\\][\\brntu'"])*["]`))}),
					parser.Eq(`literal`,
						parser.Oneof{parser.S(`null`),
							parser.CutPoint{parser.S(`true`)},
							parser.CutPoint{parser.S(`false`)}})}),
			parser.Eq(`implied_dot`,
				parser.Oneof{parser.Rule(`atom_dot_relop`),
					parser.Rule(`navigate`),
					parser.Rule(`matching`),
					parser.Rule(`expr_table_of_op`)}),
			parser.Eq(`ident`,
				parser.Oneof{parser.Rule(`NAME`),
					parser.RE(`[a-zA-Z0-9_]+`),
					parser.Rule(`SHORTCUT`),
					parser.S(`.`)})},
		"atom_dot_relop": parser.Seq{parser.S(`.`),
			parser.Oneof{parser.Rule(`rank_func`),
				parser.Rule(`agg_func`),
				parser.Rule(`single_arg_func`),
				parser.Rule(`any_func`),
				parser.Rule(`count`),
				parser.Rule(`single_or_null`),
				parser.Rule(`snapshot`),
				parser.Rule(`first_func`),
				parser.Rule(`navigate`),
				parser.Rule(`matching`)}},
		"attribs": parser.Stack{parser.Seq{parser.S(`[`),
			parser.Delim{Term: parser.At,
				Sep: parser.S(`,`)},
			parser.S(`]`)},
			parser.Oneof{parser.Eq(`pattern`,
				parser.Seq{parser.S(`~`),
					parser.Delim{Term: parser.Rule(`NAME`),
						Sep: parser.S(`+`)}}),
				parser.Eq(`attr`,
					parser.Seq{parser.Rule(`NAME`),
						parser.S(`=`),
						parser.Oneof{parser.Rule(`array_of_array`),
							parser.Rule(`array_of_strings`),
							parser.Rule(`QSTRING`)}})}},
		"call_args": parser.Seq{parser.S(`(`),
			parser.Delim{Term: parser.Eq(`arg`,
				parser.Oneof{parser.Seq{parser.Rule(`NAME`),
					parser.S(`<:`),
					parser.Rule(`type_spec`)},
					parser.Some(parser.Oneof{parser.Rule(`QSTRING`),
						parser.Rule(`NAME`)})}),
				Sep: parser.S(`,`)},
			parser.S(`)`)},
		"call_stmt": parser.Seq{parser.Eq(`target`,
			parser.Oneof{parser.S(`.`),
				parser.Delim{Term: parser.Rule(`NAME`),
					Sep: parser.S(`::`)}}),
			parser.S(`<-`),
			parser.Eq(`target_endpoint`,
				parser.Rule(`TEXT_LINE`)),
			parser.Opt(parser.Rule(`call_args`))},
		"collection_type": parser.Seq{parser.Oneof{parser.S(`set`),
			parser.S(`sequence`)},
			parser.S(`of`),
			parser.Rule(`type_spec`)},
		"collector": parser.Seq{parser.CutPoint{parser.S(`.. * <- *`)},
			parser.S(`:`),
			parser.Oneof{parser.Rule(`SHORTCUT`),
				parser.Seq{parser.RE(`\n+`),
					parser.Eq(`level`,
						parser.Rule(`INDENT`)),
					parser.Delim{Term: parser.Rule(`collector_stmt`),
						Sep: parser.Rule(`INDENT_SEP`)}}}},
		"collector_call_stmt": parser.Seq{parser.Eq(`target`,
			parser.Rule(`APPNAME`)),
			parser.S(`<-`),
			parser.Eq(`target_endpoint`,
				parser.Rule(`APPNAME_PART`))},
		"collector_http_stmt": parser.Seq{parser.Eq(`method`,
			parser.Rule(`HTTP_VERBS`)),
			parser.S(`/`),
			parser.Delim{Term: parser.Oneof{parser.Rule(`http_path_part`),
				parser.Seq{parser.S(`{`),
					parser.Rule(`http_path_part`),
					parser.S(`}`)}},
				Sep: parser.S(`/`)},
			parser.Opt(parser.Seq{parser.S(`?`),
				parser.Delim{Term: parser.Seq{parser.Eq(`param`,
					parser.Rule(`NAME`)),
					parser.S(`=`),
					parser.Eq(`type`,
						parser.Oneof{parser.Rule(`NativeDataTypes`),
							parser.Rule(`NAME`)})},
					Sep: parser.S(`&`)}})},
		"collector_pubsub_call": parser.Seq{parser.Eq(`subscriber`,
			parser.Rule(`APPNAME`)),
			parser.S(`<-`),
			parser.Eq(`publisher`,
				parser.Rule(`APPNAME`)),
			parser.S(`->`),
			parser.Eq(`name`,
				parser.Rule(`NAME`))},
		"collector_stmt": parser.Seq{parser.Oneof{parser.Rule(`collector_http_stmt`),
			parser.Rule(`collector_pubsub_call`),
			parser.Rule(`collector_call_stmt`),
			parser.Eq(`action`,
				parser.Rule(`APPNAME`))},
			parser.Rule(`attribs`)},
		"count": parser.CutPoint{parser.S(`count`)},
		"else_stmt": parser.Seq{parser.S(`else`),
			parser.Opt(parser.Rule(`PREDICATE`)),
			parser.S(`:`),
			parser.Seq{parser.RE(`\n+`),
				parser.Eq(`level`,
					parser.Rule(`INDENT`)),
				parser.Delim{Term: parser.Rule(`stmt`),
					Sep: parser.Rule(`INDENT_SEP`)}}},
		"endpoint": parser.Oneof{parser.Rule(`rest_endpoint`),
			parser.Rule(`simple_endpoint`),
			parser.Rule(`collector`),
			parser.Rule(`event`)},
		"enum": parser.ScopedGrammar{Term: parser.Seq{parser.CutPoint{parser.S(`!enum`)},
			parser.Eq(`name`,
				parser.Rule(`NAME`)),
			parser.Opt(parser.Rule(`attribs`)),
			parser.S(`:`),
			parser.Any(parser.Rule(`COMMENT`)),
			parser.Oneof{parser.Seq{parser.Rule(`SHORTCUT`),
				parser.Any(parser.Rule(`COMMENT_NO_NL`))},
				parser.Seq{parser.RE(`\n+`),
					parser.Eq(`level`,
						parser.Rule(`INDENT`)),
					parser.Delim{Term: parser.Oneof{parser.Rule(`enumeration`),
						parser.Rule(`COMMENT_NO_NL`)},
						Sep: parser.Rule(`INDENT_SEP`)}}}},
			Grammar: parser.Grammar{".wrapRE": parser.Oneof{parser.RE(`\n+`),
				parser.RE(`\s+`),
				parser.RE(`[ ]*()[ ]*`)},
				"enumeration": parser.Seq{parser.Eq(`name`,
					parser.Rule(`NAME`)),
					parser.S(`:`),
					parser.Rule(`DIGITS`),
					parser.Any(parser.Rule(`COMMENT_NO_NL`))}}},
		"event": parser.Seq{parser.CutPoint{parser.S(`<->`)},
			parser.Rule(`NAME`),
			parser.Opt(parser.Rule(`params`)),
			parser.Opt(parser.Rule(`attribs`)),
			parser.S(`:`),
			parser.Any(parser.Rule(`COMMENT`)),
			parser.Oneof{parser.Rule(`SHORTCUT`),
				parser.Seq{parser.RE(`\n+`),
					parser.Eq(`level`,
						parser.Rule(`INDENT`)),
					parser.Delim{Term: parser.Rule(`stmt`),
						Sep: parser.Rule(`INDENT_SEP`)}}}},
		"expr": parser.Stack{parser.Delim{Term: parser.At,
			Sep: parser.Eq(`op`,
				parser.S(`??`))},
			parser.Delim{Term: parser.At,
				Sep: parser.Eq(`op`,
					parser.Seq{parser.S(`but`),
						parser.S(`not`)})},
			parser.Delim{Term: parser.At,
				Sep: parser.Eq(`op`,
					parser.Oneof{parser.S(`&&`),
						parser.S(`||`)})},
			parser.Delim{Term: parser.At,
				Sep: parser.Eq(`op`,
					parser.Oneof{parser.S(`|`),
						parser.S(`&`),
						parser.S(`and`),
						parser.S(`^`),
						parser.S(`xor`)})},
			parser.Delim{Term: parser.At,
				Sep: parser.Eq(`op`,
					parser.Oneof{parser.Seq{parser.Opt(parser.S(`!`)),
						parser.S(`in`)},
						parser.Seq{parser.Opt(parser.S(`!`)),
							parser.S(`contains`)},
						parser.S(`!=`),
						parser.S(`<=`),
						parser.S(`>=`),
						parser.S(`<`),
						parser.S(`>`),
						parser.S(`==`)})},
			parser.Delim{Term: parser.At,
				Sep: parser.Eq(`op`,
					parser.Oneof{parser.Eq(`add`,
						parser.S(`+`)),
						parser.Eq(`sub`,
							parser.S(`-`))})},
			parser.Delim{Term: parser.At,
				Sep: parser.Eq(`op`,
					parser.Oneof{parser.Eq(`mul`,
						parser.S(`*`)),
						parser.Eq(`mod`,
							parser.S(`%`)),
						parser.Eq(`div`,
							parser.S(`/`))})},
			parser.Delim{Term: parser.At,
				Sep: parser.Eq(`op`,
					parser.Eq(`pow`,
						parser.S(`**`)))},
			parser.Oneof{parser.Rule(`expr_if_else`),
				parser.Seq{parser.Rule(`atom`),
					parser.Any(parser.Rule(`relop`))},
				parser.Seq{parser.Eq(`unaryop`,
					parser.Oneof{parser.S(`+`),
						parser.S(`-`),
						parser.S(`!`),
						parser.S(`~`)}),
					parser.Rule(`atom`),
					parser.Any(parser.Rule(`relop`))}}},
		"expr_block": parser.Seq{parser.Opt(parser.Eq(`arg`,
			parser.Rule(`expr`))),
			parser.S(`->`),
			parser.Opt(parser.Seq{parser.S(`<`),
				parser.Rule(`expr_ret_type`),
				parser.S(`>`)}),
			parser.S(`(`),
			parser.Opt(parser.Eq(`scopevar`,
				parser.Rule(`NAME`))),
			parser.S(`:`),
			parser.Seq{parser.RE(`\n+`),
				parser.Eq(`level`,
					parser.Rule(`INDENT`)),
				parser.Delim{Term: parser.Rule(`expr_stmt`),
					Sep: parser.Rule(`INDENT_SEP`)}},
			parser.RE(`\s*`),
			parser.S(`)`),
			parser.Rule(`EOL`)},
		"expr_func": parser.Seq{parser.Eq(`func`,
			parser.Oneof{parser.CutPoint{parser.S(`autoinc`)},
				parser.CutPoint{parser.S(`str`)},
				parser.CutPoint{parser.S(`substr`)},
				parser.Rule(`NativeDataTypes`),
				parser.Rule(`NAME`)}),
			parser.S(`(`),
			parser.Opt(parser.Eq(`args`,
				parser.Delim{Term: parser.Rule(`expr`),
					Sep: parser.S(`,`)})),
			parser.S(`)`)},
		"expr_if_else": parser.Seq{parser.S(`if`),
			parser.Rule(`expr`),
			parser.Opt(parser.S(`?`)),
			parser.CutPoint{parser.S(`then`)},
			parser.Rule(`expr`),
			parser.S(`else`),
			parser.Rule(`expr`),
			parser.Rule(`EOL`)},
		"expr_ret_type": parser.Oneof{parser.Eq(`collection`,
			parser.Seq{parser.Oneof{parser.S(`set`),
				parser.S(`sequence`)},
				parser.S(`of`),
				parser.Opt(parser.Rule(`type_spec`))}),
			parser.Rule(`type_spec`)},
		"expr_stmt": parser.ScopedGrammar{Term: parser.Oneof{parser.Rule(`expr_table_assign`),
			parser.Rule(`expr_assign`),
			parser.Rule(`expr_dot_assign`),
			parser.Rule(`COMMENT_NO_NL`)},
			Grammar: parser.Grammar{".wrapRE": parser.Oneof{parser.RE(`\n+`),
				parser.RE(`\s+`),
				parser.RE(`[ ]*()[ ]*`)},
				"expr_assign": parser.Seq{parser.Opt(parser.CutPoint{parser.S(`let`)}),
					parser.Eq(`ident`,
						parser.Rule(`NAME`)),
					parser.S(`=`),
					parser.Oneof{parser.Rule(`expr_block`),
						parser.Rule(`expr`)}},
				"expr_dot_assign": parser.Seq{parser.Opt(parser.Eq(`obj`,
					parser.Rule(`NAME`))),
					parser.S(`.`),
					parser.Eq(`field`,
						parser.Rule(`NAME`))},
				"expr_table_assign": parser.Seq{parser.Opt(parser.RE(`table\s+of\s+`)),
					parser.Eq(`ident`,
						parser.Rule(`NAME`)),
					parser.S(`=`),
					parser.Oneof{parser.Rule(`expr_block`),
						parser.Rule(`expr`)}}}},
		"expr_table_of_op": parser.Seq{parser.Eq(`dot`,
			parser.Oneof{parser.CutPoint{parser.S(`?.`)},
				parser.S(`.`)}),
			parser.Opt(parser.RE(`table\s+of\s+`)),
			parser.Eq(`ident`,
				parser.Rule(`NAME`))},
		"facade": parser.ScopedGrammar{Term: parser.Seq{parser.CutPoint{parser.S(`!wrap`)},
			parser.Rule(`NAME`),
			parser.S(`:`),
			parser.Any(parser.Rule(`COMMENT`)),
			parser.Seq{parser.RE(`\n+`),
				parser.Eq(`level`,
					parser.Rule(`INDENT`)),
				parser.Delim{Term: parser.Seq{parser.Oneof{parser.S(`!table`),
					parser.S(`!type`),
					parser.S(`!union`)},
					parser.Rule(`NAME`),
					parser.Opt(parser.Rule(`inplace_table_def`))},
					Sep: parser.Rule(`INDENT_SEP`)}}},
			Grammar: parser.Grammar{".wrapRE": parser.Oneof{parser.RE(`\n+`),
				parser.RE(`\s+`),
				parser.RE(`[ ]*()[ ]*`)},
				"inplace_table_def": parser.Seq{parser.S(`:`),
					parser.Seq{parser.RE(`\n+`),
						parser.Eq(`level`,
							parser.Rule(`INDENT`)),
						parser.Delim{Term: parser.Seq{parser.Rule(`NAME`),
							parser.Opt(parser.Rule(`attribs`))},
							Sep: parser.Rule(`INDENT_SEP`)}}}}},
		"field": parser.Seq{parser.Rule(`NAME`),
			parser.Opt(parser.Rule(`array_size`)),
			parser.S(`<:`),
			parser.Oneof{parser.Rule(`field_type`),
				parser.Seq{parser.RE(`\n+`),
					parser.Eq(`level`,
						parser.Rule(`INDENT`)),
					parser.Delim{Term: parser.Rule(`field`),
						Sep: parser.Rule(`INDENT_SEP`)}}},
			parser.Opt(parser.Rule(`QSTRING`))},
		"field_type": parser.Oneof{parser.Rule(`collection_type`),
			parser.Seq{parser.Rule(`type_spec`),
				parser.Opt(parser.Eq(`optional`,
					parser.S(`?`))),
				parser.Opt(parser.Rule(`attribs`))}},
		"first_func": parser.Seq{parser.Eq(`func`,
			parser.CutPoint{parser.S(`first`)}),
			parser.Eq(`target`,
				parser.Oneof{parser.S(`null`),
					parser.Rule(`expr`)}),
			parser.CutPoint{parser.S(`by`)},
			parser.Opt(parser.Eq(`scopevar`,
				parser.Seq{parser.Rule(`NAME`),
					parser.S(`:`)})),
			parser.Rule(`rank_expr`),
			parser.S(`)`)},
		"for_stmt": parser.Seq{parser.Eq(`for_type`,
			parser.Oneof{parser.CutPoint{parser.S(`alt`)},
				parser.CutPoint{parser.S(`until`)},
				parser.CutPoint{parser.S(`for each`)},
				parser.CutPoint{parser.S(`for`)},
				parser.CutPoint{parser.S(`loop`)},
				parser.CutPoint{parser.S(`while`)}}),
			parser.Rule(`PREDICATE`),
			parser.S(`:`),
			parser.Seq{parser.RE(`\n+`),
				parser.Eq(`level`,
					parser.Rule(`INDENT`)),
				parser.Delim{Term: parser.Rule(`stmt`),
					Sep: parser.Rule(`INDENT_SEP`)}}},
		"group_stmt": parser.Seq{parser.Rule(`NAME`),
			parser.S(`:`),
			parser.Seq{parser.RE(`\n+`),
				parser.Eq(`level`,
					parser.Rule(`INDENT`)),
				parser.Delim{Term: parser.Rule(`stmt`),
					Sep: parser.Rule(`INDENT_SEP`)}}},
		"http_path": parser.Seq{parser.S(`/`),
			parser.Opt(parser.Delim{Term: parser.Oneof{parser.Rule(`http_path_part`),
				parser.Rule(`http_path_var_with_type`)},
				Sep: parser.S(`/`)})},
		"http_path_part": parser.ScopedGrammar{Term: parser.Some(parser.Oneof{parser.Rule(`NAME`),
			parser.Rule(`DIGITS`),
			parser.RE(`[-._~]`),
			parser.Seq{parser.S(`%`),
				parser.RE(`[0-9a-fA-F]{2}`)}}),
			Grammar: parser.Grammar{".wrapRE": parser.RE(`()`)}},
		"http_path_var_with_type": parser.Seq{parser.S(`{`),
			parser.Eq(`var`,
				parser.Oneof{parser.Rule(`NAME`),
					parser.Rule(`DIGITS`)}),
			parser.S(`<:`),
			parser.Eq(`type`,
				parser.Oneof{parser.Rule(`NativeDataTypes`),
					parser.Rule(`NAME`),
					parser.Rule(`reference`)}),
			parser.S(`}`)},
		"if_else": parser.Seq{parser.Rule(`if_stmt`),
			parser.Any(parser.Rule(`else_stmt`))},
		"if_stmt": parser.Seq{parser.S(`if`),
			parser.Rule(`PREDICATE`),
			parser.S(`:`),
			parser.Seq{parser.RE(`\n+`),
				parser.Eq(`level`,
					parser.Rule(`INDENT`)),
				parser.Delim{Term: parser.Rule(`stmt`),
					Sep: parser.Rule(`INDENT_SEP`)}}},
		"import": parser.Seq{parser.CutPoint{parser.S(`import`)},
			parser.Opt(parser.Eq(`prefix`,
				parser.Oneof{parser.CutPoint{parser.S(`//`)},
					parser.S(`/`)})),
			parser.Rule(`PATH`),
			parser.Opt(parser.Seq{parser.S(`as`),
				parser.Rule(`reference`)}),
			parser.Opt(parser.Seq{parser.S(`~`),
				parser.Eq(`mode`,
					parser.Rule(`NAME`))})},
		"matching": parser.Seq{parser.Opt(parser.S(`!`)),
			parser.S(`~`),
			parser.Opt(parser.Eq(`squiggly_args`,
				parser.Seq{parser.S(`[`),
					parser.Delim{Term: parser.Rule(`NAME`),
						Sep: parser.S(`,`)},
					parser.S(`]`)})),
			parser.S(`>`),
			parser.Eq(`rhs`,
				parser.Oneof{parser.Rule(`expr_table_of_op`),
					parser.Rule(`navigate`),
					parser.Seq{parser.S(`(`),
						parser.Rule(`expr`),
						parser.S(`)`)},
					parser.Rule(`NAME`)})},
		"method_def": parser.Seq{parser.Eq(`method`,
			parser.Rule(`HTTP_VERBS`)),
			parser.Opt(parser.Rule(`params`)),
			parser.Opt(parser.Rule(`query_param`)),
			parser.Opt(parser.Rule(`attribs`)),
			parser.S(`:`),
			parser.Seq{parser.RE(`\n+`),
				parser.Eq(`level`,
					parser.Rule(`INDENT`)),
				parser.Delim{Term: parser.Rule(`stmt`),
					Sep: parser.Rule(`INDENT_SEP`)}}},
		"multi_line_docstring": parser.Seq{parser.S(`:`),
			parser.Seq{parser.RE(`\n+`),
				parser.Eq(`level`,
					parser.Rule(`INDENT`)),
				parser.Delim{Term: parser.Seq{parser.S(`|`),
					parser.Rule(`TEXT`)},
					Sep: parser.Rule(`INDENT_SEP`)}}},
		"navigate": parser.Seq{parser.Opt(parser.Eq(`qn`,
			parser.S(`?`))),
			parser.S(`->`),
			parser.Opt(parser.Oneof{parser.Seq{parser.S(`set`),
				parser.S(`of`)},
				parser.Seq{parser.S(`sequence`),
					parser.S(`of`)}}),
			parser.Eq(`attr`,
				parser.Seq{parser.Opt(parser.S(`.`)),
					parser.Rule(`NAME`)}),
			parser.Opt(parser.Seq{parser.CutPoint{parser.S(`via`)},
				parser.Eq(`via`,
					parser.Rule(`NAME`))})},
		"one_of_cases": parser.Seq{parser.Eq(`one_of_case_label`,
			parser.Oneof{parser.Seq{parser.Rule(`QSTRING`),
				parser.S(`:`)},
				parser.Seq{parser.Rule(`NAME`),
					parser.S(`:`)},
				parser.Seq{parser.Rule(`TEXT_LINE`),
					parser.S(`:`)},
				parser.S(`:`)}),
			parser.Seq{parser.RE(`\n+`),
				parser.Eq(`level`,
					parser.Rule(`INDENT`)),
				parser.Delim{Term: parser.Rule(`stmt`),
					Sep: parser.Rule(`INDENT_SEP`)}}},
		"one_of_stmt": parser.Seq{parser.CutPoint{parser.S(`one`)},
			parser.S(`of`),
			parser.S(`:`),
			parser.Seq{parser.RE(`\n+`),
				parser.Eq(`level`,
					parser.Rule(`INDENT`)),
				parser.Delim{Term: parser.Rule(`one_of_cases`),
					Sep: parser.Rule(`INDENT_SEP`)}}},
		"params": parser.Seq{parser.S(`(`),
			parser.Delim{Term: parser.Oneof{parser.Rule(`field`),
				parser.Rule(`reference`)},
				Sep: parser.S(`,`)},
			parser.S(`)`)},
		"query_param": parser.Seq{parser.S(`?`),
			parser.Delim{Term: parser.Seq{parser.Eq(`ident`,
				parser.Rule(`NAME`)),
				parser.S(`=`),
				parser.Oneof{parser.Rule(`NativeDataTypes`),
					parser.Rule(`NAME`),
					parser.Seq{parser.S(`{`),
						parser.Rule(`NAME`),
						parser.S(`}`)}},
				parser.Opt(parser.Eq(`optional`,
					parser.S(`?`)))},
				Sep: parser.S(`&`)}},
		"rank_expr": parser.Delim{Term: parser.Seq{parser.Rule(`expr`),
			parser.Opt(parser.Eq(`func`,
				parser.Oneof{parser.CutPoint{parser.S(`asc`)},
					parser.CutPoint{parser.S(`desc`)}}))},
			Sep: parser.S(`,`)},
		"rank_func": parser.Seq{parser.Eq(`func`,
			parser.CutPoint{parser.S(`rank`)}),
			parser.Opt(parser.Seq{parser.S(`<`),
				parser.Rule(`type_spec`),
				parser.S(`>`)}),
			parser.S(`(`),
			parser.Rule(`rank_expr`),
			parser.S(`as`),
			parser.Eq(`as`,
				parser.Rule(`NAME`)),
			parser.S(`)`)},
		"reference": parser.Seq{parser.RE(`\s*`),
			parser.Opt(parser.Eq(`pkg`,
				parser.Seq{parser.Delim{Term: parser.Rule(`NAME`),
					Sep: parser.S(`::`)},
					parser.S(`.`)})),
			parser.Rule(`APPNAME`)},
		"relop": parser.Oneof{parser.Rule(`expr_table_of_op`),
			parser.Rule(`rank_func`),
			parser.Rule(`agg_func`),
			parser.Rule(`single_arg_func`),
			parser.Rule(`any_func`),
			parser.Rule(`count`),
			parser.Rule(`single_or_null`),
			parser.Rule(`snapshot`),
			parser.Rule(`first_func`),
			parser.Rule(`navigate`),
			parser.Rule(`matching`)},
		"rest_endpoint": parser.Seq{parser.Rule(`http_path`),
			parser.Opt(parser.Rule(`attribs`)),
			parser.S(`:`),
			parser.Seq{parser.RE(`\n+`),
				parser.Eq(`level`,
					parser.Rule(`INDENT`)),
				parser.Delim{Term: parser.Oneof{parser.Rule(`method_def`),
					parser.Rule(`rest_endpoint`)},
					Sep: parser.Rule(`INDENT_SEP`)}}},
		"ret_stmt": parser.Seq{parser.CutPoint{parser.S(`return`)},
			parser.Eq(`ret_val`,
				parser.Rule(`TEXT`))},
		"simple_endpoint": parser.Oneof{parser.Rule(`SHORTCUT`),
			parser.Seq{parser.Eq(`endpoint_name`,
				parser.Rule(`APPNAME`)),
				parser.Opt(parser.Rule(`QSTRING`)),
				parser.Opt(parser.Rule(`params`)),
				parser.Opt(parser.Rule(`attribs`)),
				parser.S(`:`),
				parser.Oneof{parser.Rule(`SHORTCUT`),
					parser.Seq{parser.RE(`\n+`),
						parser.Eq(`level`,
							parser.Rule(`INDENT`)),
						parser.Delim{Term: parser.Rule(`stmt`),
							Sep: parser.Rule(`INDENT_SEP`)}}}}},
		"single_arg_func": parser.Seq{parser.Eq(`func`,
			parser.Oneof{parser.CutPoint{parser.S(`where`)},
				parser.CutPoint{parser.S(`flatten`)}}),
			parser.S(`(`),
			parser.Opt(parser.Eq(`scopevar`,
				parser.Seq{parser.Rule(`NAME`),
					parser.S(`:`)})),
			parser.Rule(`expr`),
			parser.S(`)`)},
		"single_or_null": parser.Oneof{parser.CutPoint{parser.S(`singleOrNull`)},
			parser.CutPoint{parser.S(`single`)}},
		"snapshot": parser.CutPoint{parser.S(`snapshot`)},
		"stmt": parser.Seq{parser.Oneof{parser.Rule(`if_else`),
			parser.Rule(`for_stmt`),
			parser.Rule(`ret_stmt`),
			parser.Rule(`call_stmt`),
			parser.Rule(`one_of_stmt`),
			parser.Eq(`http_method_comment`,
				parser.Rule(`COMMENT_NO_NL`)),
			parser.Rule(`group_stmt`),
			parser.Rule(`text_stmt`),
			parser.Rule(`annotation`)},
			parser.Opt(parser.Rule(`attribs`))},
		"subscribe": parser.Seq{parser.Rule(`APPNAME`),
			parser.S(`->`),
			parser.Rule(`NAME`),
			parser.Opt(parser.Rule(`params`)),
			parser.Opt(parser.Rule(`attribs`)),
			parser.S(`:`),
			parser.Any(parser.Rule(`COMMENT`)),
			parser.Oneof{parser.Rule(`SHORTCUT`),
				parser.Seq{parser.RE(`\n+`),
					parser.Eq(`level`,
						parser.Rule(`INDENT`)),
					parser.Delim{Term: parser.Rule(`stmt`),
						Sep: parser.Rule(`INDENT_SEP`)}}}},
		"sysl_file": parser.Seq{parser.Any(parser.Oneof{parser.Rule(`import`),
			parser.Rule(`EOL`)}),
			parser.Some(parser.Oneof{parser.Rule(`application`),
				parser.Rule(`EOL`)})},
		"table": parser.ScopedGrammar{Term: parser.Seq{parser.Eq(`mode`,
			parser.Oneof{parser.S(`!table`),
				parser.S(`!type`)}),
			parser.Rule(`NAME`),
			parser.Opt(parser.Rule(`attribs`)),
			parser.S(`:`),
			parser.Any(parser.Rule(`COMMENT`)),
			parser.Seq{parser.RE(`\n+`),
				parser.Eq(`level`,
					parser.Rule(`INDENT`)),
				parser.Delim{Term: parser.Oneof{parser.Rule(`COMMENT_NO_NL`),
					parser.Seq{parser.Rule(`table_row`),
						parser.Opt(parser.Rule(`COMMENT_NO_NL`))}},
					Sep: parser.Rule(`INDENT_SEP`)}}},
			Grammar: parser.Grammar{".wrapRE": parser.Oneof{parser.RE(`\n+`),
				parser.RE(`\s+`),
				parser.RE(`[ ]*()[ ]*`)},
				"table_row": parser.Seq{parser.Seq{parser.Rule(`NAME`),
					parser.Opt(parser.Rule(`array_size`)),
					parser.S(`<:`)},
					parser.Eq(`type`,
						parser.Oneof{parser.Rule(`collection_type`),
							parser.Rule(`type_spec`)}),
					parser.Opt(parser.Eq(`optional`,
						parser.S(`?`))),
					parser.Opt(parser.Rule(`attribs`)),
					parser.Opt(parser.Seq{parser.S(`:`),
						parser.Rule(`annotations`)})}}},
		"text_stmt": parser.Oneof{parser.Eq(`doc_string`,
			parser.Seq{parser.S(`|`),
				parser.RE(`[^\r\n]*`)}),
			parser.Rule(`QSTRING`),
			parser.Seq{parser.Rule(`TEXT`),
				parser.Opt(parser.Seq{parser.S(`<-`),
					parser.Rule(`NAME`)})},
			parser.Rule(`SHORTCUT`)},
		"type_decl": parser.Oneof{parser.Rule(`table`),
			parser.Rule(`facade`),
			parser.Rule(`alias`),
			parser.Rule(`union`),
			parser.Rule(`enum`)},
		"type_spec": parser.Seq{parser.Oneof{parser.Rule(`NativeDataTypes`),
			parser.Rule(`reference`)},
			parser.Opt(parser.Eq(`SizeSpec`,
				parser.Seq{parser.S(`(`),
					parser.RE(`\d+`),
					parser.Opt(parser.Oneof{parser.Eq(`array`,
						parser.S(`..`)),
						parser.Eq(`sized`,
							parser.S(`.`))}),
					parser.RE(`\d*`),
					parser.S(`)`)}))},
		"union": parser.Seq{parser.S(`!union`),
			parser.Rule(`NAME`),
			parser.Opt(parser.Rule(`attribs`)),
			parser.S(`:`),
			parser.Oneof{parser.Rule(`SHORTCUT`),
				parser.Seq{parser.RE(`\n+`),
					parser.Eq(`level`,
						parser.Rule(`INDENT`)),
					parser.Delim{Term: parser.Oneof{parser.Rule(`COMMENT`),
						parser.Rule(`type_spec`),
						parser.Rule(`annotation`),
						parser.Rule(`SHORTCUT`)},
						Sep: parser.Rule(`INDENT_SEP`)}}}},
		"view": parser.Seq{parser.CutPoint{parser.S(`!view`)},
			parser.Rule(`NAME`),
			parser.S(`(`),
			parser.Opt(parser.Rule(`view_params`)),
			parser.S(`)`),
			parser.Opt(parser.Seq{parser.S(`->`),
				parser.Eq(`retType`,
					parser.Oneof{parser.Rule(`collection_type`),
						parser.Rule(`type_spec`)})}),
			parser.Oneof{parser.Eq(`abstract`,
				parser.CutPoint{parser.S(`[~abstract]`)}),
				parser.Seq{parser.Opt(parser.Rule(`attribs`)),
					parser.S(`:`),
					parser.Seq{parser.RE(`\n+`),
						parser.Eq(`level`,
							parser.Rule(`INDENT`)),
						parser.Delim{Term: parser.Rule(`expr_block`),
							Sep: parser.Rule(`INDENT_SEP`)}}}}},
		"view_params": parser.Delim{Term: parser.Seq{parser.Rule(`NAME`),
			parser.S(`<:`),
			parser.Oneof{parser.Rule(`collection_type`),
				parser.Rule(`type_spec`)}},
			Sep: parser.S(`,`)}}.Compile(nil)
}

type Stopper interface {
	ExitNode() bool
	Abort() bool
}
type nodeExiter struct{}

func (n *nodeExiter) ExitNode() bool { return true }
func (n *nodeExiter) Abort() bool    { return false }

type aborter struct{}

func (n *aborter) ExitNode() bool { return true }
func (n *aborter) Abort() bool    { return true }

var (
	NodeExiter = &nodeExiter{}
	Aborter    = &aborter{}
)

type IsWalkableType interface{ isWalkableType() }

type AggFuncFuncNode struct{ ast.Node }

func (AggFuncFuncNode) isWalkableType() {}
func (c AggFuncFuncNode) Choice() int   { return ast.Choice(c.Node) }

func (c AggFuncFuncNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type AggFuncNode struct{ ast.Node }

func (AggFuncNode) isWalkableType() {}
func (c AggFuncNode) AllArgs() []ExprNode {
	var out []ExprNode
	for _, child := range ast.All(c.Node, "args") {
		out = append(out, ExprNode{child})
	}
	return out
}

func (c AggFuncNode) OneFunc() *AggFuncFuncNode {
	if child := ast.First(c.Node, "func"); child != nil {
		return &AggFuncFuncNode{child}
	}
	return nil
}

func (c AggFuncNode) OneScopevar() *AggFuncScopevarNode {
	if child := ast.First(c.Node, "scopevar"); child != nil {
		return &AggFuncScopevarNode{child}
	}
	return nil
}

func (c AggFuncNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c AggFuncNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type AggFuncScopevarNode struct{ ast.Node }

func (AggFuncScopevarNode) isWalkableType() {}

func (c AggFuncScopevarNode) OneName() *NameNode {
	if child := ast.First(c.Node, "NAME"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c AggFuncScopevarNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type AliasIndentSepNode struct{ ast.Node }

func (AliasIndentSepNode) isWalkableType() {}
func (c AliasIndentSepNode) AllIndentSep() []IndentSepNode {
	var out []IndentSepNode
	for _, child := range ast.All(c.Node, "INDENT_SEP") {
		out = append(out, IndentSepNode{child})
	}
	return out
}

type AliasLineNode struct{ ast.Node }

func (AliasLineNode) isWalkableType() {}
func (c AliasLineNode) Choice() int   { return ast.Choice(c.Node) }

func (c AliasLineNode) AllAnnotation() []AnnotationNode {
	var out []AnnotationNode
	for _, child := range ast.All(c.Node, "annotation") {
		out = append(out, AnnotationNode{child})
	}
	return out
}

func (c AliasLineNode) OneCollectionType() *CollectionTypeNode {
	if child := ast.First(c.Node, "collection_type"); child != nil {
		return &CollectionTypeNode{child}
	}
	return nil
}

func (c AliasLineNode) OneTypeSpec() *TypeSpecNode {
	if child := ast.First(c.Node, "type_spec"); child != nil {
		return &TypeSpecNode{child}
	}
	return nil
}

type AliasNode struct{ ast.Node }

func (AliasNode) isWalkableType() {}
func (c AliasNode) Choice() int   { return ast.Choice(c.Node) }

func (c AliasNode) AllAliasLine() []AliasLineNode {
	var out []AliasLineNode
	for _, child := range ast.All(c.Node, "alias_line") {
		out = append(out, AliasLineNode{child})
	}
	return out
}

func (c AliasNode) OneAttribs() *AttribsNode {
	if child := ast.First(c.Node, "attribs"); child != nil {
		return &AttribsNode{child}
	}
	return nil
}

func (c AliasNode) AllComment() []CommentNode {
	var out []CommentNode
	for _, child := range ast.All(c.Node, "COMMENT") {
		out = append(out, CommentNode{child})
	}
	return out
}

func (c AliasNode) OneLevel() *IndentNode {
	if child := ast.First(c.Node, "level"); child != nil {
		return &IndentNode{child}
	}
	return nil
}

func (c AliasNode) OneName() *NameNode {
	if child := ast.First(c.Node, "NAME"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c AliasNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type AnnotationNode struct{ ast.Node }

func (AnnotationNode) isWalkableType() {}

func (c AnnotationNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c AnnotationNode) OneValue() *AnnotationValueNode {
	if child := ast.First(c.Node, "value"); child != nil {
		return &AnnotationValueNode{child}
	}
	return nil
}

func (c AnnotationNode) OneVarName() *NameNode {
	if child := ast.First(c.Node, "var_name"); child != nil {
		return &NameNode{child}
	}
	return nil
}

type AnnotationValueNode struct{ ast.Node }

func (AnnotationValueNode) isWalkableType() {}
func (c AnnotationValueNode) Choice() int   { return ast.Choice(c.Node) }

func (c AnnotationValueNode) OneArrayOfStrings() *ArrayOfStringsNode {
	if child := ast.First(c.Node, "array_of_strings"); child != nil {
		return &ArrayOfStringsNode{child}
	}
	return nil
}

func (c AnnotationValueNode) OneMultiLineDocstring() *MultiLineDocstringNode {
	if child := ast.First(c.Node, "multi_line_docstring"); child != nil {
		return &MultiLineDocstringNode{child}
	}
	return nil
}

func (c AnnotationValueNode) OneQstring() *QstringNode {
	if child := ast.First(c.Node, "QSTRING"); child != nil {
		return &QstringNode{child}
	}
	return nil
}

type AnnotationsIndentSepNode struct{ ast.Node }

func (AnnotationsIndentSepNode) isWalkableType() {}
func (c AnnotationsIndentSepNode) AllIndentSep() []IndentSepNode {
	var out []IndentSepNode
	for _, child := range ast.All(c.Node, "INDENT_SEP") {
		out = append(out, IndentSepNode{child})
	}
	return out
}

type AnnotationsNode struct{ ast.Node }

func (AnnotationsNode) isWalkableType() {}
func (c AnnotationsNode) AllAnnotation() []AnnotationNode {
	var out []AnnotationNode
	for _, child := range ast.All(c.Node, "annotation") {
		out = append(out, AnnotationNode{child})
	}
	return out
}

func (c AnnotationsNode) OneLevel() *IndentNode {
	if child := ast.First(c.Node, "level"); child != nil {
		return &IndentNode{child}
	}
	return nil
}

func (c AnnotationsNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type AnyFuncNode struct{ ast.Node }

func (AnyFuncNode) isWalkableType() {}

func (c AnyFuncNode) OneExpr() *ExprNode {
	if child := ast.First(c.Node, "expr"); child != nil {
		return &ExprNode{child}
	}
	return nil
}

func (c AnyFuncNode) OneFunc() string {
	if child := ast.First(c.Node, "func"); child != nil {
		return ast.First(child, "").Scanner().String()
	}
	return ""
}

func (c AnyFuncNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c AnyFuncNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type AppDeclNode struct{ ast.Node }

func (AppDeclNode) isWalkableType() {}
func (c AppDeclNode) Choice() int   { return ast.Choice(c.Node) }

func (c AppDeclNode) OneAnnotation() *AnnotationNode {
	if child := ast.First(c.Node, "annotation"); child != nil {
		return &AnnotationNode{child}
	}
	return nil
}

func (c AppDeclNode) OneCommentNoNl() *CommentNoNlNode {
	if child := ast.First(c.Node, "COMMENT_NO_NL"); child != nil {
		return &CommentNoNlNode{child}
	}
	return nil
}

func (c AppDeclNode) OneEndpoint() *EndpointNode {
	if child := ast.First(c.Node, "endpoint"); child != nil {
		return &EndpointNode{child}
	}
	return nil
}

func (c AppDeclNode) OneEvent() *EventNode {
	if child := ast.First(c.Node, "event"); child != nil {
		return &EventNode{child}
	}
	return nil
}

func (c AppDeclNode) OneShortcut() *ShortcutNode {
	if child := ast.First(c.Node, "SHORTCUT"); child != nil {
		return &ShortcutNode{child}
	}
	return nil
}

func (c AppDeclNode) OneSubscribe() *SubscribeNode {
	if child := ast.First(c.Node, "subscribe"); child != nil {
		return &SubscribeNode{child}
	}
	return nil
}

func (c AppDeclNode) OneTypeDecl() *TypeDeclNode {
	if child := ast.First(c.Node, "type_decl"); child != nil {
		return &TypeDeclNode{child}
	}
	return nil
}

func (c AppDeclNode) OneView() *ViewNode {
	if child := ast.First(c.Node, "view"); child != nil {
		return &ViewNode{child}
	}
	return nil
}

type ApplicationIndentSepNode struct{ ast.Node }

func (ApplicationIndentSepNode) isWalkableType() {}
func (c ApplicationIndentSepNode) AllIndentSep() []IndentSepNode {
	var out []IndentSepNode
	for _, child := range ast.All(c.Node, "INDENT_SEP") {
		out = append(out, IndentSepNode{child})
	}
	return out
}

type ApplicationNode struct{ ast.Node }

func (ApplicationNode) isWalkableType() {}

func (c ApplicationNode) OneAppname() *AppnameNode {
	if child := ast.First(c.Node, "APPNAME"); child != nil {
		return &AppnameNode{child}
	}
	return nil
}

func (c ApplicationNode) AllAppDecl() []AppDeclNode {
	var out []AppDeclNode
	for _, child := range ast.All(c.Node, "app_decl") {
		out = append(out, AppDeclNode{child})
	}
	return out
}

func (c ApplicationNode) OneAttribs() *AttribsNode {
	if child := ast.First(c.Node, "attribs"); child != nil {
		return &AttribsNode{child}
	}
	return nil
}

func (c ApplicationNode) AllComment() []CommentNode {
	var out []CommentNode
	for _, child := range ast.All(c.Node, "COMMENT") {
		out = append(out, CommentNode{child})
	}
	return out
}

func (c ApplicationNode) OneEol() *EolNode {
	if child := ast.First(c.Node, "EOL"); child != nil {
		return &EolNode{child}
	}
	return nil
}

func (c ApplicationNode) OneLevel() *IndentNode {
	if child := ast.First(c.Node, "level"); child != nil {
		return &IndentNode{child}
	}
	return nil
}

func (c ApplicationNode) OneQstring() *QstringNode {
	if child := ast.First(c.Node, "QSTRING"); child != nil {
		return &QstringNode{child}
	}
	return nil
}

func (c ApplicationNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c ApplicationNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type AppnameNode struct{ ast.Node }

func (AppnameNode) isWalkableType() {}
func (c AppnameNode) AllApp() []AppnameNode {
	var out []AppnameNode
	for _, child := range ast.All(c.Node, "app") {
		out = append(out, AppnameNode{child})
	}
	return out
}

func (c AppnameNode) AllAppname() []AppnameNode {
	var out []AppnameNode
	for _, child := range ast.All(c.Node, "APPNAME") {
		out = append(out, AppnameNode{child})
	}
	return out
}

func (c AppnameNode) OneAppnamePart() *AppnamePartNode {
	if child := ast.First(c.Node, "APPNAME_PART"); child != nil {
		return &AppnamePartNode{child}
	}
	return nil
}

func (c AppnameNode) AllPkg() []AppnameNode {
	var out []AppnameNode
	for _, child := range ast.All(c.Node, "pkg") {
		out = append(out, AppnameNode{child})
	}
	return out
}

type AppnamePartNode struct{ ast.Node }

func (AppnamePartNode) isWalkableType() {}
func (c AppnamePartNode) Choice() int   { return ast.Choice(c.Node) }

func (c AppnamePartNode) AllQstring() []QstringNode {
	var out []QstringNode
	for _, child := range ast.All(c.Node, "QSTRING") {
		out = append(out, QstringNode{child})
	}
	return out
}

func (c AppnamePartNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type ArrayOfArrayNode struct{ ast.Node }

func (ArrayOfArrayNode) isWalkableType() {}
func (c ArrayOfArrayNode) AllArrayOfStrings() []ArrayOfStringsNode {
	var out []ArrayOfStringsNode
	for _, child := range ast.All(c.Node, "array_of_strings") {
		out = append(out, ArrayOfStringsNode{child})
	}
	return out
}

func (c ArrayOfArrayNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type ArrayOfStringsNode struct{ ast.Node }

func (ArrayOfStringsNode) isWalkableType() {}
func (c ArrayOfStringsNode) AllQstring() []QstringNode {
	var out []QstringNode
	for _, child := range ast.All(c.Node, "QSTRING") {
		out = append(out, QstringNode{child})
	}
	return out
}

func (c ArrayOfStringsNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type ArraySizeMinNode struct{ ast.Node }

func (ArraySizeMinNode) isWalkableType() {}
func (c ArraySizeMinNode) Choice() int   { return ast.Choice(c.Node) }

func (c ArraySizeMinNode) OneDigits() *DigitsNode {
	if child := ast.First(c.Node, "DIGITS"); child != nil {
		return &DigitsNode{child}
	}
	return nil
}

func (c ArraySizeMinNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type ArraySizeNode struct{ ast.Node }

func (ArraySizeNode) isWalkableType() {}

func (c ArraySizeNode) OneMax() *DigitsNode {
	if child := ast.First(c.Node, "max"); child != nil {
		return &DigitsNode{child}
	}
	return nil
}

func (c ArraySizeNode) OneMin() *ArraySizeMinNode {
	if child := ast.First(c.Node, "min"); child != nil {
		return &ArraySizeMinNode{child}
	}
	return nil
}

func (c ArraySizeNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c ArraySizeNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type AtomAtomsNode struct{ ast.Node }

func (AtomAtomsNode) isWalkableType() {}
func (c AtomAtomsNode) AllExpr() []ExprNode {
	var out []ExprNode
	for _, child := range ast.All(c.Node, "expr") {
		out = append(out, ExprNode{child})
	}
	return out
}

func (c AtomAtomsNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type AtomDotRelopNode struct{ ast.Node }

func (AtomDotRelopNode) isWalkableType() {}
func (c AtomDotRelopNode) Choice() int   { return ast.Choice(c.Node) }

func (c AtomDotRelopNode) OneAggFunc() *AggFuncNode {
	if child := ast.First(c.Node, "agg_func"); child != nil {
		return &AggFuncNode{child}
	}
	return nil
}

func (c AtomDotRelopNode) OneAnyFunc() *AnyFuncNode {
	if child := ast.First(c.Node, "any_func"); child != nil {
		return &AnyFuncNode{child}
	}
	return nil
}

func (c AtomDotRelopNode) OneCount() *CountNode {
	if child := ast.First(c.Node, "count"); child != nil {
		return &CountNode{child}
	}
	return nil
}

func (c AtomDotRelopNode) OneFirstFunc() *FirstFuncNode {
	if child := ast.First(c.Node, "first_func"); child != nil {
		return &FirstFuncNode{child}
	}
	return nil
}

func (c AtomDotRelopNode) OneMatching() *MatchingNode {
	if child := ast.First(c.Node, "matching"); child != nil {
		return &MatchingNode{child}
	}
	return nil
}

func (c AtomDotRelopNode) OneNavigate() *NavigateNode {
	if child := ast.First(c.Node, "navigate"); child != nil {
		return &NavigateNode{child}
	}
	return nil
}

func (c AtomDotRelopNode) OneRankFunc() *RankFuncNode {
	if child := ast.First(c.Node, "rank_func"); child != nil {
		return &RankFuncNode{child}
	}
	return nil
}

func (c AtomDotRelopNode) OneSingleArgFunc() *SingleArgFuncNode {
	if child := ast.First(c.Node, "single_arg_func"); child != nil {
		return &SingleArgFuncNode{child}
	}
	return nil
}

func (c AtomDotRelopNode) OneSingleOrNull() *SingleOrNullNode {
	if child := ast.First(c.Node, "single_or_null"); child != nil {
		return &SingleOrNullNode{child}
	}
	return nil
}

func (c AtomDotRelopNode) OneSnapshot() *SnapshotNode {
	if child := ast.First(c.Node, "snapshot"); child != nil {
		return &SnapshotNode{child}
	}
	return nil
}

func (c AtomDotRelopNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type AtomIdentNode struct{ ast.Node }

func (AtomIdentNode) isWalkableType() {}
func (c AtomIdentNode) Choice() int   { return ast.Choice(c.Node) }

func (c AtomIdentNode) OneName() *NameNode {
	if child := ast.First(c.Node, "NAME"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c AtomIdentNode) OneShortcut() *ShortcutNode {
	if child := ast.First(c.Node, "SHORTCUT"); child != nil {
		return &ShortcutNode{child}
	}
	return nil
}

func (c AtomIdentNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type AtomImpliedDotNode struct{ ast.Node }

func (AtomImpliedDotNode) isWalkableType() {}
func (c AtomImpliedDotNode) Choice() int   { return ast.Choice(c.Node) }

func (c AtomImpliedDotNode) OneAtomDotRelop() *AtomDotRelopNode {
	if child := ast.First(c.Node, "atom_dot_relop"); child != nil {
		return &AtomDotRelopNode{child}
	}
	return nil
}

func (c AtomImpliedDotNode) OneExprTableOfOp() *ExprTableOfOpNode {
	if child := ast.First(c.Node, "expr_table_of_op"); child != nil {
		return &ExprTableOfOpNode{child}
	}
	return nil
}

func (c AtomImpliedDotNode) OneMatching() *MatchingNode {
	if child := ast.First(c.Node, "matching"); child != nil {
		return &MatchingNode{child}
	}
	return nil
}

func (c AtomImpliedDotNode) OneNavigate() *NavigateNode {
	if child := ast.First(c.Node, "navigate"); child != nil {
		return &NavigateNode{child}
	}
	return nil
}

type AtomLiteralLiteralNode struct{ ast.Node }

func (AtomLiteralLiteralNode) isWalkableType() {}
func (c AtomLiteralLiteralNode) Choice() int   { return ast.Choice(c.Node) }

func (c AtomLiteralLiteralNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type AtomLiteralNode struct{ ast.Node }

func (AtomLiteralNode) isWalkableType() {}
func (c AtomLiteralNode) Choice() int   { return ast.Choice(c.Node) }

func (c AtomLiteralNode) OneDecimal() string {
	if child := ast.First(c.Node, "decimal"); child != nil {
		return ast.First(child, "").Scanner().String()
	}
	return ""
}

func (c AtomLiteralNode) OneDigits() string {
	if child := ast.First(c.Node, "digits"); child != nil {
		return ast.First(child, "").Scanner().String()
	}
	return ""
}

func (c AtomLiteralNode) OneLiteral() *AtomLiteralLiteralNode {
	if child := ast.First(c.Node, "literal"); child != nil {
		return &AtomLiteralLiteralNode{child}
	}
	return nil
}

func (c AtomLiteralNode) OneQuote() *AtomLiteralQuoteNode {
	if child := ast.First(c.Node, "quote"); child != nil {
		return &AtomLiteralQuoteNode{child}
	}
	return nil
}

type AtomLiteralQuoteNode struct{ ast.Node }

func (AtomLiteralQuoteNode) isWalkableType() {}
func (c AtomLiteralQuoteNode) Choice() int   { return ast.Choice(c.Node) }

func (c AtomLiteralQuoteNode) OneDouble() string {
	if child := ast.First(c.Node, "double"); child != nil {
		return ast.First(child, "").Scanner().String()
	}
	return ""
}

func (c AtomLiteralQuoteNode) OneSingle() string {
	if child := ast.First(c.Node, "single"); child != nil {
		return ast.First(child, "").Scanner().String()
	}
	return ""
}

type AtomNode struct{ ast.Node }

func (AtomNode) isWalkableType() {}
func (c AtomNode) Choice() int   { return ast.Choice(c.Node) }

func (c AtomNode) OneAtoms() *AtomAtomsNode {
	if child := ast.First(c.Node, "atoms"); child != nil {
		return &AtomAtomsNode{child}
	}
	return nil
}

func (c AtomNode) OneEmptyTuple() string {
	if child := ast.First(c.Node, "empty_tuple"); child != nil {
		return ast.First(child, "").Scanner().String()
	}
	return ""
}

func (c AtomNode) OneExpr() *ExprNode {
	if child := ast.First(c.Node, "expr"); child != nil {
		return &ExprNode{child}
	}
	return nil
}

func (c AtomNode) OneExprFunc() *ExprFuncNode {
	if child := ast.First(c.Node, "expr_func"); child != nil {
		return &ExprFuncNode{child}
	}
	return nil
}

func (c AtomNode) OneIdent() *AtomIdentNode {
	if child := ast.First(c.Node, "ident"); child != nil {
		return &AtomIdentNode{child}
	}
	return nil
}

func (c AtomNode) OneImpliedDot() *AtomImpliedDotNode {
	if child := ast.First(c.Node, "implied_dot"); child != nil {
		return &AtomImpliedDotNode{child}
	}
	return nil
}

func (c AtomNode) OneLiteral() *AtomLiteralNode {
	if child := ast.First(c.Node, "literal"); child != nil {
		return &AtomLiteralNode{child}
	}
	return nil
}

func (c AtomNode) OneSet() *AtomSetNode {
	if child := ast.First(c.Node, "set"); child != nil {
		return &AtomSetNode{child}
	}
	return nil
}

func (c AtomNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c AtomNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type AtomSetNode struct{ ast.Node }

func (AtomSetNode) isWalkableType() {}
func (c AtomSetNode) AllExpr() []ExprNode {
	var out []ExprNode
	for _, child := range ast.All(c.Node, "expr") {
		out = append(out, ExprNode{child})
	}
	return out
}

func (c AtomSetNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type AttribsAttrNode struct{ ast.Node }

func (AttribsAttrNode) isWalkableType() {}
func (c AttribsAttrNode) Choice() int   { return ast.Choice(c.Node) }

func (c AttribsAttrNode) OneArrayOfArray() *ArrayOfArrayNode {
	if child := ast.First(c.Node, "array_of_array"); child != nil {
		return &ArrayOfArrayNode{child}
	}
	return nil
}

func (c AttribsAttrNode) OneArrayOfStrings() *ArrayOfStringsNode {
	if child := ast.First(c.Node, "array_of_strings"); child != nil {
		return &ArrayOfStringsNode{child}
	}
	return nil
}

func (c AttribsAttrNode) OneName() *NameNode {
	if child := ast.First(c.Node, "NAME"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c AttribsAttrNode) OneQstring() *QstringNode {
	if child := ast.First(c.Node, "QSTRING"); child != nil {
		return &QstringNode{child}
	}
	return nil
}

func (c AttribsAttrNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type AttribsNode struct{ ast.Node }

func (AttribsNode) isWalkableType() {}
func (c AttribsNode) Choice() int   { return ast.Choice(c.Node) }

func (c AttribsNode) OneAttr() *AttribsAttrNode {
	if child := ast.First(c.Node, "attr"); child != nil {
		return &AttribsAttrNode{child}
	}
	return nil
}

func (c AttribsNode) AllAttribs() []AttribsNode {
	var out []AttribsNode
	for _, child := range ast.All(c.Node, "attribs") {
		out = append(out, AttribsNode{child})
	}
	return out
}

func (c AttribsNode) OnePattern() *AttribsPatternNode {
	if child := ast.First(c.Node, "pattern"); child != nil {
		return &AttribsPatternNode{child}
	}
	return nil
}

func (c AttribsNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type AttribsPatternNode struct{ ast.Node }

func (AttribsPatternNode) isWalkableType() {}
func (c AttribsPatternNode) AllName() []NameNode {
	var out []NameNode
	for _, child := range ast.All(c.Node, "NAME") {
		out = append(out, NameNode{child})
	}
	return out
}

func (c AttribsPatternNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type CallArgsArgNode struct{ ast.Node }

func (CallArgsArgNode) isWalkableType() {}
func (c CallArgsArgNode) Choice() int   { return ast.Choice(c.Node) }

func (c CallArgsArgNode) AllName() []NameNode {
	var out []NameNode
	for _, child := range ast.All(c.Node, "NAME") {
		out = append(out, NameNode{child})
	}
	return out
}

func (c CallArgsArgNode) AllQstring() []QstringNode {
	var out []QstringNode
	for _, child := range ast.All(c.Node, "QSTRING") {
		out = append(out, QstringNode{child})
	}
	return out
}

func (c CallArgsArgNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

func (c CallArgsArgNode) AllTypeSpec() []TypeSpecNode {
	var out []TypeSpecNode
	for _, child := range ast.All(c.Node, "type_spec") {
		out = append(out, TypeSpecNode{child})
	}
	return out
}

type CallArgsNode struct{ ast.Node }

func (CallArgsNode) isWalkableType() {}
func (c CallArgsNode) AllArg() []CallArgsArgNode {
	var out []CallArgsArgNode
	for _, child := range ast.All(c.Node, "arg") {
		out = append(out, CallArgsArgNode{child})
	}
	return out
}

func (c CallArgsNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type CallStmtNode struct{ ast.Node }

func (CallStmtNode) isWalkableType() {}

func (c CallStmtNode) OneCallArgs() *CallArgsNode {
	if child := ast.First(c.Node, "call_args"); child != nil {
		return &CallArgsNode{child}
	}
	return nil
}

func (c CallStmtNode) OneTarget() *CallStmtTargetNode {
	if child := ast.First(c.Node, "target"); child != nil {
		return &CallStmtTargetNode{child}
	}
	return nil
}

func (c CallStmtNode) OneTargetEndpoint() *TextLineNode {
	if child := ast.First(c.Node, "target_endpoint"); child != nil {
		return &TextLineNode{child}
	}
	return nil
}

func (c CallStmtNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type CallStmtTargetNode struct{ ast.Node }

func (CallStmtTargetNode) isWalkableType() {}
func (c CallStmtTargetNode) Choice() int   { return ast.Choice(c.Node) }

func (c CallStmtTargetNode) AllName() []NameNode {
	var out []NameNode
	for _, child := range ast.All(c.Node, "NAME") {
		out = append(out, NameNode{child})
	}
	return out
}

func (c CallStmtTargetNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type CollectionTypeNode struct{ ast.Node }

func (CollectionTypeNode) isWalkableType() {}
func (c CollectionTypeNode) Choice() int   { return ast.Choice(c.Node) }

func (c CollectionTypeNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c CollectionTypeNode) OneTypeSpec() *TypeSpecNode {
	if child := ast.First(c.Node, "type_spec"); child != nil {
		return &TypeSpecNode{child}
	}
	return nil
}

type CollectorCallStmtNode struct{ ast.Node }

func (CollectorCallStmtNode) isWalkableType() {}

func (c CollectorCallStmtNode) OneTarget() *AppnameNode {
	if child := ast.First(c.Node, "target"); child != nil {
		return &AppnameNode{child}
	}
	return nil
}

func (c CollectorCallStmtNode) OneTargetEndpoint() *AppnamePartNode {
	if child := ast.First(c.Node, "target_endpoint"); child != nil {
		return &AppnamePartNode{child}
	}
	return nil
}

func (c CollectorCallStmtNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type CollectorHttpStmtNode struct{ ast.Node }

func (CollectorHttpStmtNode) isWalkableType() {}
func (c CollectorHttpStmtNode) Choice() int   { return ast.Choice(c.Node) }

func (c CollectorHttpStmtNode) AllHttpPathPart() []HttpPathPartNode {
	var out []HttpPathPartNode
	for _, child := range ast.All(c.Node, "http_path_part") {
		out = append(out, HttpPathPartNode{child})
	}
	return out
}

func (c CollectorHttpStmtNode) OneMethod() *HttpVerbsNode {
	if child := ast.First(c.Node, "method"); child != nil {
		return &HttpVerbsNode{child}
	}
	return nil
}

func (c CollectorHttpStmtNode) AllParam() []NameNode {
	var out []NameNode
	for _, child := range ast.All(c.Node, "param") {
		out = append(out, NameNode{child})
	}
	return out
}

func (c CollectorHttpStmtNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c CollectorHttpStmtNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

func (c CollectorHttpStmtNode) AllType() []CollectorHttpStmtTypeNode {
	var out []CollectorHttpStmtTypeNode
	for _, child := range ast.All(c.Node, "type") {
		out = append(out, CollectorHttpStmtTypeNode{child})
	}
	return out
}

type CollectorHttpStmtTypeNode struct{ ast.Node }

func (CollectorHttpStmtTypeNode) isWalkableType() {}
func (c CollectorHttpStmtTypeNode) Choice() int   { return ast.Choice(c.Node) }

func (c CollectorHttpStmtTypeNode) AllName() []NameNode {
	var out []NameNode
	for _, child := range ast.All(c.Node, "NAME") {
		out = append(out, NameNode{child})
	}
	return out
}

func (c CollectorHttpStmtTypeNode) AllNativeDataTypes() []NativeDataTypesNode {
	var out []NativeDataTypesNode
	for _, child := range ast.All(c.Node, "NativeDataTypes") {
		out = append(out, NativeDataTypesNode{child})
	}
	return out
}

type CollectorIndentSepNode struct{ ast.Node }

func (CollectorIndentSepNode) isWalkableType() {}
func (c CollectorIndentSepNode) AllIndentSep() []IndentSepNode {
	var out []IndentSepNode
	for _, child := range ast.All(c.Node, "INDENT_SEP") {
		out = append(out, IndentSepNode{child})
	}
	return out
}

type CollectorNode struct{ ast.Node }

func (CollectorNode) isWalkableType() {}
func (c CollectorNode) Choice() int   { return ast.Choice(c.Node) }

func (c CollectorNode) AllCollectorStmt() []CollectorStmtNode {
	var out []CollectorStmtNode
	for _, child := range ast.All(c.Node, "collector_stmt") {
		out = append(out, CollectorStmtNode{child})
	}
	return out
}

func (c CollectorNode) OneLevel() *IndentNode {
	if child := ast.First(c.Node, "level"); child != nil {
		return &IndentNode{child}
	}
	return nil
}

func (c CollectorNode) OneShortcut() *ShortcutNode {
	if child := ast.First(c.Node, "SHORTCUT"); child != nil {
		return &ShortcutNode{child}
	}
	return nil
}

func (c CollectorNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type CollectorPubsubCallNode struct{ ast.Node }

func (CollectorPubsubCallNode) isWalkableType() {}

func (c CollectorPubsubCallNode) OneName() *NameNode {
	if child := ast.First(c.Node, "name"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c CollectorPubsubCallNode) OnePublisher() *AppnameNode {
	if child := ast.First(c.Node, "publisher"); child != nil {
		return &AppnameNode{child}
	}
	return nil
}

func (c CollectorPubsubCallNode) OneSubscriber() *AppnameNode {
	if child := ast.First(c.Node, "subscriber"); child != nil {
		return &AppnameNode{child}
	}
	return nil
}

func (c CollectorPubsubCallNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c CollectorPubsubCallNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type CollectorStmtNode struct{ ast.Node }

func (CollectorStmtNode) isWalkableType() {}
func (c CollectorStmtNode) Choice() int   { return ast.Choice(c.Node) }

func (c CollectorStmtNode) OneAction() *AppnameNode {
	if child := ast.First(c.Node, "action"); child != nil {
		return &AppnameNode{child}
	}
	return nil
}

func (c CollectorStmtNode) OneAttribs() *AttribsNode {
	if child := ast.First(c.Node, "attribs"); child != nil {
		return &AttribsNode{child}
	}
	return nil
}

func (c CollectorStmtNode) OneCollectorCallStmt() *CollectorCallStmtNode {
	if child := ast.First(c.Node, "collector_call_stmt"); child != nil {
		return &CollectorCallStmtNode{child}
	}
	return nil
}

func (c CollectorStmtNode) OneCollectorHttpStmt() *CollectorHttpStmtNode {
	if child := ast.First(c.Node, "collector_http_stmt"); child != nil {
		return &CollectorHttpStmtNode{child}
	}
	return nil
}

func (c CollectorStmtNode) OneCollectorPubsubCall() *CollectorPubsubCallNode {
	if child := ast.First(c.Node, "collector_pubsub_call"); child != nil {
		return &CollectorPubsubCallNode{child}
	}
	return nil
}

type CommentNoNlNode struct{ ast.Node }

func (CommentNoNlNode) isWalkableType() {}

func (c CommentNoNlNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type CommentNode struct{ ast.Node }

func (CommentNode) isWalkableType() {}

func (c CommentNode) OneCommentNoNl() *CommentNoNlNode {
	if child := ast.First(c.Node, "COMMENT_NO_NL"); child != nil {
		return &CommentNoNlNode{child}
	}
	return nil
}

func (c CommentNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type CountNode struct{ ast.Node }

func (CountNode) isWalkableType() {}
func (c *CountNode) String() string {
	if c == nil || c.Node == nil {
		return ""
	}
	return c.Node.Scanner().String()
}

type DigitsNode struct{ ast.Node }

func (DigitsNode) isWalkableType() {}
func (c *DigitsNode) String() string {
	if c == nil || c.Node == nil {
		return ""
	}
	return c.Node.Scanner().String()
}

type ElseStmtIndentSepNode struct{ ast.Node }

func (ElseStmtIndentSepNode) isWalkableType() {}
func (c ElseStmtIndentSepNode) AllIndentSep() []IndentSepNode {
	var out []IndentSepNode
	for _, child := range ast.All(c.Node, "INDENT_SEP") {
		out = append(out, IndentSepNode{child})
	}
	return out
}

type ElseStmtNode struct{ ast.Node }

func (ElseStmtNode) isWalkableType() {}

func (c ElseStmtNode) OneLevel() *IndentNode {
	if child := ast.First(c.Node, "level"); child != nil {
		return &IndentNode{child}
	}
	return nil
}

func (c ElseStmtNode) OnePredicate() *PredicateNode {
	if child := ast.First(c.Node, "PREDICATE"); child != nil {
		return &PredicateNode{child}
	}
	return nil
}

func (c ElseStmtNode) AllStmt() []StmtNode {
	var out []StmtNode
	for _, child := range ast.All(c.Node, "stmt") {
		out = append(out, StmtNode{child})
	}
	return out
}

func (c ElseStmtNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c ElseStmtNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type EndpointNode struct{ ast.Node }

func (EndpointNode) isWalkableType() {}
func (c EndpointNode) Choice() int   { return ast.Choice(c.Node) }

func (c EndpointNode) OneCollector() *CollectorNode {
	if child := ast.First(c.Node, "collector"); child != nil {
		return &CollectorNode{child}
	}
	return nil
}

func (c EndpointNode) OneEvent() *EventNode {
	if child := ast.First(c.Node, "event"); child != nil {
		return &EventNode{child}
	}
	return nil
}

func (c EndpointNode) OneRestEndpoint() *RestEndpointNode {
	if child := ast.First(c.Node, "rest_endpoint"); child != nil {
		return &RestEndpointNode{child}
	}
	return nil
}

func (c EndpointNode) OneSimpleEndpoint() *SimpleEndpointNode {
	if child := ast.First(c.Node, "simple_endpoint"); child != nil {
		return &SimpleEndpointNode{child}
	}
	return nil
}

type EnumEnumerationNode struct{ ast.Node }

func (EnumEnumerationNode) isWalkableType() {}
func (c EnumEnumerationNode) AllCommentNoNl() []CommentNoNlNode {
	var out []CommentNoNlNode
	for _, child := range ast.All(c.Node, "COMMENT_NO_NL") {
		out = append(out, CommentNoNlNode{child})
	}
	return out
}

func (c EnumEnumerationNode) OneDigits() *DigitsNode {
	if child := ast.First(c.Node, "DIGITS"); child != nil {
		return &DigitsNode{child}
	}
	return nil
}

func (c EnumEnumerationNode) OneName() *NameNode {
	if child := ast.First(c.Node, "name"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c EnumEnumerationNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type EnumIndentSepNode struct{ ast.Node }

func (EnumIndentSepNode) isWalkableType() {}
func (c EnumIndentSepNode) AllIndentSep() []IndentSepNode {
	var out []IndentSepNode
	for _, child := range ast.All(c.Node, "INDENT_SEP") {
		out = append(out, IndentSepNode{child})
	}
	return out
}

type EnumNode struct{ ast.Node }

func (EnumNode) isWalkableType() {}
func (c EnumNode) Choice() int   { return ast.Choice(c.Node) }

func (c EnumNode) OneAttribs() *AttribsNode {
	if child := ast.First(c.Node, "attribs"); child != nil {
		return &AttribsNode{child}
	}
	return nil
}

func (c EnumNode) AllComment() []CommentNode {
	var out []CommentNode
	for _, child := range ast.All(c.Node, "COMMENT") {
		out = append(out, CommentNode{child})
	}
	return out
}

func (c EnumNode) AllCommentNoNl() []CommentNoNlNode {
	var out []CommentNoNlNode
	for _, child := range ast.All(c.Node, "COMMENT_NO_NL") {
		out = append(out, CommentNoNlNode{child})
	}
	return out
}

func (c EnumNode) AllEnumeration() []EnumEnumerationNode {
	var out []EnumEnumerationNode
	for _, child := range ast.All(c.Node, "enumeration") {
		out = append(out, EnumEnumerationNode{child})
	}
	return out
}

func (c EnumNode) OneLevel() *IndentNode {
	if child := ast.First(c.Node, "level"); child != nil {
		return &IndentNode{child}
	}
	return nil
}

func (c EnumNode) OneName() *NameNode {
	if child := ast.First(c.Node, "name"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c EnumNode) OneShortcut() *ShortcutNode {
	if child := ast.First(c.Node, "SHORTCUT"); child != nil {
		return &ShortcutNode{child}
	}
	return nil
}

func (c EnumNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type EolNode struct{ ast.Node }

func (EolNode) isWalkableType() {}
func (c EolNode) Choice() int   { return ast.Choice(c.Node) }

func (c EolNode) AllComment() []CommentNode {
	var out []CommentNode
	for _, child := range ast.All(c.Node, "COMMENT") {
		out = append(out, CommentNode{child})
	}
	return out
}

func (c EolNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type EventIndentSepNode struct{ ast.Node }

func (EventIndentSepNode) isWalkableType() {}
func (c EventIndentSepNode) AllIndentSep() []IndentSepNode {
	var out []IndentSepNode
	for _, child := range ast.All(c.Node, "INDENT_SEP") {
		out = append(out, IndentSepNode{child})
	}
	return out
}

type EventNode struct{ ast.Node }

func (EventNode) isWalkableType() {}
func (c EventNode) Choice() int   { return ast.Choice(c.Node) }

func (c EventNode) OneAttribs() *AttribsNode {
	if child := ast.First(c.Node, "attribs"); child != nil {
		return &AttribsNode{child}
	}
	return nil
}

func (c EventNode) AllComment() []CommentNode {
	var out []CommentNode
	for _, child := range ast.All(c.Node, "COMMENT") {
		out = append(out, CommentNode{child})
	}
	return out
}

func (c EventNode) OneLevel() *IndentNode {
	if child := ast.First(c.Node, "level"); child != nil {
		return &IndentNode{child}
	}
	return nil
}

func (c EventNode) OneName() *NameNode {
	if child := ast.First(c.Node, "NAME"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c EventNode) OneParams() *ParamsNode {
	if child := ast.First(c.Node, "params"); child != nil {
		return &ParamsNode{child}
	}
	return nil
}

func (c EventNode) OneShortcut() *ShortcutNode {
	if child := ast.First(c.Node, "SHORTCUT"); child != nil {
		return &ShortcutNode{child}
	}
	return nil
}

func (c EventNode) AllStmt() []StmtNode {
	var out []StmtNode
	for _, child := range ast.All(c.Node, "stmt") {
		out = append(out, StmtNode{child})
	}
	return out
}

func (c EventNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type ExprBlockIndentSepNode struct{ ast.Node }

func (ExprBlockIndentSepNode) isWalkableType() {}
func (c ExprBlockIndentSepNode) AllIndentSep() []IndentSepNode {
	var out []IndentSepNode
	for _, child := range ast.All(c.Node, "INDENT_SEP") {
		out = append(out, IndentSepNode{child})
	}
	return out
}

type ExprBlockNode struct{ ast.Node }

func (ExprBlockNode) isWalkableType() {}

func (c ExprBlockNode) OneArg() *ExprNode {
	if child := ast.First(c.Node, "arg"); child != nil {
		return &ExprNode{child}
	}
	return nil
}

func (c ExprBlockNode) OneEol() *EolNode {
	if child := ast.First(c.Node, "EOL"); child != nil {
		return &EolNode{child}
	}
	return nil
}

func (c ExprBlockNode) OneExprRetType() *ExprRetTypeNode {
	if child := ast.First(c.Node, "expr_ret_type"); child != nil {
		return &ExprRetTypeNode{child}
	}
	return nil
}

func (c ExprBlockNode) AllExprStmt() []ExprStmtNode {
	var out []ExprStmtNode
	for _, child := range ast.All(c.Node, "expr_stmt") {
		out = append(out, ExprStmtNode{child})
	}
	return out
}

func (c ExprBlockNode) OneLevel() *IndentNode {
	if child := ast.First(c.Node, "level"); child != nil {
		return &IndentNode{child}
	}
	return nil
}

func (c ExprBlockNode) OneScopevar() *NameNode {
	if child := ast.First(c.Node, "scopevar"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c ExprBlockNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c ExprBlockNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type ExprFuncArgsNode struct{ ast.Node }

func (ExprFuncArgsNode) isWalkableType() {}
func (c ExprFuncArgsNode) AllExpr() []ExprNode {
	var out []ExprNode
	for _, child := range ast.All(c.Node, "expr") {
		out = append(out, ExprNode{child})
	}
	return out
}

type ExprFuncFuncNode struct{ ast.Node }

func (ExprFuncFuncNode) isWalkableType() {}
func (c ExprFuncFuncNode) Choice() int   { return ast.Choice(c.Node) }

func (c ExprFuncFuncNode) OneName() *NameNode {
	if child := ast.First(c.Node, "NAME"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c ExprFuncFuncNode) OneNativeDataTypes() *NativeDataTypesNode {
	if child := ast.First(c.Node, "NativeDataTypes"); child != nil {
		return &NativeDataTypesNode{child}
	}
	return nil
}

func (c ExprFuncFuncNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type ExprFuncNode struct{ ast.Node }

func (ExprFuncNode) isWalkableType() {}

func (c ExprFuncNode) OneArgs() *ExprFuncArgsNode {
	if child := ast.First(c.Node, "args"); child != nil {
		return &ExprFuncArgsNode{child}
	}
	return nil
}

func (c ExprFuncNode) OneFunc() *ExprFuncFuncNode {
	if child := ast.First(c.Node, "func"); child != nil {
		return &ExprFuncFuncNode{child}
	}
	return nil
}

func (c ExprFuncNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c ExprFuncNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type ExprIfElseNode struct{ ast.Node }

func (ExprIfElseNode) isWalkableType() {}

func (c ExprIfElseNode) OneEol() *EolNode {
	if child := ast.First(c.Node, "EOL"); child != nil {
		return &EolNode{child}
	}
	return nil
}

func (c ExprIfElseNode) OneExpr() *ExprNode {
	if child := ast.First(c.Node, "expr"); child != nil {
		return &ExprNode{child}
	}
	return nil
}
func (c ExprIfElseNode) AllExpr() []ExprNode {
	var out []ExprNode
	for _, child := range ast.All(c.Node, "expr") {
		out = append(out, ExprNode{child})
	}
	return out
}

func (c ExprIfElseNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c ExprIfElseNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type ExprNode struct{ ast.Node }

func (ExprNode) isWalkableType() {}
func (c ExprNode) Choice() int   { return ast.Choice(c.Node) }

func (c ExprNode) OneAtom() *AtomNode {
	if child := ast.First(c.Node, "atom"); child != nil {
		return &AtomNode{child}
	}
	return nil
}

func (c ExprNode) AllExpr() []ExprNode {
	var out []ExprNode
	for _, child := range ast.All(c.Node, "expr") {
		out = append(out, ExprNode{child})
	}
	return out
}

func (c ExprNode) OneExprIfElse() *ExprIfElseNode {
	if child := ast.First(c.Node, "expr_if_else"); child != nil {
		return &ExprIfElseNode{child}
	}
	return nil
}

func (c ExprNode) OneOp() string {
	if child := ast.First(c.Node, "op"); child != nil {
		return ast.First(child, "").Scanner().String()
	}
	return ""
}

func (c ExprNode) AllOp() []string {
	var out []string
	for _, child := range ast.All(c.Node, "op") {
		out = append(out, ast.First(child, "").Scanner().String())
	}
	return out
}

func (c ExprNode) AllRelop() []RelopNode {
	var out []RelopNode
	for _, child := range ast.All(c.Node, "relop") {
		out = append(out, RelopNode{child})
	}
	return out
}

func (c ExprNode) OneUnaryop() *ExprUnaryopNode {
	if child := ast.First(c.Node, "unaryop"); child != nil {
		return &ExprUnaryopNode{child}
	}
	return nil
}

type ExprOpNode struct{ ast.Node }

func (ExprOpNode) isWalkableType() {}
func (c ExprOpNode) Choice() int   { return ast.Choice(c.Node) }

func (c ExprOpNode) AllAdd() []string {
	var out []string
	for _, child := range ast.All(c.Node, "add") {
		out = append(out, ast.First(child, "").Scanner().String())
	}
	return out
}

func (c ExprOpNode) AllDiv() []string {
	var out []string
	for _, child := range ast.All(c.Node, "div") {
		out = append(out, ast.First(child, "").Scanner().String())
	}
	return out
}

func (c ExprOpNode) AllMod() []string {
	var out []string
	for _, child := range ast.All(c.Node, "mod") {
		out = append(out, ast.First(child, "").Scanner().String())
	}
	return out
}

func (c ExprOpNode) AllMul() []string {
	var out []string
	for _, child := range ast.All(c.Node, "mul") {
		out = append(out, ast.First(child, "").Scanner().String())
	}
	return out
}

func (c ExprOpNode) AllPow() []string {
	var out []string
	for _, child := range ast.All(c.Node, "pow") {
		out = append(out, ast.First(child, "").Scanner().String())
	}
	return out
}

func (c ExprOpNode) AllSub() []string {
	var out []string
	for _, child := range ast.All(c.Node, "sub") {
		out = append(out, ast.First(child, "").Scanner().String())
	}
	return out
}

func (c ExprOpNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type ExprRetTypeCollectionNode struct{ ast.Node }

func (ExprRetTypeCollectionNode) isWalkableType() {}
func (c ExprRetTypeCollectionNode) Choice() int   { return ast.Choice(c.Node) }

func (c ExprRetTypeCollectionNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c ExprRetTypeCollectionNode) OneTypeSpec() *TypeSpecNode {
	if child := ast.First(c.Node, "type_spec"); child != nil {
		return &TypeSpecNode{child}
	}
	return nil
}

type ExprRetTypeNode struct{ ast.Node }

func (ExprRetTypeNode) isWalkableType() {}
func (c ExprRetTypeNode) Choice() int   { return ast.Choice(c.Node) }

func (c ExprRetTypeNode) OneCollection() *ExprRetTypeCollectionNode {
	if child := ast.First(c.Node, "collection"); child != nil {
		return &ExprRetTypeCollectionNode{child}
	}
	return nil
}

func (c ExprRetTypeNode) OneTypeSpec() *TypeSpecNode {
	if child := ast.First(c.Node, "type_spec"); child != nil {
		return &TypeSpecNode{child}
	}
	return nil
}

type ExprStmtExprAssignNode struct{ ast.Node }

func (ExprStmtExprAssignNode) isWalkableType() {}
func (c ExprStmtExprAssignNode) Choice() int   { return ast.Choice(c.Node) }

func (c ExprStmtExprAssignNode) OneExpr() *ExprNode {
	if child := ast.First(c.Node, "expr"); child != nil {
		return &ExprNode{child}
	}
	return nil
}

func (c ExprStmtExprAssignNode) OneExprBlock() *ExprBlockNode {
	if child := ast.First(c.Node, "expr_block"); child != nil {
		return &ExprBlockNode{child}
	}
	return nil
}

func (c ExprStmtExprAssignNode) OneIdent() *NameNode {
	if child := ast.First(c.Node, "ident"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c ExprStmtExprAssignNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type ExprStmtExprDotAssignNode struct{ ast.Node }

func (ExprStmtExprDotAssignNode) isWalkableType() {}

func (c ExprStmtExprDotAssignNode) OneField() *NameNode {
	if child := ast.First(c.Node, "field"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c ExprStmtExprDotAssignNode) OneObj() *NameNode {
	if child := ast.First(c.Node, "obj"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c ExprStmtExprDotAssignNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type ExprStmtExprTableAssignNode struct{ ast.Node }

func (ExprStmtExprTableAssignNode) isWalkableType() {}
func (c ExprStmtExprTableAssignNode) Choice() int   { return ast.Choice(c.Node) }

func (c ExprStmtExprTableAssignNode) OneExpr() *ExprNode {
	if child := ast.First(c.Node, "expr"); child != nil {
		return &ExprNode{child}
	}
	return nil
}

func (c ExprStmtExprTableAssignNode) OneExprBlock() *ExprBlockNode {
	if child := ast.First(c.Node, "expr_block"); child != nil {
		return &ExprBlockNode{child}
	}
	return nil
}

func (c ExprStmtExprTableAssignNode) OneIdent() *NameNode {
	if child := ast.First(c.Node, "ident"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c ExprStmtExprTableAssignNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type ExprStmtNode struct{ ast.Node }

func (ExprStmtNode) isWalkableType() {}
func (c ExprStmtNode) Choice() int   { return ast.Choice(c.Node) }

func (c ExprStmtNode) OneCommentNoNl() *CommentNoNlNode {
	if child := ast.First(c.Node, "COMMENT_NO_NL"); child != nil {
		return &CommentNoNlNode{child}
	}
	return nil
}

func (c ExprStmtNode) OneExprAssign() *ExprStmtExprAssignNode {
	if child := ast.First(c.Node, "expr_assign"); child != nil {
		return &ExprStmtExprAssignNode{child}
	}
	return nil
}

func (c ExprStmtNode) OneExprDotAssign() *ExprStmtExprDotAssignNode {
	if child := ast.First(c.Node, "expr_dot_assign"); child != nil {
		return &ExprStmtExprDotAssignNode{child}
	}
	return nil
}

func (c ExprStmtNode) OneExprTableAssign() *ExprStmtExprTableAssignNode {
	if child := ast.First(c.Node, "expr_table_assign"); child != nil {
		return &ExprStmtExprTableAssignNode{child}
	}
	return nil
}

type ExprTableOfOpDotNode struct{ ast.Node }

func (ExprTableOfOpDotNode) isWalkableType() {}
func (c ExprTableOfOpDotNode) Choice() int   { return ast.Choice(c.Node) }

func (c ExprTableOfOpDotNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type ExprTableOfOpNode struct{ ast.Node }

func (ExprTableOfOpNode) isWalkableType() {}

func (c ExprTableOfOpNode) OneDot() *ExprTableOfOpDotNode {
	if child := ast.First(c.Node, "dot"); child != nil {
		return &ExprTableOfOpDotNode{child}
	}
	return nil
}

func (c ExprTableOfOpNode) OneIdent() *NameNode {
	if child := ast.First(c.Node, "ident"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c ExprTableOfOpNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type ExprUnaryopNode struct{ ast.Node }

func (ExprUnaryopNode) isWalkableType() {}
func (c ExprUnaryopNode) Choice() int   { return ast.Choice(c.Node) }

func (c ExprUnaryopNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type FacadeIndentSepNode struct{ ast.Node }

func (FacadeIndentSepNode) isWalkableType() {}
func (c FacadeIndentSepNode) AllIndentSep() []IndentSepNode {
	var out []IndentSepNode
	for _, child := range ast.All(c.Node, "INDENT_SEP") {
		out = append(out, IndentSepNode{child})
	}
	return out
}

type FacadeInplaceTableDefIndentSepNode struct{ ast.Node }

func (FacadeInplaceTableDefIndentSepNode) isWalkableType() {}
func (c FacadeInplaceTableDefIndentSepNode) AllIndentSep() []IndentSepNode {
	var out []IndentSepNode
	for _, child := range ast.All(c.Node, "INDENT_SEP") {
		out = append(out, IndentSepNode{child})
	}
	return out
}

type FacadeInplaceTableDefNode struct{ ast.Node }

func (FacadeInplaceTableDefNode) isWalkableType() {}
func (c FacadeInplaceTableDefNode) AllAttribs() []AttribsNode {
	var out []AttribsNode
	for _, child := range ast.All(c.Node, "attribs") {
		out = append(out, AttribsNode{child})
	}
	return out
}

func (c FacadeInplaceTableDefNode) OneLevel() *IndentNode {
	if child := ast.First(c.Node, "level"); child != nil {
		return &IndentNode{child}
	}
	return nil
}

func (c FacadeInplaceTableDefNode) AllName() []NameNode {
	var out []NameNode
	for _, child := range ast.All(c.Node, "NAME") {
		out = append(out, NameNode{child})
	}
	return out
}

func (c FacadeInplaceTableDefNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type FacadeNode struct{ ast.Node }

func (FacadeNode) isWalkableType() {}
func (c FacadeNode) Choice() int   { return ast.Choice(c.Node) }

func (c FacadeNode) AllComment() []CommentNode {
	var out []CommentNode
	for _, child := range ast.All(c.Node, "COMMENT") {
		out = append(out, CommentNode{child})
	}
	return out
}

func (c FacadeNode) AllInplaceTableDef() []FacadeInplaceTableDefNode {
	var out []FacadeInplaceTableDefNode
	for _, child := range ast.All(c.Node, "inplace_table_def") {
		out = append(out, FacadeInplaceTableDefNode{child})
	}
	return out
}

func (c FacadeNode) OneLevel() *IndentNode {
	if child := ast.First(c.Node, "level"); child != nil {
		return &IndentNode{child}
	}
	return nil
}

func (c FacadeNode) OneName() *NameNode {
	if child := ast.First(c.Node, "NAME"); child != nil {
		return &NameNode{child}
	}
	return nil
}
func (c FacadeNode) AllName() []NameNode {
	var out []NameNode
	for _, child := range ast.All(c.Node, "NAME") {
		out = append(out, NameNode{child})
	}
	return out
}

func (c FacadeNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c FacadeNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type FieldIndentSepNode struct{ ast.Node }

func (FieldIndentSepNode) isWalkableType() {}
func (c FieldIndentSepNode) AllIndentSep() []IndentSepNode {
	var out []IndentSepNode
	for _, child := range ast.All(c.Node, "INDENT_SEP") {
		out = append(out, IndentSepNode{child})
	}
	return out
}

type FieldNode struct{ ast.Node }

func (FieldNode) isWalkableType() {}
func (c FieldNode) Choice() int   { return ast.Choice(c.Node) }

func (c FieldNode) OneArraySize() *ArraySizeNode {
	if child := ast.First(c.Node, "array_size"); child != nil {
		return &ArraySizeNode{child}
	}
	return nil
}

func (c FieldNode) AllField() []FieldNode {
	var out []FieldNode
	for _, child := range ast.All(c.Node, "field") {
		out = append(out, FieldNode{child})
	}
	return out
}

func (c FieldNode) OneFieldType() *FieldTypeNode {
	if child := ast.First(c.Node, "field_type"); child != nil {
		return &FieldTypeNode{child}
	}
	return nil
}

func (c FieldNode) OneLevel() *IndentNode {
	if child := ast.First(c.Node, "level"); child != nil {
		return &IndentNode{child}
	}
	return nil
}

func (c FieldNode) OneName() *NameNode {
	if child := ast.First(c.Node, "NAME"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c FieldNode) OneQstring() *QstringNode {
	if child := ast.First(c.Node, "QSTRING"); child != nil {
		return &QstringNode{child}
	}
	return nil
}

func (c FieldNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type FieldTypeNode struct{ ast.Node }

func (FieldTypeNode) isWalkableType() {}
func (c FieldTypeNode) Choice() int   { return ast.Choice(c.Node) }

func (c FieldTypeNode) OneAttribs() *AttribsNode {
	if child := ast.First(c.Node, "attribs"); child != nil {
		return &AttribsNode{child}
	}
	return nil
}

func (c FieldTypeNode) OneCollectionType() *CollectionTypeNode {
	if child := ast.First(c.Node, "collection_type"); child != nil {
		return &CollectionTypeNode{child}
	}
	return nil
}

func (c FieldTypeNode) OneOptional() string {
	if child := ast.First(c.Node, "optional"); child != nil {
		return ast.First(child, "").Scanner().String()
	}
	return ""
}

func (c FieldTypeNode) OneTypeSpec() *TypeSpecNode {
	if child := ast.First(c.Node, "type_spec"); child != nil {
		return &TypeSpecNode{child}
	}
	return nil
}

type FirstFuncNode struct{ ast.Node }

func (FirstFuncNode) isWalkableType() {}

func (c FirstFuncNode) OneFunc() string {
	if child := ast.First(c.Node, "func"); child != nil {
		return ast.First(child, "").Scanner().String()
	}
	return ""
}

func (c FirstFuncNode) OneRankExpr() *RankExprNode {
	if child := ast.First(c.Node, "rank_expr"); child != nil {
		return &RankExprNode{child}
	}
	return nil
}

func (c FirstFuncNode) OneScopevar() *FirstFuncScopevarNode {
	if child := ast.First(c.Node, "scopevar"); child != nil {
		return &FirstFuncScopevarNode{child}
	}
	return nil
}

func (c FirstFuncNode) OneTarget() *FirstFuncTargetNode {
	if child := ast.First(c.Node, "target"); child != nil {
		return &FirstFuncTargetNode{child}
	}
	return nil
}

func (c FirstFuncNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c FirstFuncNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type FirstFuncScopevarNode struct{ ast.Node }

func (FirstFuncScopevarNode) isWalkableType() {}

func (c FirstFuncScopevarNode) OneName() *NameNode {
	if child := ast.First(c.Node, "NAME"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c FirstFuncScopevarNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type FirstFuncTargetNode struct{ ast.Node }

func (FirstFuncTargetNode) isWalkableType() {}
func (c FirstFuncTargetNode) Choice() int   { return ast.Choice(c.Node) }

func (c FirstFuncTargetNode) OneExpr() *ExprNode {
	if child := ast.First(c.Node, "expr"); child != nil {
		return &ExprNode{child}
	}
	return nil
}

func (c FirstFuncTargetNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type ForStmtForTypeNode struct{ ast.Node }

func (ForStmtForTypeNode) isWalkableType() {}
func (c ForStmtForTypeNode) Choice() int   { return ast.Choice(c.Node) }

func (c ForStmtForTypeNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type ForStmtIndentSepNode struct{ ast.Node }

func (ForStmtIndentSepNode) isWalkableType() {}
func (c ForStmtIndentSepNode) AllIndentSep() []IndentSepNode {
	var out []IndentSepNode
	for _, child := range ast.All(c.Node, "INDENT_SEP") {
		out = append(out, IndentSepNode{child})
	}
	return out
}

type ForStmtNode struct{ ast.Node }

func (ForStmtNode) isWalkableType() {}

func (c ForStmtNode) OneForType() *ForStmtForTypeNode {
	if child := ast.First(c.Node, "for_type"); child != nil {
		return &ForStmtForTypeNode{child}
	}
	return nil
}

func (c ForStmtNode) OneLevel() *IndentNode {
	if child := ast.First(c.Node, "level"); child != nil {
		return &IndentNode{child}
	}
	return nil
}

func (c ForStmtNode) OnePredicate() *PredicateNode {
	if child := ast.First(c.Node, "PREDICATE"); child != nil {
		return &PredicateNode{child}
	}
	return nil
}

func (c ForStmtNode) AllStmt() []StmtNode {
	var out []StmtNode
	for _, child := range ast.All(c.Node, "stmt") {
		out = append(out, StmtNode{child})
	}
	return out
}

func (c ForStmtNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c ForStmtNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type GroupStmtIndentSepNode struct{ ast.Node }

func (GroupStmtIndentSepNode) isWalkableType() {}
func (c GroupStmtIndentSepNode) AllIndentSep() []IndentSepNode {
	var out []IndentSepNode
	for _, child := range ast.All(c.Node, "INDENT_SEP") {
		out = append(out, IndentSepNode{child})
	}
	return out
}

type GroupStmtNode struct{ ast.Node }

func (GroupStmtNode) isWalkableType() {}

func (c GroupStmtNode) OneLevel() *IndentNode {
	if child := ast.First(c.Node, "level"); child != nil {
		return &IndentNode{child}
	}
	return nil
}

func (c GroupStmtNode) OneName() *NameNode {
	if child := ast.First(c.Node, "NAME"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c GroupStmtNode) AllStmt() []StmtNode {
	var out []StmtNode
	for _, child := range ast.All(c.Node, "stmt") {
		out = append(out, StmtNode{child})
	}
	return out
}

func (c GroupStmtNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c GroupStmtNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type HttpPathNode struct{ ast.Node }

func (HttpPathNode) isWalkableType() {}
func (c HttpPathNode) Choice() int   { return ast.Choice(c.Node) }

func (c HttpPathNode) AllHttpPathPart() []HttpPathPartNode {
	var out []HttpPathPartNode
	for _, child := range ast.All(c.Node, "http_path_part") {
		out = append(out, HttpPathPartNode{child})
	}
	return out
}

func (c HttpPathNode) AllHttpPathVarWithType() []HttpPathVarWithTypeNode {
	var out []HttpPathVarWithTypeNode
	for _, child := range ast.All(c.Node, "http_path_var_with_type") {
		out = append(out, HttpPathVarWithTypeNode{child})
	}
	return out
}

func (c HttpPathNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type HttpPathPartNode struct{ ast.Node }

func (HttpPathPartNode) isWalkableType() {}
func (c HttpPathPartNode) Choice() int   { return ast.Choice(c.Node) }

func (c HttpPathPartNode) AllDigits() []DigitsNode {
	var out []DigitsNode
	for _, child := range ast.All(c.Node, "DIGITS") {
		out = append(out, DigitsNode{child})
	}
	return out
}

func (c HttpPathPartNode) AllName() []NameNode {
	var out []NameNode
	for _, child := range ast.All(c.Node, "NAME") {
		out = append(out, NameNode{child})
	}
	return out
}

func (c HttpPathPartNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type HttpPathPartWrapReNode struct{ ast.Node }

func (HttpPathPartWrapReNode) isWalkableType() {}
func (c *HttpPathPartWrapReNode) String() string {
	if c == nil || c.Node == nil {
		return ""
	}
	return c.Node.Scanner().String()
}

type HttpPathVarWithTypeNode struct{ ast.Node }

func (HttpPathVarWithTypeNode) isWalkableType() {}

func (c HttpPathVarWithTypeNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c HttpPathVarWithTypeNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

func (c HttpPathVarWithTypeNode) OneType() *HttpPathVarWithTypeTypeNode {
	if child := ast.First(c.Node, "type"); child != nil {
		return &HttpPathVarWithTypeTypeNode{child}
	}
	return nil
}

func (c HttpPathVarWithTypeNode) OneVar() *HttpPathVarWithTypeVarNode {
	if child := ast.First(c.Node, "var"); child != nil {
		return &HttpPathVarWithTypeVarNode{child}
	}
	return nil
}

type HttpPathVarWithTypeTypeNode struct{ ast.Node }

func (HttpPathVarWithTypeTypeNode) isWalkableType() {}
func (c HttpPathVarWithTypeTypeNode) Choice() int   { return ast.Choice(c.Node) }

func (c HttpPathVarWithTypeTypeNode) OneName() *NameNode {
	if child := ast.First(c.Node, "NAME"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c HttpPathVarWithTypeTypeNode) OneNativeDataTypes() *NativeDataTypesNode {
	if child := ast.First(c.Node, "NativeDataTypes"); child != nil {
		return &NativeDataTypesNode{child}
	}
	return nil
}

func (c HttpPathVarWithTypeTypeNode) OneReference() *ReferenceNode {
	if child := ast.First(c.Node, "reference"); child != nil {
		return &ReferenceNode{child}
	}
	return nil
}

type HttpPathVarWithTypeVarNode struct{ ast.Node }

func (HttpPathVarWithTypeVarNode) isWalkableType() {}
func (c HttpPathVarWithTypeVarNode) Choice() int   { return ast.Choice(c.Node) }

func (c HttpPathVarWithTypeVarNode) OneDigits() *DigitsNode {
	if child := ast.First(c.Node, "DIGITS"); child != nil {
		return &DigitsNode{child}
	}
	return nil
}

func (c HttpPathVarWithTypeVarNode) OneName() *NameNode {
	if child := ast.First(c.Node, "NAME"); child != nil {
		return &NameNode{child}
	}
	return nil
}

type HttpVerbsNode struct{ ast.Node }

func (HttpVerbsNode) isWalkableType() {}
func (c HttpVerbsNode) Choice() int   { return ast.Choice(c.Node) }

func (c HttpVerbsNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type IfElseNode struct{ ast.Node }

func (IfElseNode) isWalkableType() {}
func (c IfElseNode) AllElseStmt() []ElseStmtNode {
	var out []ElseStmtNode
	for _, child := range ast.All(c.Node, "else_stmt") {
		out = append(out, ElseStmtNode{child})
	}
	return out
}

func (c IfElseNode) OneIfStmt() *IfStmtNode {
	if child := ast.First(c.Node, "if_stmt"); child != nil {
		return &IfStmtNode{child}
	}
	return nil
}

type IfStmtIndentSepNode struct{ ast.Node }

func (IfStmtIndentSepNode) isWalkableType() {}
func (c IfStmtIndentSepNode) AllIndentSep() []IndentSepNode {
	var out []IndentSepNode
	for _, child := range ast.All(c.Node, "INDENT_SEP") {
		out = append(out, IndentSepNode{child})
	}
	return out
}

type IfStmtNode struct{ ast.Node }

func (IfStmtNode) isWalkableType() {}

func (c IfStmtNode) OneLevel() *IndentNode {
	if child := ast.First(c.Node, "level"); child != nil {
		return &IndentNode{child}
	}
	return nil
}

func (c IfStmtNode) OnePredicate() *PredicateNode {
	if child := ast.First(c.Node, "PREDICATE"); child != nil {
		return &PredicateNode{child}
	}
	return nil
}

func (c IfStmtNode) AllStmt() []StmtNode {
	var out []StmtNode
	for _, child := range ast.All(c.Node, "stmt") {
		out = append(out, StmtNode{child})
	}
	return out
}

func (c IfStmtNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c IfStmtNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type ImportNode struct{ ast.Node }

func (ImportNode) isWalkableType() {}

func (c ImportNode) OneMode() *NameNode {
	if child := ast.First(c.Node, "mode"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c ImportNode) OnePath() *PathNode {
	if child := ast.First(c.Node, "PATH"); child != nil {
		return &PathNode{child}
	}
	return nil
}

func (c ImportNode) OnePrefix() *ImportPrefixNode {
	if child := ast.First(c.Node, "prefix"); child != nil {
		return &ImportPrefixNode{child}
	}
	return nil
}

func (c ImportNode) OneReference() *ReferenceNode {
	if child := ast.First(c.Node, "reference"); child != nil {
		return &ReferenceNode{child}
	}
	return nil
}

func (c ImportNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c ImportNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type ImportPrefixNode struct{ ast.Node }

func (ImportPrefixNode) isWalkableType() {}
func (c ImportPrefixNode) Choice() int   { return ast.Choice(c.Node) }

func (c ImportPrefixNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type IndentNode struct{ ast.Node }

func (IndentNode) isWalkableType()      {}
func (c IndentNode) LevelRef() ast.Node { return ast.First(c.Node, "level") }

func (c IndentNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type IndentSepNode struct{ ast.Node }

func (IndentSepNode) isWalkableType()      {}
func (c IndentSepNode) LevelRef() ast.Node { return ast.First(c.Node, "level") }

func (c IndentSepNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type MatchingNode struct{ ast.Node }

func (MatchingNode) isWalkableType() {}

func (c MatchingNode) OneRhs() *MatchingRhsNode {
	if child := ast.First(c.Node, "rhs"); child != nil {
		return &MatchingRhsNode{child}
	}
	return nil
}

func (c MatchingNode) OneSquigglyArgs() *MatchingSquigglyArgsNode {
	if child := ast.First(c.Node, "squiggly_args"); child != nil {
		return &MatchingSquigglyArgsNode{child}
	}
	return nil
}

func (c MatchingNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c MatchingNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type MatchingRhsNode struct{ ast.Node }

func (MatchingRhsNode) isWalkableType() {}
func (c MatchingRhsNode) Choice() int   { return ast.Choice(c.Node) }

func (c MatchingRhsNode) OneExpr() *ExprNode {
	if child := ast.First(c.Node, "expr"); child != nil {
		return &ExprNode{child}
	}
	return nil
}

func (c MatchingRhsNode) OneExprTableOfOp() *ExprTableOfOpNode {
	if child := ast.First(c.Node, "expr_table_of_op"); child != nil {
		return &ExprTableOfOpNode{child}
	}
	return nil
}

func (c MatchingRhsNode) OneName() *NameNode {
	if child := ast.First(c.Node, "NAME"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c MatchingRhsNode) OneNavigate() *NavigateNode {
	if child := ast.First(c.Node, "navigate"); child != nil {
		return &NavigateNode{child}
	}
	return nil
}

func (c MatchingRhsNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c MatchingRhsNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type MatchingSquigglyArgsNode struct{ ast.Node }

func (MatchingSquigglyArgsNode) isWalkableType() {}
func (c MatchingSquigglyArgsNode) AllName() []NameNode {
	var out []NameNode
	for _, child := range ast.All(c.Node, "NAME") {
		out = append(out, NameNode{child})
	}
	return out
}

func (c MatchingSquigglyArgsNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type MethodDefIndentSepNode struct{ ast.Node }

func (MethodDefIndentSepNode) isWalkableType() {}
func (c MethodDefIndentSepNode) AllIndentSep() []IndentSepNode {
	var out []IndentSepNode
	for _, child := range ast.All(c.Node, "INDENT_SEP") {
		out = append(out, IndentSepNode{child})
	}
	return out
}

type MethodDefNode struct{ ast.Node }

func (MethodDefNode) isWalkableType() {}

func (c MethodDefNode) OneAttribs() *AttribsNode {
	if child := ast.First(c.Node, "attribs"); child != nil {
		return &AttribsNode{child}
	}
	return nil
}

func (c MethodDefNode) OneLevel() *IndentNode {
	if child := ast.First(c.Node, "level"); child != nil {
		return &IndentNode{child}
	}
	return nil
}

func (c MethodDefNode) OneMethod() *HttpVerbsNode {
	if child := ast.First(c.Node, "method"); child != nil {
		return &HttpVerbsNode{child}
	}
	return nil
}

func (c MethodDefNode) OneParams() *ParamsNode {
	if child := ast.First(c.Node, "params"); child != nil {
		return &ParamsNode{child}
	}
	return nil
}

func (c MethodDefNode) OneQueryParam() *QueryParamNode {
	if child := ast.First(c.Node, "query_param"); child != nil {
		return &QueryParamNode{child}
	}
	return nil
}

func (c MethodDefNode) AllStmt() []StmtNode {
	var out []StmtNode
	for _, child := range ast.All(c.Node, "stmt") {
		out = append(out, StmtNode{child})
	}
	return out
}

func (c MethodDefNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c MethodDefNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type MultiLineDocstringIndentSepNode struct{ ast.Node }

func (MultiLineDocstringIndentSepNode) isWalkableType() {}
func (c MultiLineDocstringIndentSepNode) AllIndentSep() []IndentSepNode {
	var out []IndentSepNode
	for _, child := range ast.All(c.Node, "INDENT_SEP") {
		out = append(out, IndentSepNode{child})
	}
	return out
}

type MultiLineDocstringNode struct{ ast.Node }

func (MultiLineDocstringNode) isWalkableType() {}

func (c MultiLineDocstringNode) OneLevel() *IndentNode {
	if child := ast.First(c.Node, "level"); child != nil {
		return &IndentNode{child}
	}
	return nil
}

func (c MultiLineDocstringNode) AllText() []TextNode {
	var out []TextNode
	for _, child := range ast.All(c.Node, "TEXT") {
		out = append(out, TextNode{child})
	}
	return out
}

func (c MultiLineDocstringNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c MultiLineDocstringNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type NameNode struct{ ast.Node }

func (NameNode) isWalkableType() {}
func (c *NameNode) String() string {
	if c == nil || c.Node == nil {
		return ""
	}
	return c.Node.Scanner().String()
}

type NativeDataTypesNode struct{ ast.Node }

func (NativeDataTypesNode) isWalkableType() {}
func (c NativeDataTypesNode) Choice() int   { return ast.Choice(c.Node) }

func (c NativeDataTypesNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type NavigateAttrNode struct{ ast.Node }

func (NavigateAttrNode) isWalkableType() {}

func (c NavigateAttrNode) OneName() *NameNode {
	if child := ast.First(c.Node, "NAME"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c NavigateAttrNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type NavigateNode struct{ ast.Node }

func (NavigateNode) isWalkableType() {}
func (c NavigateNode) Choice() int   { return ast.Choice(c.Node) }

func (c NavigateNode) OneAttr() *NavigateAttrNode {
	if child := ast.First(c.Node, "attr"); child != nil {
		return &NavigateAttrNode{child}
	}
	return nil
}

func (c NavigateNode) OneQn() string {
	if child := ast.First(c.Node, "qn"); child != nil {
		return ast.First(child, "").Scanner().String()
	}
	return ""
}

func (c NavigateNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c NavigateNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

func (c NavigateNode) OneVia() *NameNode {
	if child := ast.First(c.Node, "via"); child != nil {
		return &NameNode{child}
	}
	return nil
}

type OneOfCasesIndentSepNode struct{ ast.Node }

func (OneOfCasesIndentSepNode) isWalkableType() {}
func (c OneOfCasesIndentSepNode) AllIndentSep() []IndentSepNode {
	var out []IndentSepNode
	for _, child := range ast.All(c.Node, "INDENT_SEP") {
		out = append(out, IndentSepNode{child})
	}
	return out
}

type OneOfCasesNode struct{ ast.Node }

func (OneOfCasesNode) isWalkableType() {}

func (c OneOfCasesNode) OneLevel() *IndentNode {
	if child := ast.First(c.Node, "level"); child != nil {
		return &IndentNode{child}
	}
	return nil
}

func (c OneOfCasesNode) OneOneOfCaseLabel() *OneOfCasesOneOfCaseLabelNode {
	if child := ast.First(c.Node, "one_of_case_label"); child != nil {
		return &OneOfCasesOneOfCaseLabelNode{child}
	}
	return nil
}

func (c OneOfCasesNode) AllStmt() []StmtNode {
	var out []StmtNode
	for _, child := range ast.All(c.Node, "stmt") {
		out = append(out, StmtNode{child})
	}
	return out
}

func (c OneOfCasesNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type OneOfCasesOneOfCaseLabelNode struct{ ast.Node }

func (OneOfCasesOneOfCaseLabelNode) isWalkableType() {}
func (c OneOfCasesOneOfCaseLabelNode) Choice() int   { return ast.Choice(c.Node) }

func (c OneOfCasesOneOfCaseLabelNode) OneName() *NameNode {
	if child := ast.First(c.Node, "NAME"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c OneOfCasesOneOfCaseLabelNode) OneQstring() *QstringNode {
	if child := ast.First(c.Node, "QSTRING"); child != nil {
		return &QstringNode{child}
	}
	return nil
}

func (c OneOfCasesOneOfCaseLabelNode) OneTextLine() *TextLineNode {
	if child := ast.First(c.Node, "TEXT_LINE"); child != nil {
		return &TextLineNode{child}
	}
	return nil
}

func (c OneOfCasesOneOfCaseLabelNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type OneOfStmtIndentSepNode struct{ ast.Node }

func (OneOfStmtIndentSepNode) isWalkableType() {}
func (c OneOfStmtIndentSepNode) AllIndentSep() []IndentSepNode {
	var out []IndentSepNode
	for _, child := range ast.All(c.Node, "INDENT_SEP") {
		out = append(out, IndentSepNode{child})
	}
	return out
}

type OneOfStmtNode struct{ ast.Node }

func (OneOfStmtNode) isWalkableType() {}

func (c OneOfStmtNode) OneLevel() *IndentNode {
	if child := ast.First(c.Node, "level"); child != nil {
		return &IndentNode{child}
	}
	return nil
}

func (c OneOfStmtNode) AllOneOfCases() []OneOfCasesNode {
	var out []OneOfCasesNode
	for _, child := range ast.All(c.Node, "one_of_cases") {
		out = append(out, OneOfCasesNode{child})
	}
	return out
}

func (c OneOfStmtNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c OneOfStmtNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type ParamsNode struct{ ast.Node }

func (ParamsNode) isWalkableType() {}
func (c ParamsNode) Choice() int   { return ast.Choice(c.Node) }

func (c ParamsNode) AllField() []FieldNode {
	var out []FieldNode
	for _, child := range ast.All(c.Node, "field") {
		out = append(out, FieldNode{child})
	}
	return out
}

func (c ParamsNode) AllReference() []ReferenceNode {
	var out []ReferenceNode
	for _, child := range ast.All(c.Node, "reference") {
		out = append(out, ReferenceNode{child})
	}
	return out
}

func (c ParamsNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type PathNode struct{ ast.Node }

func (PathNode) isWalkableType() {}

func (c PathNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type PredicateNode struct{ ast.Node }

func (PredicateNode) isWalkableType() {}
func (c *PredicateNode) String() string {
	if c == nil || c.Node == nil {
		return ""
	}
	return c.Node.Scanner().String()
}

type QstringNode struct{ ast.Node }

func (QstringNode) isWalkableType() {}
func (c *QstringNode) String() string {
	if c == nil || c.Node == nil {
		return ""
	}
	return c.Node.Scanner().String()
}

type QueryParamNode struct{ ast.Node }

func (QueryParamNode) isWalkableType() {}
func (c QueryParamNode) Choice() int   { return ast.Choice(c.Node) }

func (c QueryParamNode) AllIdent() []NameNode {
	var out []NameNode
	for _, child := range ast.All(c.Node, "ident") {
		out = append(out, NameNode{child})
	}
	return out
}

func (c QueryParamNode) AllName() []NameNode {
	var out []NameNode
	for _, child := range ast.All(c.Node, "NAME") {
		out = append(out, NameNode{child})
	}
	return out
}

func (c QueryParamNode) AllNativeDataTypes() []NativeDataTypesNode {
	var out []NativeDataTypesNode
	for _, child := range ast.All(c.Node, "NativeDataTypes") {
		out = append(out, NativeDataTypesNode{child})
	}
	return out
}

func (c QueryParamNode) AllOptional() []string {
	var out []string
	for _, child := range ast.All(c.Node, "optional") {
		out = append(out, ast.First(child, "").Scanner().String())
	}
	return out
}

func (c QueryParamNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c QueryParamNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type RankExprFuncNode struct{ ast.Node }

func (RankExprFuncNode) isWalkableType() {}
func (c RankExprFuncNode) Choice() int   { return ast.Choice(c.Node) }

func (c RankExprFuncNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type RankExprNode struct{ ast.Node }

func (RankExprNode) isWalkableType() {}
func (c RankExprNode) AllExpr() []ExprNode {
	var out []ExprNode
	for _, child := range ast.All(c.Node, "expr") {
		out = append(out, ExprNode{child})
	}
	return out
}

func (c RankExprNode) AllFunc() []RankExprFuncNode {
	var out []RankExprFuncNode
	for _, child := range ast.All(c.Node, "func") {
		out = append(out, RankExprFuncNode{child})
	}
	return out
}

type RankFuncNode struct{ ast.Node }

func (RankFuncNode) isWalkableType() {}

func (c RankFuncNode) OneAs() *NameNode {
	if child := ast.First(c.Node, "as"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c RankFuncNode) OneFunc() string {
	if child := ast.First(c.Node, "func"); child != nil {
		return ast.First(child, "").Scanner().String()
	}
	return ""
}

func (c RankFuncNode) OneRankExpr() *RankExprNode {
	if child := ast.First(c.Node, "rank_expr"); child != nil {
		return &RankExprNode{child}
	}
	return nil
}

func (c RankFuncNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c RankFuncNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

func (c RankFuncNode) OneTypeSpec() *TypeSpecNode {
	if child := ast.First(c.Node, "type_spec"); child != nil {
		return &TypeSpecNode{child}
	}
	return nil
}

type ReferenceNode struct{ ast.Node }

func (ReferenceNode) isWalkableType() {}

func (c ReferenceNode) OneAppname() *AppnameNode {
	if child := ast.First(c.Node, "APPNAME"); child != nil {
		return &AppnameNode{child}
	}
	return nil
}

func (c ReferenceNode) OnePkg() *ReferencePkgNode {
	if child := ast.First(c.Node, "pkg"); child != nil {
		return &ReferencePkgNode{child}
	}
	return nil
}

func (c ReferenceNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type ReferencePkgNode struct{ ast.Node }

func (ReferencePkgNode) isWalkableType() {}
func (c ReferencePkgNode) AllName() []NameNode {
	var out []NameNode
	for _, child := range ast.All(c.Node, "NAME") {
		out = append(out, NameNode{child})
	}
	return out
}

func (c ReferencePkgNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type RelopNode struct{ ast.Node }

func (RelopNode) isWalkableType() {}
func (c RelopNode) Choice() int   { return ast.Choice(c.Node) }

func (c RelopNode) OneAggFunc() *AggFuncNode {
	if child := ast.First(c.Node, "agg_func"); child != nil {
		return &AggFuncNode{child}
	}
	return nil
}

func (c RelopNode) OneAnyFunc() *AnyFuncNode {
	if child := ast.First(c.Node, "any_func"); child != nil {
		return &AnyFuncNode{child}
	}
	return nil
}

func (c RelopNode) OneCount() *CountNode {
	if child := ast.First(c.Node, "count"); child != nil {
		return &CountNode{child}
	}
	return nil
}

func (c RelopNode) OneExprTableOfOp() *ExprTableOfOpNode {
	if child := ast.First(c.Node, "expr_table_of_op"); child != nil {
		return &ExprTableOfOpNode{child}
	}
	return nil
}

func (c RelopNode) OneFirstFunc() *FirstFuncNode {
	if child := ast.First(c.Node, "first_func"); child != nil {
		return &FirstFuncNode{child}
	}
	return nil
}

func (c RelopNode) OneMatching() *MatchingNode {
	if child := ast.First(c.Node, "matching"); child != nil {
		return &MatchingNode{child}
	}
	return nil
}

func (c RelopNode) OneNavigate() *NavigateNode {
	if child := ast.First(c.Node, "navigate"); child != nil {
		return &NavigateNode{child}
	}
	return nil
}

func (c RelopNode) OneRankFunc() *RankFuncNode {
	if child := ast.First(c.Node, "rank_func"); child != nil {
		return &RankFuncNode{child}
	}
	return nil
}

func (c RelopNode) OneSingleArgFunc() *SingleArgFuncNode {
	if child := ast.First(c.Node, "single_arg_func"); child != nil {
		return &SingleArgFuncNode{child}
	}
	return nil
}

func (c RelopNode) OneSingleOrNull() *SingleOrNullNode {
	if child := ast.First(c.Node, "single_or_null"); child != nil {
		return &SingleOrNullNode{child}
	}
	return nil
}

func (c RelopNode) OneSnapshot() *SnapshotNode {
	if child := ast.First(c.Node, "snapshot"); child != nil {
		return &SnapshotNode{child}
	}
	return nil
}

type RestEndpointIndentSepNode struct{ ast.Node }

func (RestEndpointIndentSepNode) isWalkableType() {}
func (c RestEndpointIndentSepNode) AllIndentSep() []IndentSepNode {
	var out []IndentSepNode
	for _, child := range ast.All(c.Node, "INDENT_SEP") {
		out = append(out, IndentSepNode{child})
	}
	return out
}

type RestEndpointNode struct{ ast.Node }

func (RestEndpointNode) isWalkableType() {}
func (c RestEndpointNode) Choice() int   { return ast.Choice(c.Node) }

func (c RestEndpointNode) OneAttribs() *AttribsNode {
	if child := ast.First(c.Node, "attribs"); child != nil {
		return &AttribsNode{child}
	}
	return nil
}

func (c RestEndpointNode) OneHttpPath() *HttpPathNode {
	if child := ast.First(c.Node, "http_path"); child != nil {
		return &HttpPathNode{child}
	}
	return nil
}

func (c RestEndpointNode) OneLevel() *IndentNode {
	if child := ast.First(c.Node, "level"); child != nil {
		return &IndentNode{child}
	}
	return nil
}

func (c RestEndpointNode) AllMethodDef() []MethodDefNode {
	var out []MethodDefNode
	for _, child := range ast.All(c.Node, "method_def") {
		out = append(out, MethodDefNode{child})
	}
	return out
}

func (c RestEndpointNode) AllRestEndpoint() []RestEndpointNode {
	var out []RestEndpointNode
	for _, child := range ast.All(c.Node, "rest_endpoint") {
		out = append(out, RestEndpointNode{child})
	}
	return out
}

func (c RestEndpointNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c RestEndpointNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type RetStmtNode struct{ ast.Node }

func (RetStmtNode) isWalkableType() {}

func (c RetStmtNode) OneRetVal() *TextNode {
	if child := ast.First(c.Node, "ret_val"); child != nil {
		return &TextNode{child}
	}
	return nil
}

func (c RetStmtNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type ShortcutNode struct{ ast.Node }

func (ShortcutNode) isWalkableType() {}
func (c *ShortcutNode) String() string {
	if c == nil || c.Node == nil {
		return ""
	}
	return c.Node.Scanner().String()
}

type SimpleEndpointIndentSepNode struct{ ast.Node }

func (SimpleEndpointIndentSepNode) isWalkableType() {}
func (c SimpleEndpointIndentSepNode) AllIndentSep() []IndentSepNode {
	var out []IndentSepNode
	for _, child := range ast.All(c.Node, "INDENT_SEP") {
		out = append(out, IndentSepNode{child})
	}
	return out
}

type SimpleEndpointNode struct{ ast.Node }

func (SimpleEndpointNode) isWalkableType() {}
func (c SimpleEndpointNode) Choice() int   { return ast.Choice(c.Node) }

func (c SimpleEndpointNode) OneAttribs() *AttribsNode {
	if child := ast.First(c.Node, "attribs"); child != nil {
		return &AttribsNode{child}
	}
	return nil
}

func (c SimpleEndpointNode) OneEndpointName() *AppnameNode {
	if child := ast.First(c.Node, "endpoint_name"); child != nil {
		return &AppnameNode{child}
	}
	return nil
}

func (c SimpleEndpointNode) OneLevel() *IndentNode {
	if child := ast.First(c.Node, "level"); child != nil {
		return &IndentNode{child}
	}
	return nil
}

func (c SimpleEndpointNode) OneParams() *ParamsNode {
	if child := ast.First(c.Node, "params"); child != nil {
		return &ParamsNode{child}
	}
	return nil
}

func (c SimpleEndpointNode) OneQstring() *QstringNode {
	if child := ast.First(c.Node, "QSTRING"); child != nil {
		return &QstringNode{child}
	}
	return nil
}

func (c SimpleEndpointNode) OneShortcut() *ShortcutNode {
	if child := ast.First(c.Node, "SHORTCUT"); child != nil {
		return &ShortcutNode{child}
	}
	return nil
}

func (c SimpleEndpointNode) AllStmt() []StmtNode {
	var out []StmtNode
	for _, child := range ast.All(c.Node, "stmt") {
		out = append(out, StmtNode{child})
	}
	return out
}

func (c SimpleEndpointNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type SingleArgFuncFuncNode struct{ ast.Node }

func (SingleArgFuncFuncNode) isWalkableType() {}
func (c SingleArgFuncFuncNode) Choice() int   { return ast.Choice(c.Node) }

func (c SingleArgFuncFuncNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type SingleArgFuncNode struct{ ast.Node }

func (SingleArgFuncNode) isWalkableType() {}

func (c SingleArgFuncNode) OneExpr() *ExprNode {
	if child := ast.First(c.Node, "expr"); child != nil {
		return &ExprNode{child}
	}
	return nil
}

func (c SingleArgFuncNode) OneFunc() *SingleArgFuncFuncNode {
	if child := ast.First(c.Node, "func"); child != nil {
		return &SingleArgFuncFuncNode{child}
	}
	return nil
}

func (c SingleArgFuncNode) OneScopevar() *SingleArgFuncScopevarNode {
	if child := ast.First(c.Node, "scopevar"); child != nil {
		return &SingleArgFuncScopevarNode{child}
	}
	return nil
}

func (c SingleArgFuncNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c SingleArgFuncNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type SingleArgFuncScopevarNode struct{ ast.Node }

func (SingleArgFuncScopevarNode) isWalkableType() {}

func (c SingleArgFuncScopevarNode) OneName() *NameNode {
	if child := ast.First(c.Node, "NAME"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c SingleArgFuncScopevarNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type SingleOrNullNode struct{ ast.Node }

func (SingleOrNullNode) isWalkableType() {}
func (c SingleOrNullNode) Choice() int   { return ast.Choice(c.Node) }

func (c SingleOrNullNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type SnapshotNode struct{ ast.Node }

func (SnapshotNode) isWalkableType() {}
func (c *SnapshotNode) String() string {
	if c == nil || c.Node == nil {
		return ""
	}
	return c.Node.Scanner().String()
}

type StmtNode struct{ ast.Node }

func (StmtNode) isWalkableType() {}
func (c StmtNode) Choice() int   { return ast.Choice(c.Node) }

func (c StmtNode) OneAnnotation() *AnnotationNode {
	if child := ast.First(c.Node, "annotation"); child != nil {
		return &AnnotationNode{child}
	}
	return nil
}

func (c StmtNode) OneAttribs() *AttribsNode {
	if child := ast.First(c.Node, "attribs"); child != nil {
		return &AttribsNode{child}
	}
	return nil
}

func (c StmtNode) OneCallStmt() *CallStmtNode {
	if child := ast.First(c.Node, "call_stmt"); child != nil {
		return &CallStmtNode{child}
	}
	return nil
}

func (c StmtNode) OneForStmt() *ForStmtNode {
	if child := ast.First(c.Node, "for_stmt"); child != nil {
		return &ForStmtNode{child}
	}
	return nil
}

func (c StmtNode) OneGroupStmt() *GroupStmtNode {
	if child := ast.First(c.Node, "group_stmt"); child != nil {
		return &GroupStmtNode{child}
	}
	return nil
}

func (c StmtNode) OneHttpMethodComment() *CommentNoNlNode {
	if child := ast.First(c.Node, "http_method_comment"); child != nil {
		return &CommentNoNlNode{child}
	}
	return nil
}

func (c StmtNode) OneIfElse() *IfElseNode {
	if child := ast.First(c.Node, "if_else"); child != nil {
		return &IfElseNode{child}
	}
	return nil
}

func (c StmtNode) OneOneOfStmt() *OneOfStmtNode {
	if child := ast.First(c.Node, "one_of_stmt"); child != nil {
		return &OneOfStmtNode{child}
	}
	return nil
}

func (c StmtNode) OneRetStmt() *RetStmtNode {
	if child := ast.First(c.Node, "ret_stmt"); child != nil {
		return &RetStmtNode{child}
	}
	return nil
}

func (c StmtNode) OneTextStmt() *TextStmtNode {
	if child := ast.First(c.Node, "text_stmt"); child != nil {
		return &TextStmtNode{child}
	}
	return nil
}

type SubscribeIndentSepNode struct{ ast.Node }

func (SubscribeIndentSepNode) isWalkableType() {}
func (c SubscribeIndentSepNode) AllIndentSep() []IndentSepNode {
	var out []IndentSepNode
	for _, child := range ast.All(c.Node, "INDENT_SEP") {
		out = append(out, IndentSepNode{child})
	}
	return out
}

type SubscribeNode struct{ ast.Node }

func (SubscribeNode) isWalkableType() {}
func (c SubscribeNode) Choice() int   { return ast.Choice(c.Node) }

func (c SubscribeNode) OneAppname() *AppnameNode {
	if child := ast.First(c.Node, "APPNAME"); child != nil {
		return &AppnameNode{child}
	}
	return nil
}

func (c SubscribeNode) OneAttribs() *AttribsNode {
	if child := ast.First(c.Node, "attribs"); child != nil {
		return &AttribsNode{child}
	}
	return nil
}

func (c SubscribeNode) AllComment() []CommentNode {
	var out []CommentNode
	for _, child := range ast.All(c.Node, "COMMENT") {
		out = append(out, CommentNode{child})
	}
	return out
}

func (c SubscribeNode) OneLevel() *IndentNode {
	if child := ast.First(c.Node, "level"); child != nil {
		return &IndentNode{child}
	}
	return nil
}

func (c SubscribeNode) OneName() *NameNode {
	if child := ast.First(c.Node, "NAME"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c SubscribeNode) OneParams() *ParamsNode {
	if child := ast.First(c.Node, "params"); child != nil {
		return &ParamsNode{child}
	}
	return nil
}

func (c SubscribeNode) OneShortcut() *ShortcutNode {
	if child := ast.First(c.Node, "SHORTCUT"); child != nil {
		return &ShortcutNode{child}
	}
	return nil
}

func (c SubscribeNode) AllStmt() []StmtNode {
	var out []StmtNode
	for _, child := range ast.All(c.Node, "stmt") {
		out = append(out, StmtNode{child})
	}
	return out
}

func (c SubscribeNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c SubscribeNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type SyslFileNode struct{ ast.Node }

func (SyslFileNode) isWalkableType() {}
func (c SyslFileNode) Choice() int   { return ast.Choice(c.Node) }

func (c SyslFileNode) AllApplication() []ApplicationNode {
	var out []ApplicationNode
	for _, child := range ast.All(c.Node, "application") {
		out = append(out, ApplicationNode{child})
	}
	return out
}

func (c SyslFileNode) AllEol() []EolNode {
	var out []EolNode
	for _, child := range ast.All(c.Node, "EOL") {
		out = append(out, EolNode{child})
	}
	return out
}

func (c SyslFileNode) AllImport() []ImportNode {
	var out []ImportNode
	for _, child := range ast.All(c.Node, "import") {
		out = append(out, ImportNode{child})
	}
	return out
}

type TableIndentSepNode struct{ ast.Node }

func (TableIndentSepNode) isWalkableType() {}
func (c TableIndentSepNode) AllIndentSep() []IndentSepNode {
	var out []IndentSepNode
	for _, child := range ast.All(c.Node, "INDENT_SEP") {
		out = append(out, IndentSepNode{child})
	}
	return out
}

type TableModeNode struct{ ast.Node }

func (TableModeNode) isWalkableType() {}
func (c TableModeNode) Choice() int   { return ast.Choice(c.Node) }

func (c TableModeNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type TableNode struct{ ast.Node }

func (TableNode) isWalkableType() {}
func (c TableNode) Choice() int   { return ast.Choice(c.Node) }

func (c TableNode) OneAttribs() *AttribsNode {
	if child := ast.First(c.Node, "attribs"); child != nil {
		return &AttribsNode{child}
	}
	return nil
}

func (c TableNode) AllComment() []CommentNode {
	var out []CommentNode
	for _, child := range ast.All(c.Node, "COMMENT") {
		out = append(out, CommentNode{child})
	}
	return out
}

func (c TableNode) AllCommentNoNl() []CommentNoNlNode {
	var out []CommentNoNlNode
	for _, child := range ast.All(c.Node, "COMMENT_NO_NL") {
		out = append(out, CommentNoNlNode{child})
	}
	return out
}

func (c TableNode) OneLevel() *IndentNode {
	if child := ast.First(c.Node, "level"); child != nil {
		return &IndentNode{child}
	}
	return nil
}

func (c TableNode) OneMode() *TableModeNode {
	if child := ast.First(c.Node, "mode"); child != nil {
		return &TableModeNode{child}
	}
	return nil
}

func (c TableNode) OneName() *NameNode {
	if child := ast.First(c.Node, "NAME"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c TableNode) AllTableRow() []TableTableRowNode {
	var out []TableTableRowNode
	for _, child := range ast.All(c.Node, "table_row") {
		out = append(out, TableTableRowNode{child})
	}
	return out
}

func (c TableNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c TableNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type TableTableRowNode struct{ ast.Node }

func (TableTableRowNode) isWalkableType() {}

func (c TableTableRowNode) OneAnnotations() *AnnotationsNode {
	if child := ast.First(c.Node, "annotations"); child != nil {
		return &AnnotationsNode{child}
	}
	return nil
}

func (c TableTableRowNode) OneArraySize() *ArraySizeNode {
	if child := ast.First(c.Node, "array_size"); child != nil {
		return &ArraySizeNode{child}
	}
	return nil
}

func (c TableTableRowNode) OneAttribs() *AttribsNode {
	if child := ast.First(c.Node, "attribs"); child != nil {
		return &AttribsNode{child}
	}
	return nil
}

func (c TableTableRowNode) OneName() *NameNode {
	if child := ast.First(c.Node, "NAME"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c TableTableRowNode) OneOptional() string {
	if child := ast.First(c.Node, "optional"); child != nil {
		return ast.First(child, "").Scanner().String()
	}
	return ""
}

func (c TableTableRowNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c TableTableRowNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

func (c TableTableRowNode) OneType() *TableTableRowTypeNode {
	if child := ast.First(c.Node, "type"); child != nil {
		return &TableTableRowTypeNode{child}
	}
	return nil
}

type TableTableRowTypeNode struct{ ast.Node }

func (TableTableRowTypeNode) isWalkableType() {}
func (c TableTableRowTypeNode) Choice() int   { return ast.Choice(c.Node) }

func (c TableTableRowTypeNode) OneCollectionType() *CollectionTypeNode {
	if child := ast.First(c.Node, "collection_type"); child != nil {
		return &CollectionTypeNode{child}
	}
	return nil
}

func (c TableTableRowTypeNode) OneTypeSpec() *TypeSpecNode {
	if child := ast.First(c.Node, "type_spec"); child != nil {
		return &TypeSpecNode{child}
	}
	return nil
}

type TextLineNode struct{ ast.Node }

func (TextLineNode) isWalkableType() {}
func (c *TextLineNode) String() string {
	if c == nil || c.Node == nil {
		return ""
	}
	return c.Node.Scanner().String()
}

type TextNode struct{ ast.Node }

func (TextNode) isWalkableType() {}
func (c *TextNode) String() string {
	if c == nil || c.Node == nil {
		return ""
	}
	return c.Node.Scanner().String()
}

type TextStmtDocStringNode struct{ ast.Node }

func (TextStmtDocStringNode) isWalkableType() {}

func (c TextStmtDocStringNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type TextStmtNode struct{ ast.Node }

func (TextStmtNode) isWalkableType() {}
func (c TextStmtNode) Choice() int   { return ast.Choice(c.Node) }

func (c TextStmtNode) OneDocString() *TextStmtDocStringNode {
	if child := ast.First(c.Node, "doc_string"); child != nil {
		return &TextStmtDocStringNode{child}
	}
	return nil
}

func (c TextStmtNode) OneName() *NameNode {
	if child := ast.First(c.Node, "NAME"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c TextStmtNode) OneQstring() *QstringNode {
	if child := ast.First(c.Node, "QSTRING"); child != nil {
		return &QstringNode{child}
	}
	return nil
}

func (c TextStmtNode) OneShortcut() *ShortcutNode {
	if child := ast.First(c.Node, "SHORTCUT"); child != nil {
		return &ShortcutNode{child}
	}
	return nil
}

func (c TextStmtNode) OneText() *TextNode {
	if child := ast.First(c.Node, "TEXT"); child != nil {
		return &TextNode{child}
	}
	return nil
}

func (c TextStmtNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type TypeDeclNode struct{ ast.Node }

func (TypeDeclNode) isWalkableType() {}
func (c TypeDeclNode) Choice() int   { return ast.Choice(c.Node) }

func (c TypeDeclNode) OneAlias() *AliasNode {
	if child := ast.First(c.Node, "alias"); child != nil {
		return &AliasNode{child}
	}
	return nil
}

func (c TypeDeclNode) OneEnum() *EnumNode {
	if child := ast.First(c.Node, "enum"); child != nil {
		return &EnumNode{child}
	}
	return nil
}

func (c TypeDeclNode) OneFacade() *FacadeNode {
	if child := ast.First(c.Node, "facade"); child != nil {
		return &FacadeNode{child}
	}
	return nil
}

func (c TypeDeclNode) OneTable() *TableNode {
	if child := ast.First(c.Node, "table"); child != nil {
		return &TableNode{child}
	}
	return nil
}

func (c TypeDeclNode) OneUnion() *UnionNode {
	if child := ast.First(c.Node, "union"); child != nil {
		return &UnionNode{child}
	}
	return nil
}

type TypeSpecNode struct{ ast.Node }

func (TypeSpecNode) isWalkableType() {}
func (c TypeSpecNode) Choice() int   { return ast.Choice(c.Node) }

func (c TypeSpecNode) OneNativeDataTypes() *NativeDataTypesNode {
	if child := ast.First(c.Node, "NativeDataTypes"); child != nil {
		return &NativeDataTypesNode{child}
	}
	return nil
}

func (c TypeSpecNode) OneReference() *ReferenceNode {
	if child := ast.First(c.Node, "reference"); child != nil {
		return &ReferenceNode{child}
	}
	return nil
}

func (c TypeSpecNode) OneSizeSpec() *TypeSpecSizeSpecNode {
	if child := ast.First(c.Node, "SizeSpec"); child != nil {
		return &TypeSpecSizeSpecNode{child}
	}
	return nil
}

type TypeSpecSizeSpecNode struct{ ast.Node }

func (TypeSpecSizeSpecNode) isWalkableType() {}
func (c TypeSpecSizeSpecNode) Choice() int   { return ast.Choice(c.Node) }

func (c TypeSpecSizeSpecNode) OneArray() string {
	if child := ast.First(c.Node, "array"); child != nil {
		return ast.First(child, "").Scanner().String()
	}
	return ""
}

func (c TypeSpecSizeSpecNode) OneSized() string {
	if child := ast.First(c.Node, "sized"); child != nil {
		return ast.First(child, "").Scanner().String()
	}
	return ""
}

func (c TypeSpecSizeSpecNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c TypeSpecSizeSpecNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

type UnionIndentSepNode struct{ ast.Node }

func (UnionIndentSepNode) isWalkableType() {}
func (c UnionIndentSepNode) AllIndentSep() []IndentSepNode {
	var out []IndentSepNode
	for _, child := range ast.All(c.Node, "INDENT_SEP") {
		out = append(out, IndentSepNode{child})
	}
	return out
}

type UnionNode struct{ ast.Node }

func (UnionNode) isWalkableType() {}
func (c UnionNode) Choice() int   { return ast.Choice(c.Node) }

func (c UnionNode) AllAnnotation() []AnnotationNode {
	var out []AnnotationNode
	for _, child := range ast.All(c.Node, "annotation") {
		out = append(out, AnnotationNode{child})
	}
	return out
}

func (c UnionNode) OneAttribs() *AttribsNode {
	if child := ast.First(c.Node, "attribs"); child != nil {
		return &AttribsNode{child}
	}
	return nil
}

func (c UnionNode) AllComment() []CommentNode {
	var out []CommentNode
	for _, child := range ast.All(c.Node, "COMMENT") {
		out = append(out, CommentNode{child})
	}
	return out
}

func (c UnionNode) OneLevel() *IndentNode {
	if child := ast.First(c.Node, "level"); child != nil {
		return &IndentNode{child}
	}
	return nil
}

func (c UnionNode) OneName() *NameNode {
	if child := ast.First(c.Node, "NAME"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c UnionNode) OneShortcut() *ShortcutNode {
	if child := ast.First(c.Node, "SHORTCUT"); child != nil {
		return &ShortcutNode{child}
	}
	return nil
}
func (c UnionNode) AllShortcut() []ShortcutNode {
	var out []ShortcutNode
	for _, child := range ast.All(c.Node, "SHORTCUT") {
		out = append(out, ShortcutNode{child})
	}
	return out
}

func (c UnionNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c UnionNode) AllTypeSpec() []TypeSpecNode {
	var out []TypeSpecNode
	for _, child := range ast.All(c.Node, "type_spec") {
		out = append(out, TypeSpecNode{child})
	}
	return out
}

type ViewIndentSepNode struct{ ast.Node }

func (ViewIndentSepNode) isWalkableType() {}
func (c ViewIndentSepNode) AllIndentSep() []IndentSepNode {
	var out []IndentSepNode
	for _, child := range ast.All(c.Node, "INDENT_SEP") {
		out = append(out, IndentSepNode{child})
	}
	return out
}

type ViewNode struct{ ast.Node }

func (ViewNode) isWalkableType() {}
func (c ViewNode) Choice() int   { return ast.Choice(c.Node) }

func (c ViewNode) OneAbstract() string {
	if child := ast.First(c.Node, "abstract"); child != nil {
		return ast.First(child, "").Scanner().String()
	}
	return ""
}

func (c ViewNode) OneAttribs() *AttribsNode {
	if child := ast.First(c.Node, "attribs"); child != nil {
		return &AttribsNode{child}
	}
	return nil
}

func (c ViewNode) AllExprBlock() []ExprBlockNode {
	var out []ExprBlockNode
	for _, child := range ast.All(c.Node, "expr_block") {
		out = append(out, ExprBlockNode{child})
	}
	return out
}

func (c ViewNode) OneLevel() *IndentNode {
	if child := ast.First(c.Node, "level"); child != nil {
		return &IndentNode{child}
	}
	return nil
}

func (c ViewNode) OneName() *NameNode {
	if child := ast.First(c.Node, "NAME"); child != nil {
		return &NameNode{child}
	}
	return nil
}

func (c ViewNode) OneRetType() *ViewRetTypeNode {
	if child := ast.First(c.Node, "retType"); child != nil {
		return &ViewRetTypeNode{child}
	}
	return nil
}

func (c ViewNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

func (c ViewNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

func (c ViewNode) OneViewParams() *ViewParamsNode {
	if child := ast.First(c.Node, "view_params"); child != nil {
		return &ViewParamsNode{child}
	}
	return nil
}

type ViewParamsNode struct{ ast.Node }

func (ViewParamsNode) isWalkableType() {}
func (c ViewParamsNode) Choice() int   { return ast.Choice(c.Node) }

func (c ViewParamsNode) AllCollectionType() []CollectionTypeNode {
	var out []CollectionTypeNode
	for _, child := range ast.All(c.Node, "collection_type") {
		out = append(out, CollectionTypeNode{child})
	}
	return out
}

func (c ViewParamsNode) AllName() []NameNode {
	var out []NameNode
	for _, child := range ast.All(c.Node, "NAME") {
		out = append(out, NameNode{child})
	}
	return out
}

func (c ViewParamsNode) AllToken() []string {
	var out []string
	for _, child := range ast.All(c.Node, "") {
		out = append(out, child.Scanner().String())
	}
	return out
}

func (c ViewParamsNode) AllTypeSpec() []TypeSpecNode {
	var out []TypeSpecNode
	for _, child := range ast.All(c.Node, "type_spec") {
		out = append(out, TypeSpecNode{child})
	}
	return out
}

type ViewRetTypeNode struct{ ast.Node }

func (ViewRetTypeNode) isWalkableType() {}
func (c ViewRetTypeNode) Choice() int   { return ast.Choice(c.Node) }

func (c ViewRetTypeNode) OneCollectionType() *CollectionTypeNode {
	if child := ast.First(c.Node, "collection_type"); child != nil {
		return &CollectionTypeNode{child}
	}
	return nil
}

func (c ViewRetTypeNode) OneTypeSpec() *TypeSpecNode {
	if child := ast.First(c.Node, "type_spec"); child != nil {
		return &TypeSpecNode{child}
	}
	return nil
}

type WrapReNode struct{ ast.Node }

func (WrapReNode) isWalkableType() {}
func (c WrapReNode) Choice() int   { return ast.Choice(c.Node) }

func (c WrapReNode) OneToken() string {
	if child := ast.First(c.Node, ""); child != nil {
		return child.Scanner().String()
	}
	return ""
}

type WalkerOps struct {
	EnterAggFuncFuncNode                    func(AggFuncFuncNode) Stopper
	ExitAggFuncFuncNode                     func(AggFuncFuncNode) Stopper
	EnterAggFuncNode                        func(AggFuncNode) Stopper
	ExitAggFuncNode                         func(AggFuncNode) Stopper
	EnterAggFuncScopevarNode                func(AggFuncScopevarNode) Stopper
	ExitAggFuncScopevarNode                 func(AggFuncScopevarNode) Stopper
	EnterAliasIndentSepNode                 func(AliasIndentSepNode) Stopper
	ExitAliasIndentSepNode                  func(AliasIndentSepNode) Stopper
	EnterAliasLineNode                      func(AliasLineNode) Stopper
	ExitAliasLineNode                       func(AliasLineNode) Stopper
	EnterAliasNode                          func(AliasNode) Stopper
	ExitAliasNode                           func(AliasNode) Stopper
	EnterAnnotationNode                     func(AnnotationNode) Stopper
	ExitAnnotationNode                      func(AnnotationNode) Stopper
	EnterAnnotationValueNode                func(AnnotationValueNode) Stopper
	ExitAnnotationValueNode                 func(AnnotationValueNode) Stopper
	EnterAnnotationsIndentSepNode           func(AnnotationsIndentSepNode) Stopper
	ExitAnnotationsIndentSepNode            func(AnnotationsIndentSepNode) Stopper
	EnterAnnotationsNode                    func(AnnotationsNode) Stopper
	ExitAnnotationsNode                     func(AnnotationsNode) Stopper
	EnterAnyFuncNode                        func(AnyFuncNode) Stopper
	ExitAnyFuncNode                         func(AnyFuncNode) Stopper
	EnterAppDeclNode                        func(AppDeclNode) Stopper
	ExitAppDeclNode                         func(AppDeclNode) Stopper
	EnterApplicationIndentSepNode           func(ApplicationIndentSepNode) Stopper
	ExitApplicationIndentSepNode            func(ApplicationIndentSepNode) Stopper
	EnterApplicationNode                    func(ApplicationNode) Stopper
	ExitApplicationNode                     func(ApplicationNode) Stopper
	EnterAppnameNode                        func(AppnameNode) Stopper
	ExitAppnameNode                         func(AppnameNode) Stopper
	EnterAppnamePartNode                    func(AppnamePartNode) Stopper
	ExitAppnamePartNode                     func(AppnamePartNode) Stopper
	EnterArrayOfArrayNode                   func(ArrayOfArrayNode) Stopper
	ExitArrayOfArrayNode                    func(ArrayOfArrayNode) Stopper
	EnterArrayOfStringsNode                 func(ArrayOfStringsNode) Stopper
	ExitArrayOfStringsNode                  func(ArrayOfStringsNode) Stopper
	EnterArraySizeMinNode                   func(ArraySizeMinNode) Stopper
	ExitArraySizeMinNode                    func(ArraySizeMinNode) Stopper
	EnterArraySizeNode                      func(ArraySizeNode) Stopper
	ExitArraySizeNode                       func(ArraySizeNode) Stopper
	EnterAtomAtomsNode                      func(AtomAtomsNode) Stopper
	ExitAtomAtomsNode                       func(AtomAtomsNode) Stopper
	EnterAtomDotRelopNode                   func(AtomDotRelopNode) Stopper
	ExitAtomDotRelopNode                    func(AtomDotRelopNode) Stopper
	EnterAtomIdentNode                      func(AtomIdentNode) Stopper
	ExitAtomIdentNode                       func(AtomIdentNode) Stopper
	EnterAtomImpliedDotNode                 func(AtomImpliedDotNode) Stopper
	ExitAtomImpliedDotNode                  func(AtomImpliedDotNode) Stopper
	EnterAtomLiteralLiteralNode             func(AtomLiteralLiteralNode) Stopper
	ExitAtomLiteralLiteralNode              func(AtomLiteralLiteralNode) Stopper
	EnterAtomLiteralNode                    func(AtomLiteralNode) Stopper
	ExitAtomLiteralNode                     func(AtomLiteralNode) Stopper
	EnterAtomLiteralQuoteNode               func(AtomLiteralQuoteNode) Stopper
	ExitAtomLiteralQuoteNode                func(AtomLiteralQuoteNode) Stopper
	EnterAtomNode                           func(AtomNode) Stopper
	ExitAtomNode                            func(AtomNode) Stopper
	EnterAtomSetNode                        func(AtomSetNode) Stopper
	ExitAtomSetNode                         func(AtomSetNode) Stopper
	EnterAttribsAttrNode                    func(AttribsAttrNode) Stopper
	ExitAttribsAttrNode                     func(AttribsAttrNode) Stopper
	EnterAttribsNode                        func(AttribsNode) Stopper
	ExitAttribsNode                         func(AttribsNode) Stopper
	EnterAttribsPatternNode                 func(AttribsPatternNode) Stopper
	ExitAttribsPatternNode                  func(AttribsPatternNode) Stopper
	EnterCallArgsArgNode                    func(CallArgsArgNode) Stopper
	ExitCallArgsArgNode                     func(CallArgsArgNode) Stopper
	EnterCallArgsNode                       func(CallArgsNode) Stopper
	ExitCallArgsNode                        func(CallArgsNode) Stopper
	EnterCallStmtNode                       func(CallStmtNode) Stopper
	ExitCallStmtNode                        func(CallStmtNode) Stopper
	EnterCallStmtTargetNode                 func(CallStmtTargetNode) Stopper
	ExitCallStmtTargetNode                  func(CallStmtTargetNode) Stopper
	EnterCollectionTypeNode                 func(CollectionTypeNode) Stopper
	ExitCollectionTypeNode                  func(CollectionTypeNode) Stopper
	EnterCollectorCallStmtNode              func(CollectorCallStmtNode) Stopper
	ExitCollectorCallStmtNode               func(CollectorCallStmtNode) Stopper
	EnterCollectorHttpStmtNode              func(CollectorHttpStmtNode) Stopper
	ExitCollectorHttpStmtNode               func(CollectorHttpStmtNode) Stopper
	EnterCollectorHttpStmtTypeNode          func(CollectorHttpStmtTypeNode) Stopper
	ExitCollectorHttpStmtTypeNode           func(CollectorHttpStmtTypeNode) Stopper
	EnterCollectorIndentSepNode             func(CollectorIndentSepNode) Stopper
	ExitCollectorIndentSepNode              func(CollectorIndentSepNode) Stopper
	EnterCollectorNode                      func(CollectorNode) Stopper
	ExitCollectorNode                       func(CollectorNode) Stopper
	EnterCollectorPubsubCallNode            func(CollectorPubsubCallNode) Stopper
	ExitCollectorPubsubCallNode             func(CollectorPubsubCallNode) Stopper
	EnterCollectorStmtNode                  func(CollectorStmtNode) Stopper
	ExitCollectorStmtNode                   func(CollectorStmtNode) Stopper
	EnterCommentNoNlNode                    func(CommentNoNlNode) Stopper
	ExitCommentNoNlNode                     func(CommentNoNlNode) Stopper
	EnterCommentNode                        func(CommentNode) Stopper
	ExitCommentNode                         func(CommentNode) Stopper
	EnterCountNode                          func(CountNode) Stopper
	ExitCountNode                           func(CountNode) Stopper
	EnterDigitsNode                         func(DigitsNode) Stopper
	ExitDigitsNode                          func(DigitsNode) Stopper
	EnterElseStmtIndentSepNode              func(ElseStmtIndentSepNode) Stopper
	ExitElseStmtIndentSepNode               func(ElseStmtIndentSepNode) Stopper
	EnterElseStmtNode                       func(ElseStmtNode) Stopper
	ExitElseStmtNode                        func(ElseStmtNode) Stopper
	EnterEndpointNode                       func(EndpointNode) Stopper
	ExitEndpointNode                        func(EndpointNode) Stopper
	EnterEnumEnumerationNode                func(EnumEnumerationNode) Stopper
	ExitEnumEnumerationNode                 func(EnumEnumerationNode) Stopper
	EnterEnumIndentSepNode                  func(EnumIndentSepNode) Stopper
	ExitEnumIndentSepNode                   func(EnumIndentSepNode) Stopper
	EnterEnumNode                           func(EnumNode) Stopper
	ExitEnumNode                            func(EnumNode) Stopper
	EnterEolNode                            func(EolNode) Stopper
	ExitEolNode                             func(EolNode) Stopper
	EnterEventIndentSepNode                 func(EventIndentSepNode) Stopper
	ExitEventIndentSepNode                  func(EventIndentSepNode) Stopper
	EnterEventNode                          func(EventNode) Stopper
	ExitEventNode                           func(EventNode) Stopper
	EnterExprBlockIndentSepNode             func(ExprBlockIndentSepNode) Stopper
	ExitExprBlockIndentSepNode              func(ExprBlockIndentSepNode) Stopper
	EnterExprBlockNode                      func(ExprBlockNode) Stopper
	ExitExprBlockNode                       func(ExprBlockNode) Stopper
	EnterExprFuncArgsNode                   func(ExprFuncArgsNode) Stopper
	ExitExprFuncArgsNode                    func(ExprFuncArgsNode) Stopper
	EnterExprFuncFuncNode                   func(ExprFuncFuncNode) Stopper
	ExitExprFuncFuncNode                    func(ExprFuncFuncNode) Stopper
	EnterExprFuncNode                       func(ExprFuncNode) Stopper
	ExitExprFuncNode                        func(ExprFuncNode) Stopper
	EnterExprIfElseNode                     func(ExprIfElseNode) Stopper
	ExitExprIfElseNode                      func(ExprIfElseNode) Stopper
	EnterExprNode                           func(ExprNode) Stopper
	ExitExprNode                            func(ExprNode) Stopper
	EnterExprOpNode                         func(ExprOpNode) Stopper
	ExitExprOpNode                          func(ExprOpNode) Stopper
	EnterExprRetTypeCollectionNode          func(ExprRetTypeCollectionNode) Stopper
	ExitExprRetTypeCollectionNode           func(ExprRetTypeCollectionNode) Stopper
	EnterExprRetTypeNode                    func(ExprRetTypeNode) Stopper
	ExitExprRetTypeNode                     func(ExprRetTypeNode) Stopper
	EnterExprStmtExprAssignNode             func(ExprStmtExprAssignNode) Stopper
	ExitExprStmtExprAssignNode              func(ExprStmtExprAssignNode) Stopper
	EnterExprStmtExprDotAssignNode          func(ExprStmtExprDotAssignNode) Stopper
	ExitExprStmtExprDotAssignNode           func(ExprStmtExprDotAssignNode) Stopper
	EnterExprStmtExprTableAssignNode        func(ExprStmtExprTableAssignNode) Stopper
	ExitExprStmtExprTableAssignNode         func(ExprStmtExprTableAssignNode) Stopper
	EnterExprStmtNode                       func(ExprStmtNode) Stopper
	ExitExprStmtNode                        func(ExprStmtNode) Stopper
	EnterExprTableOfOpDotNode               func(ExprTableOfOpDotNode) Stopper
	ExitExprTableOfOpDotNode                func(ExprTableOfOpDotNode) Stopper
	EnterExprTableOfOpNode                  func(ExprTableOfOpNode) Stopper
	ExitExprTableOfOpNode                   func(ExprTableOfOpNode) Stopper
	EnterExprUnaryopNode                    func(ExprUnaryopNode) Stopper
	ExitExprUnaryopNode                     func(ExprUnaryopNode) Stopper
	EnterFacadeIndentSepNode                func(FacadeIndentSepNode) Stopper
	ExitFacadeIndentSepNode                 func(FacadeIndentSepNode) Stopper
	EnterFacadeInplaceTableDefIndentSepNode func(FacadeInplaceTableDefIndentSepNode) Stopper
	ExitFacadeInplaceTableDefIndentSepNode  func(FacadeInplaceTableDefIndentSepNode) Stopper
	EnterFacadeInplaceTableDefNode          func(FacadeInplaceTableDefNode) Stopper
	ExitFacadeInplaceTableDefNode           func(FacadeInplaceTableDefNode) Stopper
	EnterFacadeNode                         func(FacadeNode) Stopper
	ExitFacadeNode                          func(FacadeNode) Stopper
	EnterFieldIndentSepNode                 func(FieldIndentSepNode) Stopper
	ExitFieldIndentSepNode                  func(FieldIndentSepNode) Stopper
	EnterFieldNode                          func(FieldNode) Stopper
	ExitFieldNode                           func(FieldNode) Stopper
	EnterFieldTypeNode                      func(FieldTypeNode) Stopper
	ExitFieldTypeNode                       func(FieldTypeNode) Stopper
	EnterFirstFuncNode                      func(FirstFuncNode) Stopper
	ExitFirstFuncNode                       func(FirstFuncNode) Stopper
	EnterFirstFuncScopevarNode              func(FirstFuncScopevarNode) Stopper
	ExitFirstFuncScopevarNode               func(FirstFuncScopevarNode) Stopper
	EnterFirstFuncTargetNode                func(FirstFuncTargetNode) Stopper
	ExitFirstFuncTargetNode                 func(FirstFuncTargetNode) Stopper
	EnterForStmtForTypeNode                 func(ForStmtForTypeNode) Stopper
	ExitForStmtForTypeNode                  func(ForStmtForTypeNode) Stopper
	EnterForStmtIndentSepNode               func(ForStmtIndentSepNode) Stopper
	ExitForStmtIndentSepNode                func(ForStmtIndentSepNode) Stopper
	EnterForStmtNode                        func(ForStmtNode) Stopper
	ExitForStmtNode                         func(ForStmtNode) Stopper
	EnterGroupStmtIndentSepNode             func(GroupStmtIndentSepNode) Stopper
	ExitGroupStmtIndentSepNode              func(GroupStmtIndentSepNode) Stopper
	EnterGroupStmtNode                      func(GroupStmtNode) Stopper
	ExitGroupStmtNode                       func(GroupStmtNode) Stopper
	EnterHttpPathNode                       func(HttpPathNode) Stopper
	ExitHttpPathNode                        func(HttpPathNode) Stopper
	EnterHttpPathPartNode                   func(HttpPathPartNode) Stopper
	ExitHttpPathPartNode                    func(HttpPathPartNode) Stopper
	EnterHttpPathPartWrapReNode             func(HttpPathPartWrapReNode) Stopper
	ExitHttpPathPartWrapReNode              func(HttpPathPartWrapReNode) Stopper
	EnterHttpPathVarWithTypeNode            func(HttpPathVarWithTypeNode) Stopper
	ExitHttpPathVarWithTypeNode             func(HttpPathVarWithTypeNode) Stopper
	EnterHttpPathVarWithTypeTypeNode        func(HttpPathVarWithTypeTypeNode) Stopper
	ExitHttpPathVarWithTypeTypeNode         func(HttpPathVarWithTypeTypeNode) Stopper
	EnterHttpPathVarWithTypeVarNode         func(HttpPathVarWithTypeVarNode) Stopper
	ExitHttpPathVarWithTypeVarNode          func(HttpPathVarWithTypeVarNode) Stopper
	EnterHttpVerbsNode                      func(HttpVerbsNode) Stopper
	ExitHttpVerbsNode                       func(HttpVerbsNode) Stopper
	EnterIfElseNode                         func(IfElseNode) Stopper
	ExitIfElseNode                          func(IfElseNode) Stopper
	EnterIfStmtIndentSepNode                func(IfStmtIndentSepNode) Stopper
	ExitIfStmtIndentSepNode                 func(IfStmtIndentSepNode) Stopper
	EnterIfStmtNode                         func(IfStmtNode) Stopper
	ExitIfStmtNode                          func(IfStmtNode) Stopper
	EnterImportNode                         func(ImportNode) Stopper
	ExitImportNode                          func(ImportNode) Stopper
	EnterImportPrefixNode                   func(ImportPrefixNode) Stopper
	ExitImportPrefixNode                    func(ImportPrefixNode) Stopper
	EnterIndentNode                         func(IndentNode) Stopper
	ExitIndentNode                          func(IndentNode) Stopper
	EnterIndentSepNode                      func(IndentSepNode) Stopper
	ExitIndentSepNode                       func(IndentSepNode) Stopper
	EnterMatchingNode                       func(MatchingNode) Stopper
	ExitMatchingNode                        func(MatchingNode) Stopper
	EnterMatchingRhsNode                    func(MatchingRhsNode) Stopper
	ExitMatchingRhsNode                     func(MatchingRhsNode) Stopper
	EnterMatchingSquigglyArgsNode           func(MatchingSquigglyArgsNode) Stopper
	ExitMatchingSquigglyArgsNode            func(MatchingSquigglyArgsNode) Stopper
	EnterMethodDefIndentSepNode             func(MethodDefIndentSepNode) Stopper
	ExitMethodDefIndentSepNode              func(MethodDefIndentSepNode) Stopper
	EnterMethodDefNode                      func(MethodDefNode) Stopper
	ExitMethodDefNode                       func(MethodDefNode) Stopper
	EnterMultiLineDocstringIndentSepNode    func(MultiLineDocstringIndentSepNode) Stopper
	ExitMultiLineDocstringIndentSepNode     func(MultiLineDocstringIndentSepNode) Stopper
	EnterMultiLineDocstringNode             func(MultiLineDocstringNode) Stopper
	ExitMultiLineDocstringNode              func(MultiLineDocstringNode) Stopper
	EnterNameNode                           func(NameNode) Stopper
	ExitNameNode                            func(NameNode) Stopper
	EnterNativeDataTypesNode                func(NativeDataTypesNode) Stopper
	ExitNativeDataTypesNode                 func(NativeDataTypesNode) Stopper
	EnterNavigateAttrNode                   func(NavigateAttrNode) Stopper
	ExitNavigateAttrNode                    func(NavigateAttrNode) Stopper
	EnterNavigateNode                       func(NavigateNode) Stopper
	ExitNavigateNode                        func(NavigateNode) Stopper
	EnterOneOfCasesIndentSepNode            func(OneOfCasesIndentSepNode) Stopper
	ExitOneOfCasesIndentSepNode             func(OneOfCasesIndentSepNode) Stopper
	EnterOneOfCasesNode                     func(OneOfCasesNode) Stopper
	ExitOneOfCasesNode                      func(OneOfCasesNode) Stopper
	EnterOneOfCasesOneOfCaseLabelNode       func(OneOfCasesOneOfCaseLabelNode) Stopper
	ExitOneOfCasesOneOfCaseLabelNode        func(OneOfCasesOneOfCaseLabelNode) Stopper
	EnterOneOfStmtIndentSepNode             func(OneOfStmtIndentSepNode) Stopper
	ExitOneOfStmtIndentSepNode              func(OneOfStmtIndentSepNode) Stopper
	EnterOneOfStmtNode                      func(OneOfStmtNode) Stopper
	ExitOneOfStmtNode                       func(OneOfStmtNode) Stopper
	EnterParamsNode                         func(ParamsNode) Stopper
	ExitParamsNode                          func(ParamsNode) Stopper
	EnterPathNode                           func(PathNode) Stopper
	ExitPathNode                            func(PathNode) Stopper
	EnterPredicateNode                      func(PredicateNode) Stopper
	ExitPredicateNode                       func(PredicateNode) Stopper
	EnterQstringNode                        func(QstringNode) Stopper
	ExitQstringNode                         func(QstringNode) Stopper
	EnterQueryParamNode                     func(QueryParamNode) Stopper
	ExitQueryParamNode                      func(QueryParamNode) Stopper
	EnterRankExprFuncNode                   func(RankExprFuncNode) Stopper
	ExitRankExprFuncNode                    func(RankExprFuncNode) Stopper
	EnterRankExprNode                       func(RankExprNode) Stopper
	ExitRankExprNode                        func(RankExprNode) Stopper
	EnterRankFuncNode                       func(RankFuncNode) Stopper
	ExitRankFuncNode                        func(RankFuncNode) Stopper
	EnterReferenceNode                      func(ReferenceNode) Stopper
	ExitReferenceNode                       func(ReferenceNode) Stopper
	EnterReferencePkgNode                   func(ReferencePkgNode) Stopper
	ExitReferencePkgNode                    func(ReferencePkgNode) Stopper
	EnterRelopNode                          func(RelopNode) Stopper
	ExitRelopNode                           func(RelopNode) Stopper
	EnterRestEndpointIndentSepNode          func(RestEndpointIndentSepNode) Stopper
	ExitRestEndpointIndentSepNode           func(RestEndpointIndentSepNode) Stopper
	EnterRestEndpointNode                   func(RestEndpointNode) Stopper
	ExitRestEndpointNode                    func(RestEndpointNode) Stopper
	EnterRetStmtNode                        func(RetStmtNode) Stopper
	ExitRetStmtNode                         func(RetStmtNode) Stopper
	EnterShortcutNode                       func(ShortcutNode) Stopper
	ExitShortcutNode                        func(ShortcutNode) Stopper
	EnterSimpleEndpointIndentSepNode        func(SimpleEndpointIndentSepNode) Stopper
	ExitSimpleEndpointIndentSepNode         func(SimpleEndpointIndentSepNode) Stopper
	EnterSimpleEndpointNode                 func(SimpleEndpointNode) Stopper
	ExitSimpleEndpointNode                  func(SimpleEndpointNode) Stopper
	EnterSingleArgFuncFuncNode              func(SingleArgFuncFuncNode) Stopper
	ExitSingleArgFuncFuncNode               func(SingleArgFuncFuncNode) Stopper
	EnterSingleArgFuncNode                  func(SingleArgFuncNode) Stopper
	ExitSingleArgFuncNode                   func(SingleArgFuncNode) Stopper
	EnterSingleArgFuncScopevarNode          func(SingleArgFuncScopevarNode) Stopper
	ExitSingleArgFuncScopevarNode           func(SingleArgFuncScopevarNode) Stopper
	EnterSingleOrNullNode                   func(SingleOrNullNode) Stopper
	ExitSingleOrNullNode                    func(SingleOrNullNode) Stopper
	EnterSnapshotNode                       func(SnapshotNode) Stopper
	ExitSnapshotNode                        func(SnapshotNode) Stopper
	EnterStmtNode                           func(StmtNode) Stopper
	ExitStmtNode                            func(StmtNode) Stopper
	EnterSubscribeIndentSepNode             func(SubscribeIndentSepNode) Stopper
	ExitSubscribeIndentSepNode              func(SubscribeIndentSepNode) Stopper
	EnterSubscribeNode                      func(SubscribeNode) Stopper
	ExitSubscribeNode                       func(SubscribeNode) Stopper
	EnterSyslFileNode                       func(SyslFileNode) Stopper
	ExitSyslFileNode                        func(SyslFileNode) Stopper
	EnterTableIndentSepNode                 func(TableIndentSepNode) Stopper
	ExitTableIndentSepNode                  func(TableIndentSepNode) Stopper
	EnterTableModeNode                      func(TableModeNode) Stopper
	ExitTableModeNode                       func(TableModeNode) Stopper
	EnterTableNode                          func(TableNode) Stopper
	ExitTableNode                           func(TableNode) Stopper
	EnterTableTableRowNode                  func(TableTableRowNode) Stopper
	ExitTableTableRowNode                   func(TableTableRowNode) Stopper
	EnterTableTableRowTypeNode              func(TableTableRowTypeNode) Stopper
	ExitTableTableRowTypeNode               func(TableTableRowTypeNode) Stopper
	EnterTextLineNode                       func(TextLineNode) Stopper
	ExitTextLineNode                        func(TextLineNode) Stopper
	EnterTextNode                           func(TextNode) Stopper
	ExitTextNode                            func(TextNode) Stopper
	EnterTextStmtDocStringNode              func(TextStmtDocStringNode) Stopper
	ExitTextStmtDocStringNode               func(TextStmtDocStringNode) Stopper
	EnterTextStmtNode                       func(TextStmtNode) Stopper
	ExitTextStmtNode                        func(TextStmtNode) Stopper
	EnterTypeDeclNode                       func(TypeDeclNode) Stopper
	ExitTypeDeclNode                        func(TypeDeclNode) Stopper
	EnterTypeSpecNode                       func(TypeSpecNode) Stopper
	ExitTypeSpecNode                        func(TypeSpecNode) Stopper
	EnterTypeSpecSizeSpecNode               func(TypeSpecSizeSpecNode) Stopper
	ExitTypeSpecSizeSpecNode                func(TypeSpecSizeSpecNode) Stopper
	EnterUnionIndentSepNode                 func(UnionIndentSepNode) Stopper
	ExitUnionIndentSepNode                  func(UnionIndentSepNode) Stopper
	EnterUnionNode                          func(UnionNode) Stopper
	ExitUnionNode                           func(UnionNode) Stopper
	EnterViewIndentSepNode                  func(ViewIndentSepNode) Stopper
	ExitViewIndentSepNode                   func(ViewIndentSepNode) Stopper
	EnterViewNode                           func(ViewNode) Stopper
	ExitViewNode                            func(ViewNode) Stopper
	EnterViewParamsNode                     func(ViewParamsNode) Stopper
	ExitViewParamsNode                      func(ViewParamsNode) Stopper
	EnterViewRetTypeNode                    func(ViewRetTypeNode) Stopper
	ExitViewRetTypeNode                     func(ViewRetTypeNode) Stopper
	EnterWrapReNode                         func(WrapReNode) Stopper
	ExitWrapReNode                          func(WrapReNode) Stopper
}

func (w WalkerOps) Walk(tree IsWalkableType) Stopper {
	switch node := tree.(type) {
	case AggFuncFuncNode:
		return w.WalkAggFuncFuncNode(node)

	case AggFuncNode:
		return w.WalkAggFuncNode(node)

	case AggFuncScopevarNode:
		return w.WalkAggFuncScopevarNode(node)

	case AliasIndentSepNode:
		return w.WalkAliasIndentSepNode(node)

	case AliasLineNode:
		return w.WalkAliasLineNode(node)

	case AliasNode:
		return w.WalkAliasNode(node)

	case AnnotationNode:
		return w.WalkAnnotationNode(node)

	case AnnotationValueNode:
		return w.WalkAnnotationValueNode(node)

	case AnnotationsIndentSepNode:
		return w.WalkAnnotationsIndentSepNode(node)

	case AnnotationsNode:
		return w.WalkAnnotationsNode(node)

	case AnyFuncNode:
		return w.WalkAnyFuncNode(node)

	case AppDeclNode:
		return w.WalkAppDeclNode(node)

	case ApplicationIndentSepNode:
		return w.WalkApplicationIndentSepNode(node)

	case ApplicationNode:
		return w.WalkApplicationNode(node)

	case AppnameNode:
		return w.WalkAppnameNode(node)

	case AppnamePartNode:
		return w.WalkAppnamePartNode(node)

	case ArrayOfArrayNode:
		return w.WalkArrayOfArrayNode(node)

	case ArrayOfStringsNode:
		return w.WalkArrayOfStringsNode(node)

	case ArraySizeMinNode:
		return w.WalkArraySizeMinNode(node)

	case ArraySizeNode:
		return w.WalkArraySizeNode(node)

	case AtomAtomsNode:
		return w.WalkAtomAtomsNode(node)

	case AtomDotRelopNode:
		return w.WalkAtomDotRelopNode(node)

	case AtomIdentNode:
		return w.WalkAtomIdentNode(node)

	case AtomImpliedDotNode:
		return w.WalkAtomImpliedDotNode(node)

	case AtomLiteralLiteralNode:
		return w.WalkAtomLiteralLiteralNode(node)

	case AtomLiteralNode:
		return w.WalkAtomLiteralNode(node)

	case AtomLiteralQuoteNode:
		return w.WalkAtomLiteralQuoteNode(node)

	case AtomNode:
		return w.WalkAtomNode(node)

	case AtomSetNode:
		return w.WalkAtomSetNode(node)

	case AttribsAttrNode:
		return w.WalkAttribsAttrNode(node)

	case AttribsNode:
		return w.WalkAttribsNode(node)

	case AttribsPatternNode:
		return w.WalkAttribsPatternNode(node)

	case CallArgsArgNode:
		return w.WalkCallArgsArgNode(node)

	case CallArgsNode:
		return w.WalkCallArgsNode(node)

	case CallStmtNode:
		return w.WalkCallStmtNode(node)

	case CallStmtTargetNode:
		return w.WalkCallStmtTargetNode(node)

	case CollectionTypeNode:
		return w.WalkCollectionTypeNode(node)

	case CollectorCallStmtNode:
		return w.WalkCollectorCallStmtNode(node)

	case CollectorHttpStmtNode:
		return w.WalkCollectorHttpStmtNode(node)

	case CollectorHttpStmtTypeNode:
		return w.WalkCollectorHttpStmtTypeNode(node)

	case CollectorIndentSepNode:
		return w.WalkCollectorIndentSepNode(node)

	case CollectorNode:
		return w.WalkCollectorNode(node)

	case CollectorPubsubCallNode:
		return w.WalkCollectorPubsubCallNode(node)

	case CollectorStmtNode:
		return w.WalkCollectorStmtNode(node)

	case CommentNoNlNode:
		return w.WalkCommentNoNlNode(node)

	case CommentNode:
		return w.WalkCommentNode(node)

	case CountNode:
		if fn := w.EnterCountNode; fn != nil {
			return fn(node)
		}

	case DigitsNode:
		if fn := w.EnterDigitsNode; fn != nil {
			return fn(node)
		}

	case ElseStmtIndentSepNode:
		return w.WalkElseStmtIndentSepNode(node)

	case ElseStmtNode:
		return w.WalkElseStmtNode(node)

	case EndpointNode:
		return w.WalkEndpointNode(node)

	case EnumEnumerationNode:
		return w.WalkEnumEnumerationNode(node)

	case EnumIndentSepNode:
		return w.WalkEnumIndentSepNode(node)

	case EnumNode:
		return w.WalkEnumNode(node)

	case EolNode:
		return w.WalkEolNode(node)

	case EventIndentSepNode:
		return w.WalkEventIndentSepNode(node)

	case EventNode:
		return w.WalkEventNode(node)

	case ExprBlockIndentSepNode:
		return w.WalkExprBlockIndentSepNode(node)

	case ExprBlockNode:
		return w.WalkExprBlockNode(node)

	case ExprFuncArgsNode:
		return w.WalkExprFuncArgsNode(node)

	case ExprFuncFuncNode:
		return w.WalkExprFuncFuncNode(node)

	case ExprFuncNode:
		return w.WalkExprFuncNode(node)

	case ExprIfElseNode:
		return w.WalkExprIfElseNode(node)

	case ExprNode:
		return w.WalkExprNode(node)

	case ExprOpNode:
		return w.WalkExprOpNode(node)

	case ExprRetTypeCollectionNode:
		return w.WalkExprRetTypeCollectionNode(node)

	case ExprRetTypeNode:
		return w.WalkExprRetTypeNode(node)

	case ExprStmtExprAssignNode:
		return w.WalkExprStmtExprAssignNode(node)

	case ExprStmtExprDotAssignNode:
		return w.WalkExprStmtExprDotAssignNode(node)

	case ExprStmtExprTableAssignNode:
		return w.WalkExprStmtExprTableAssignNode(node)

	case ExprStmtNode:
		return w.WalkExprStmtNode(node)

	case ExprTableOfOpDotNode:
		return w.WalkExprTableOfOpDotNode(node)

	case ExprTableOfOpNode:
		return w.WalkExprTableOfOpNode(node)

	case ExprUnaryopNode:
		return w.WalkExprUnaryopNode(node)

	case FacadeIndentSepNode:
		return w.WalkFacadeIndentSepNode(node)

	case FacadeInplaceTableDefIndentSepNode:
		return w.WalkFacadeInplaceTableDefIndentSepNode(node)

	case FacadeInplaceTableDefNode:
		return w.WalkFacadeInplaceTableDefNode(node)

	case FacadeNode:
		return w.WalkFacadeNode(node)

	case FieldIndentSepNode:
		return w.WalkFieldIndentSepNode(node)

	case FieldNode:
		return w.WalkFieldNode(node)

	case FieldTypeNode:
		return w.WalkFieldTypeNode(node)

	case FirstFuncNode:
		return w.WalkFirstFuncNode(node)

	case FirstFuncScopevarNode:
		return w.WalkFirstFuncScopevarNode(node)

	case FirstFuncTargetNode:
		return w.WalkFirstFuncTargetNode(node)

	case ForStmtForTypeNode:
		return w.WalkForStmtForTypeNode(node)

	case ForStmtIndentSepNode:
		return w.WalkForStmtIndentSepNode(node)

	case ForStmtNode:
		return w.WalkForStmtNode(node)

	case GroupStmtIndentSepNode:
		return w.WalkGroupStmtIndentSepNode(node)

	case GroupStmtNode:
		return w.WalkGroupStmtNode(node)

	case HttpPathNode:
		return w.WalkHttpPathNode(node)

	case HttpPathPartNode:
		return w.WalkHttpPathPartNode(node)

	case HttpPathPartWrapReNode:
		if fn := w.EnterHttpPathPartWrapReNode; fn != nil {
			return fn(node)
		}

	case HttpPathVarWithTypeNode:
		return w.WalkHttpPathVarWithTypeNode(node)

	case HttpPathVarWithTypeTypeNode:
		return w.WalkHttpPathVarWithTypeTypeNode(node)

	case HttpPathVarWithTypeVarNode:
		return w.WalkHttpPathVarWithTypeVarNode(node)

	case HttpVerbsNode:
		return w.WalkHttpVerbsNode(node)

	case IfElseNode:
		return w.WalkIfElseNode(node)

	case IfStmtIndentSepNode:
		return w.WalkIfStmtIndentSepNode(node)

	case IfStmtNode:
		return w.WalkIfStmtNode(node)

	case ImportNode:
		return w.WalkImportNode(node)

	case ImportPrefixNode:
		return w.WalkImportPrefixNode(node)

	case IndentNode:
		return w.WalkIndentNode(node)

	case IndentSepNode:
		return w.WalkIndentSepNode(node)

	case MatchingNode:
		return w.WalkMatchingNode(node)

	case MatchingRhsNode:
		return w.WalkMatchingRhsNode(node)

	case MatchingSquigglyArgsNode:
		return w.WalkMatchingSquigglyArgsNode(node)

	case MethodDefIndentSepNode:
		return w.WalkMethodDefIndentSepNode(node)

	case MethodDefNode:
		return w.WalkMethodDefNode(node)

	case MultiLineDocstringIndentSepNode:
		return w.WalkMultiLineDocstringIndentSepNode(node)

	case MultiLineDocstringNode:
		return w.WalkMultiLineDocstringNode(node)

	case NameNode:
		if fn := w.EnterNameNode; fn != nil {
			return fn(node)
		}

	case NativeDataTypesNode:
		return w.WalkNativeDataTypesNode(node)

	case NavigateAttrNode:
		return w.WalkNavigateAttrNode(node)

	case NavigateNode:
		return w.WalkNavigateNode(node)

	case OneOfCasesIndentSepNode:
		return w.WalkOneOfCasesIndentSepNode(node)

	case OneOfCasesNode:
		return w.WalkOneOfCasesNode(node)

	case OneOfCasesOneOfCaseLabelNode:
		return w.WalkOneOfCasesOneOfCaseLabelNode(node)

	case OneOfStmtIndentSepNode:
		return w.WalkOneOfStmtIndentSepNode(node)

	case OneOfStmtNode:
		return w.WalkOneOfStmtNode(node)

	case ParamsNode:
		return w.WalkParamsNode(node)

	case PathNode:
		return w.WalkPathNode(node)

	case PredicateNode:
		if fn := w.EnterPredicateNode; fn != nil {
			return fn(node)
		}

	case QstringNode:
		if fn := w.EnterQstringNode; fn != nil {
			return fn(node)
		}

	case QueryParamNode:
		return w.WalkQueryParamNode(node)

	case RankExprFuncNode:
		return w.WalkRankExprFuncNode(node)

	case RankExprNode:
		return w.WalkRankExprNode(node)

	case RankFuncNode:
		return w.WalkRankFuncNode(node)

	case ReferenceNode:
		return w.WalkReferenceNode(node)

	case ReferencePkgNode:
		return w.WalkReferencePkgNode(node)

	case RelopNode:
		return w.WalkRelopNode(node)

	case RestEndpointIndentSepNode:
		return w.WalkRestEndpointIndentSepNode(node)

	case RestEndpointNode:
		return w.WalkRestEndpointNode(node)

	case RetStmtNode:
		return w.WalkRetStmtNode(node)

	case ShortcutNode:
		if fn := w.EnterShortcutNode; fn != nil {
			return fn(node)
		}

	case SimpleEndpointIndentSepNode:
		return w.WalkSimpleEndpointIndentSepNode(node)

	case SimpleEndpointNode:
		return w.WalkSimpleEndpointNode(node)

	case SingleArgFuncFuncNode:
		return w.WalkSingleArgFuncFuncNode(node)

	case SingleArgFuncNode:
		return w.WalkSingleArgFuncNode(node)

	case SingleArgFuncScopevarNode:
		return w.WalkSingleArgFuncScopevarNode(node)

	case SingleOrNullNode:
		return w.WalkSingleOrNullNode(node)

	case SnapshotNode:
		if fn := w.EnterSnapshotNode; fn != nil {
			return fn(node)
		}

	case StmtNode:
		return w.WalkStmtNode(node)

	case SubscribeIndentSepNode:
		return w.WalkSubscribeIndentSepNode(node)

	case SubscribeNode:
		return w.WalkSubscribeNode(node)

	case SyslFileNode:
		return w.WalkSyslFileNode(node)

	case TableIndentSepNode:
		return w.WalkTableIndentSepNode(node)

	case TableModeNode:
		return w.WalkTableModeNode(node)

	case TableNode:
		return w.WalkTableNode(node)

	case TableTableRowNode:
		return w.WalkTableTableRowNode(node)

	case TableTableRowTypeNode:
		return w.WalkTableTableRowTypeNode(node)

	case TextLineNode:
		if fn := w.EnterTextLineNode; fn != nil {
			return fn(node)
		}

	case TextNode:
		if fn := w.EnterTextNode; fn != nil {
			return fn(node)
		}

	case TextStmtDocStringNode:
		return w.WalkTextStmtDocStringNode(node)

	case TextStmtNode:
		return w.WalkTextStmtNode(node)

	case TypeDeclNode:
		return w.WalkTypeDeclNode(node)

	case TypeSpecNode:
		return w.WalkTypeSpecNode(node)

	case TypeSpecSizeSpecNode:
		return w.WalkTypeSpecSizeSpecNode(node)

	case UnionIndentSepNode:
		return w.WalkUnionIndentSepNode(node)

	case UnionNode:
		return w.WalkUnionNode(node)

	case ViewIndentSepNode:
		return w.WalkViewIndentSepNode(node)

	case ViewNode:
		return w.WalkViewNode(node)

	case ViewParamsNode:
		return w.WalkViewParamsNode(node)

	case ViewRetTypeNode:
		return w.WalkViewRetTypeNode(node)

	case WrapReNode:
		return w.WalkWrapReNode(node)

	}
	return nil
}
func (w WalkerOps) WalkAggFuncFuncNode(node AggFuncFuncNode) Stopper {
	if fn := w.EnterAggFuncFuncNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitAggFuncFuncNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAggFuncNode(node AggFuncNode) Stopper {
	if fn := w.EnterAggFuncNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllArgs() {
		if s := w.WalkExprNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneFunc(); child != nil {
		child := *child
		if s := w.WalkAggFuncFuncNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneScopevar(); child != nil {
		child := *child
		if s := w.WalkAggFuncScopevarNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitAggFuncNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAggFuncScopevarNode(node AggFuncScopevarNode) Stopper {
	if fn := w.EnterAggFuncScopevarNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitAggFuncScopevarNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAliasIndentSepNode(node AliasIndentSepNode) Stopper {
	if fn := w.EnterAliasIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIndentSep() {
		if s := w.WalkIndentSepNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitAliasIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAliasLineNode(node AliasLineNode) Stopper {
	if fn := w.EnterAliasLineNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllAnnotation() {
		if s := w.WalkAnnotationNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneCollectionType(); child != nil {
		child := *child
		if s := w.WalkCollectionTypeNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneTypeSpec(); child != nil {
		child := *child
		if s := w.WalkTypeSpecNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitAliasLineNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAliasNode(node AliasNode) Stopper {
	if fn := w.EnterAliasNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllAliasLine() {
		if s := w.WalkAliasLineNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAttribs(); child != nil {
		child := *child
		if s := w.WalkAttribsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllComment() {
		if s := w.WalkCommentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLevel(); child != nil {
		child := *child
		if s := w.WalkIndentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitAliasNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAnnotationNode(node AnnotationNode) Stopper {
	if fn := w.EnterAnnotationNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneValue(); child != nil {
		child := *child
		if s := w.WalkAnnotationValueNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneVarName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitAnnotationNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAnnotationValueNode(node AnnotationValueNode) Stopper {
	if fn := w.EnterAnnotationValueNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneArrayOfStrings(); child != nil {
		child := *child
		if s := w.WalkArrayOfStringsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneMultiLineDocstring(); child != nil {
		child := *child
		if s := w.WalkMultiLineDocstringNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneQstring(); child != nil {
		child := *child
		if fn := w.EnterQstringNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitAnnotationValueNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAnnotationsIndentSepNode(node AnnotationsIndentSepNode) Stopper {
	if fn := w.EnterAnnotationsIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIndentSep() {
		if s := w.WalkIndentSepNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitAnnotationsIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAnnotationsNode(node AnnotationsNode) Stopper {
	if fn := w.EnterAnnotationsNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllAnnotation() {
		if s := w.WalkAnnotationNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLevel(); child != nil {
		child := *child
		if s := w.WalkIndentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitAnnotationsNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAnyFuncNode(node AnyFuncNode) Stopper {
	if fn := w.EnterAnyFuncNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneExpr(); child != nil {
		child := *child
		if s := w.WalkExprNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitAnyFuncNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAppDeclNode(node AppDeclNode) Stopper {
	if fn := w.EnterAppDeclNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAnnotation(); child != nil {
		child := *child
		if s := w.WalkAnnotationNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneCommentNoNl(); child != nil {
		child := *child
		if s := w.WalkCommentNoNlNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneEndpoint(); child != nil {
		child := *child
		if s := w.WalkEndpointNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneEvent(); child != nil {
		child := *child
		if s := w.WalkEventNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneShortcut(); child != nil {
		child := *child
		if fn := w.EnterShortcutNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneSubscribe(); child != nil {
		child := *child
		if s := w.WalkSubscribeNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneTypeDecl(); child != nil {
		child := *child
		if s := w.WalkTypeDeclNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneView(); child != nil {
		child := *child
		if s := w.WalkViewNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitAppDeclNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkApplicationIndentSepNode(node ApplicationIndentSepNode) Stopper {
	if fn := w.EnterApplicationIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIndentSep() {
		if s := w.WalkIndentSepNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitApplicationIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkApplicationNode(node ApplicationNode) Stopper {
	if fn := w.EnterApplicationNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAppname(); child != nil {
		child := *child
		if s := w.WalkAppnameNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllAppDecl() {
		if s := w.WalkAppDeclNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAttribs(); child != nil {
		child := *child
		if s := w.WalkAttribsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllComment() {
		if s := w.WalkCommentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneEol(); child != nil {
		child := *child
		if s := w.WalkEolNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLevel(); child != nil {
		child := *child
		if s := w.WalkIndentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneQstring(); child != nil {
		child := *child
		if fn := w.EnterQstringNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitApplicationNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAppnameNode(node AppnameNode) Stopper {
	if fn := w.EnterAppnameNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllApp() {
		if s := w.WalkAppnameNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllAppname() {
		if s := w.WalkAppnameNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAppnamePart(); child != nil {
		child := *child
		if s := w.WalkAppnamePartNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllPkg() {
		if s := w.WalkAppnameNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitAppnameNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAppnamePartNode(node AppnamePartNode) Stopper {
	if fn := w.EnterAppnamePartNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllQstring() {
		if fn := w.EnterQstringNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitAppnamePartNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkArrayOfArrayNode(node ArrayOfArrayNode) Stopper {
	if fn := w.EnterArrayOfArrayNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllArrayOfStrings() {
		if s := w.WalkArrayOfStringsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitArrayOfArrayNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkArrayOfStringsNode(node ArrayOfStringsNode) Stopper {
	if fn := w.EnterArrayOfStringsNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllQstring() {
		if fn := w.EnterQstringNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitArrayOfStringsNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkArraySizeMinNode(node ArraySizeMinNode) Stopper {
	if fn := w.EnterArraySizeMinNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneDigits(); child != nil {
		child := *child
		if fn := w.EnterDigitsNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitArraySizeMinNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkArraySizeNode(node ArraySizeNode) Stopper {
	if fn := w.EnterArraySizeNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneMax(); child != nil {
		child := *child
		if fn := w.EnterDigitsNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneMin(); child != nil {
		child := *child
		if s := w.WalkArraySizeMinNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitArraySizeNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAtomAtomsNode(node AtomAtomsNode) Stopper {
	if fn := w.EnterAtomAtomsNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllExpr() {
		if s := w.WalkExprNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitAtomAtomsNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAtomDotRelopNode(node AtomDotRelopNode) Stopper {
	if fn := w.EnterAtomDotRelopNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAggFunc(); child != nil {
		child := *child
		if s := w.WalkAggFuncNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAnyFunc(); child != nil {
		child := *child
		if s := w.WalkAnyFuncNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneCount(); child != nil {
		child := *child
		if fn := w.EnterCountNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneFirstFunc(); child != nil {
		child := *child
		if s := w.WalkFirstFuncNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneMatching(); child != nil {
		child := *child
		if s := w.WalkMatchingNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneNavigate(); child != nil {
		child := *child
		if s := w.WalkNavigateNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneRankFunc(); child != nil {
		child := *child
		if s := w.WalkRankFuncNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneSingleArgFunc(); child != nil {
		child := *child
		if s := w.WalkSingleArgFuncNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneSingleOrNull(); child != nil {
		child := *child
		if s := w.WalkSingleOrNullNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneSnapshot(); child != nil {
		child := *child
		if fn := w.EnterSnapshotNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitAtomDotRelopNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAtomIdentNode(node AtomIdentNode) Stopper {
	if fn := w.EnterAtomIdentNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneShortcut(); child != nil {
		child := *child
		if fn := w.EnterShortcutNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitAtomIdentNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAtomImpliedDotNode(node AtomImpliedDotNode) Stopper {
	if fn := w.EnterAtomImpliedDotNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAtomDotRelop(); child != nil {
		child := *child
		if s := w.WalkAtomDotRelopNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneExprTableOfOp(); child != nil {
		child := *child
		if s := w.WalkExprTableOfOpNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneMatching(); child != nil {
		child := *child
		if s := w.WalkMatchingNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneNavigate(); child != nil {
		child := *child
		if s := w.WalkNavigateNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitAtomImpliedDotNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAtomLiteralLiteralNode(node AtomLiteralLiteralNode) Stopper {
	if fn := w.EnterAtomLiteralLiteralNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitAtomLiteralLiteralNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAtomLiteralNode(node AtomLiteralNode) Stopper {
	if fn := w.EnterAtomLiteralNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLiteral(); child != nil {
		child := *child
		if s := w.WalkAtomLiteralLiteralNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneQuote(); child != nil {
		child := *child
		if s := w.WalkAtomLiteralQuoteNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitAtomLiteralNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAtomLiteralQuoteNode(node AtomLiteralQuoteNode) Stopper {
	if fn := w.EnterAtomLiteralQuoteNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitAtomLiteralQuoteNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAtomNode(node AtomNode) Stopper {
	if fn := w.EnterAtomNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAtoms(); child != nil {
		child := *child
		if s := w.WalkAtomAtomsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneExpr(); child != nil {
		child := *child
		if s := w.WalkExprNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneExprFunc(); child != nil {
		child := *child
		if s := w.WalkExprFuncNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneIdent(); child != nil {
		child := *child
		if s := w.WalkAtomIdentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneImpliedDot(); child != nil {
		child := *child
		if s := w.WalkAtomImpliedDotNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLiteral(); child != nil {
		child := *child
		if s := w.WalkAtomLiteralNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneSet(); child != nil {
		child := *child
		if s := w.WalkAtomSetNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitAtomNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAtomSetNode(node AtomSetNode) Stopper {
	if fn := w.EnterAtomSetNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllExpr() {
		if s := w.WalkExprNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitAtomSetNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAttribsAttrNode(node AttribsAttrNode) Stopper {
	if fn := w.EnterAttribsAttrNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneArrayOfArray(); child != nil {
		child := *child
		if s := w.WalkArrayOfArrayNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneArrayOfStrings(); child != nil {
		child := *child
		if s := w.WalkArrayOfStringsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneQstring(); child != nil {
		child := *child
		if fn := w.EnterQstringNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitAttribsAttrNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAttribsNode(node AttribsNode) Stopper {
	if fn := w.EnterAttribsNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAttr(); child != nil {
		child := *child
		if s := w.WalkAttribsAttrNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllAttribs() {
		if s := w.WalkAttribsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OnePattern(); child != nil {
		child := *child
		if s := w.WalkAttribsPatternNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitAttribsNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkAttribsPatternNode(node AttribsPatternNode) Stopper {
	if fn := w.EnterAttribsPatternNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllName() {
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitAttribsPatternNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkCallArgsArgNode(node CallArgsArgNode) Stopper {
	if fn := w.EnterCallArgsArgNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllName() {
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	for _, child := range node.AllQstring() {
		if fn := w.EnterQstringNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	for _, child := range node.AllTypeSpec() {
		if s := w.WalkTypeSpecNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitCallArgsArgNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkCallArgsNode(node CallArgsNode) Stopper {
	if fn := w.EnterCallArgsNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllArg() {
		if s := w.WalkCallArgsArgNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitCallArgsNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkCallStmtNode(node CallStmtNode) Stopper {
	if fn := w.EnterCallStmtNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneCallArgs(); child != nil {
		child := *child
		if s := w.WalkCallArgsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneTarget(); child != nil {
		child := *child
		if s := w.WalkCallStmtTargetNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneTargetEndpoint(); child != nil {
		child := *child
		if fn := w.EnterTextLineNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitCallStmtNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkCallStmtTargetNode(node CallStmtTargetNode) Stopper {
	if fn := w.EnterCallStmtTargetNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllName() {
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitCallStmtTargetNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkCollectionTypeNode(node CollectionTypeNode) Stopper {
	if fn := w.EnterCollectionTypeNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneTypeSpec(); child != nil {
		child := *child
		if s := w.WalkTypeSpecNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitCollectionTypeNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkCollectorCallStmtNode(node CollectorCallStmtNode) Stopper {
	if fn := w.EnterCollectorCallStmtNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneTarget(); child != nil {
		child := *child
		if s := w.WalkAppnameNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneTargetEndpoint(); child != nil {
		child := *child
		if s := w.WalkAppnamePartNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitCollectorCallStmtNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkCollectorHttpStmtNode(node CollectorHttpStmtNode) Stopper {
	if fn := w.EnterCollectorHttpStmtNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllHttpPathPart() {
		if s := w.WalkHttpPathPartNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneMethod(); child != nil {
		child := *child
		if s := w.WalkHttpVerbsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllParam() {
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	for _, child := range node.AllType() {
		if s := w.WalkCollectorHttpStmtTypeNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitCollectorHttpStmtNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkCollectorHttpStmtTypeNode(node CollectorHttpStmtTypeNode) Stopper {
	if fn := w.EnterCollectorHttpStmtTypeNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllName() {
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	for _, child := range node.AllNativeDataTypes() {
		if s := w.WalkNativeDataTypesNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitCollectorHttpStmtTypeNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkCollectorIndentSepNode(node CollectorIndentSepNode) Stopper {
	if fn := w.EnterCollectorIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIndentSep() {
		if s := w.WalkIndentSepNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitCollectorIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkCollectorNode(node CollectorNode) Stopper {
	if fn := w.EnterCollectorNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllCollectorStmt() {
		if s := w.WalkCollectorStmtNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLevel(); child != nil {
		child := *child
		if s := w.WalkIndentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneShortcut(); child != nil {
		child := *child
		if fn := w.EnterShortcutNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitCollectorNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkCollectorPubsubCallNode(node CollectorPubsubCallNode) Stopper {
	if fn := w.EnterCollectorPubsubCallNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OnePublisher(); child != nil {
		child := *child
		if s := w.WalkAppnameNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneSubscriber(); child != nil {
		child := *child
		if s := w.WalkAppnameNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitCollectorPubsubCallNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkCollectorStmtNode(node CollectorStmtNode) Stopper {
	if fn := w.EnterCollectorStmtNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAction(); child != nil {
		child := *child
		if s := w.WalkAppnameNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAttribs(); child != nil {
		child := *child
		if s := w.WalkAttribsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneCollectorCallStmt(); child != nil {
		child := *child
		if s := w.WalkCollectorCallStmtNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneCollectorHttpStmt(); child != nil {
		child := *child
		if s := w.WalkCollectorHttpStmtNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneCollectorPubsubCall(); child != nil {
		child := *child
		if s := w.WalkCollectorPubsubCallNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitCollectorStmtNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkCommentNoNlNode(node CommentNoNlNode) Stopper {
	if fn := w.EnterCommentNoNlNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitCommentNoNlNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkCommentNode(node CommentNode) Stopper {
	if fn := w.EnterCommentNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneCommentNoNl(); child != nil {
		child := *child
		if s := w.WalkCommentNoNlNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitCommentNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkElseStmtIndentSepNode(node ElseStmtIndentSepNode) Stopper {
	if fn := w.EnterElseStmtIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIndentSep() {
		if s := w.WalkIndentSepNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitElseStmtIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkElseStmtNode(node ElseStmtNode) Stopper {
	if fn := w.EnterElseStmtNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLevel(); child != nil {
		child := *child
		if s := w.WalkIndentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OnePredicate(); child != nil {
		child := *child
		if fn := w.EnterPredicateNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	for _, child := range node.AllStmt() {
		if s := w.WalkStmtNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitElseStmtNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkEndpointNode(node EndpointNode) Stopper {
	if fn := w.EnterEndpointNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneCollector(); child != nil {
		child := *child
		if s := w.WalkCollectorNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneEvent(); child != nil {
		child := *child
		if s := w.WalkEventNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneRestEndpoint(); child != nil {
		child := *child
		if s := w.WalkRestEndpointNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneSimpleEndpoint(); child != nil {
		child := *child
		if s := w.WalkSimpleEndpointNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitEndpointNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkEnumEnumerationNode(node EnumEnumerationNode) Stopper {
	if fn := w.EnterEnumEnumerationNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllCommentNoNl() {
		if s := w.WalkCommentNoNlNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneDigits(); child != nil {
		child := *child
		if fn := w.EnterDigitsNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitEnumEnumerationNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkEnumIndentSepNode(node EnumIndentSepNode) Stopper {
	if fn := w.EnterEnumIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIndentSep() {
		if s := w.WalkIndentSepNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitEnumIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkEnumNode(node EnumNode) Stopper {
	if fn := w.EnterEnumNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAttribs(); child != nil {
		child := *child
		if s := w.WalkAttribsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllComment() {
		if s := w.WalkCommentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllCommentNoNl() {
		if s := w.WalkCommentNoNlNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllEnumeration() {
		if s := w.WalkEnumEnumerationNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLevel(); child != nil {
		child := *child
		if s := w.WalkIndentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneShortcut(); child != nil {
		child := *child
		if fn := w.EnterShortcutNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitEnumNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkEolNode(node EolNode) Stopper {
	if fn := w.EnterEolNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllComment() {
		if s := w.WalkCommentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitEolNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkEventIndentSepNode(node EventIndentSepNode) Stopper {
	if fn := w.EnterEventIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIndentSep() {
		if s := w.WalkIndentSepNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitEventIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkEventNode(node EventNode) Stopper {
	if fn := w.EnterEventNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAttribs(); child != nil {
		child := *child
		if s := w.WalkAttribsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllComment() {
		if s := w.WalkCommentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLevel(); child != nil {
		child := *child
		if s := w.WalkIndentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneParams(); child != nil {
		child := *child
		if s := w.WalkParamsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneShortcut(); child != nil {
		child := *child
		if fn := w.EnterShortcutNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	for _, child := range node.AllStmt() {
		if s := w.WalkStmtNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitEventNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkExprBlockIndentSepNode(node ExprBlockIndentSepNode) Stopper {
	if fn := w.EnterExprBlockIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIndentSep() {
		if s := w.WalkIndentSepNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitExprBlockIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkExprBlockNode(node ExprBlockNode) Stopper {
	if fn := w.EnterExprBlockNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneArg(); child != nil {
		child := *child
		if s := w.WalkExprNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneEol(); child != nil {
		child := *child
		if s := w.WalkEolNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneExprRetType(); child != nil {
		child := *child
		if s := w.WalkExprRetTypeNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllExprStmt() {
		if s := w.WalkExprStmtNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLevel(); child != nil {
		child := *child
		if s := w.WalkIndentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneScopevar(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitExprBlockNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkExprFuncArgsNode(node ExprFuncArgsNode) Stopper {
	if fn := w.EnterExprFuncArgsNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllExpr() {
		if s := w.WalkExprNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitExprFuncArgsNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkExprFuncFuncNode(node ExprFuncFuncNode) Stopper {
	if fn := w.EnterExprFuncFuncNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneNativeDataTypes(); child != nil {
		child := *child
		if s := w.WalkNativeDataTypesNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitExprFuncFuncNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkExprFuncNode(node ExprFuncNode) Stopper {
	if fn := w.EnterExprFuncNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneArgs(); child != nil {
		child := *child
		if s := w.WalkExprFuncArgsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneFunc(); child != nil {
		child := *child
		if s := w.WalkExprFuncFuncNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitExprFuncNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkExprIfElseNode(node ExprIfElseNode) Stopper {
	if fn := w.EnterExprIfElseNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneEol(); child != nil {
		child := *child
		if s := w.WalkEolNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllExpr() {
		if s := w.WalkExprNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitExprIfElseNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkExprNode(node ExprNode) Stopper {
	if fn := w.EnterExprNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAtom(); child != nil {
		child := *child
		if s := w.WalkAtomNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllExpr() {
		if s := w.WalkExprNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneExprIfElse(); child != nil {
		child := *child
		if s := w.WalkExprIfElseNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllRelop() {
		if s := w.WalkRelopNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneUnaryop(); child != nil {
		child := *child
		if s := w.WalkExprUnaryopNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitExprNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkExprOpNode(node ExprOpNode) Stopper {
	if fn := w.EnterExprOpNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitExprOpNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkExprRetTypeCollectionNode(node ExprRetTypeCollectionNode) Stopper {
	if fn := w.EnterExprRetTypeCollectionNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneTypeSpec(); child != nil {
		child := *child
		if s := w.WalkTypeSpecNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitExprRetTypeCollectionNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkExprRetTypeNode(node ExprRetTypeNode) Stopper {
	if fn := w.EnterExprRetTypeNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneCollection(); child != nil {
		child := *child
		if s := w.WalkExprRetTypeCollectionNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneTypeSpec(); child != nil {
		child := *child
		if s := w.WalkTypeSpecNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitExprRetTypeNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkExprStmtExprAssignNode(node ExprStmtExprAssignNode) Stopper {
	if fn := w.EnterExprStmtExprAssignNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneExpr(); child != nil {
		child := *child
		if s := w.WalkExprNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneExprBlock(); child != nil {
		child := *child
		if s := w.WalkExprBlockNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneIdent(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitExprStmtExprAssignNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkExprStmtExprDotAssignNode(node ExprStmtExprDotAssignNode) Stopper {
	if fn := w.EnterExprStmtExprDotAssignNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneField(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneObj(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitExprStmtExprDotAssignNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkExprStmtExprTableAssignNode(node ExprStmtExprTableAssignNode) Stopper {
	if fn := w.EnterExprStmtExprTableAssignNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneExpr(); child != nil {
		child := *child
		if s := w.WalkExprNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneExprBlock(); child != nil {
		child := *child
		if s := w.WalkExprBlockNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneIdent(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitExprStmtExprTableAssignNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkExprStmtNode(node ExprStmtNode) Stopper {
	if fn := w.EnterExprStmtNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneCommentNoNl(); child != nil {
		child := *child
		if s := w.WalkCommentNoNlNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneExprAssign(); child != nil {
		child := *child
		if s := w.WalkExprStmtExprAssignNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneExprDotAssign(); child != nil {
		child := *child
		if s := w.WalkExprStmtExprDotAssignNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneExprTableAssign(); child != nil {
		child := *child
		if s := w.WalkExprStmtExprTableAssignNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitExprStmtNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkExprTableOfOpDotNode(node ExprTableOfOpDotNode) Stopper {
	if fn := w.EnterExprTableOfOpDotNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitExprTableOfOpDotNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkExprTableOfOpNode(node ExprTableOfOpNode) Stopper {
	if fn := w.EnterExprTableOfOpNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneDot(); child != nil {
		child := *child
		if s := w.WalkExprTableOfOpDotNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneIdent(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitExprTableOfOpNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkExprUnaryopNode(node ExprUnaryopNode) Stopper {
	if fn := w.EnterExprUnaryopNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitExprUnaryopNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkFacadeIndentSepNode(node FacadeIndentSepNode) Stopper {
	if fn := w.EnterFacadeIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIndentSep() {
		if s := w.WalkIndentSepNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitFacadeIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkFacadeInplaceTableDefIndentSepNode(node FacadeInplaceTableDefIndentSepNode) Stopper {
	if fn := w.EnterFacadeInplaceTableDefIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIndentSep() {
		if s := w.WalkIndentSepNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitFacadeInplaceTableDefIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkFacadeInplaceTableDefNode(node FacadeInplaceTableDefNode) Stopper {
	if fn := w.EnterFacadeInplaceTableDefNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllAttribs() {
		if s := w.WalkAttribsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLevel(); child != nil {
		child := *child
		if s := w.WalkIndentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllName() {
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitFacadeInplaceTableDefNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkFacadeNode(node FacadeNode) Stopper {
	if fn := w.EnterFacadeNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllComment() {
		if s := w.WalkCommentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllInplaceTableDef() {
		if s := w.WalkFacadeInplaceTableDefNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLevel(); child != nil {
		child := *child
		if s := w.WalkIndentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllName() {
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitFacadeNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkFieldIndentSepNode(node FieldIndentSepNode) Stopper {
	if fn := w.EnterFieldIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIndentSep() {
		if s := w.WalkIndentSepNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitFieldIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkFieldNode(node FieldNode) Stopper {
	if fn := w.EnterFieldNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneArraySize(); child != nil {
		child := *child
		if s := w.WalkArraySizeNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllField() {
		if s := w.WalkFieldNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneFieldType(); child != nil {
		child := *child
		if s := w.WalkFieldTypeNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLevel(); child != nil {
		child := *child
		if s := w.WalkIndentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneQstring(); child != nil {
		child := *child
		if fn := w.EnterQstringNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitFieldNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkFieldTypeNode(node FieldTypeNode) Stopper {
	if fn := w.EnterFieldTypeNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAttribs(); child != nil {
		child := *child
		if s := w.WalkAttribsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneCollectionType(); child != nil {
		child := *child
		if s := w.WalkCollectionTypeNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneTypeSpec(); child != nil {
		child := *child
		if s := w.WalkTypeSpecNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitFieldTypeNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkFirstFuncNode(node FirstFuncNode) Stopper {
	if fn := w.EnterFirstFuncNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneRankExpr(); child != nil {
		child := *child
		if s := w.WalkRankExprNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneScopevar(); child != nil {
		child := *child
		if s := w.WalkFirstFuncScopevarNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneTarget(); child != nil {
		child := *child
		if s := w.WalkFirstFuncTargetNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitFirstFuncNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkFirstFuncScopevarNode(node FirstFuncScopevarNode) Stopper {
	if fn := w.EnterFirstFuncScopevarNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitFirstFuncScopevarNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkFirstFuncTargetNode(node FirstFuncTargetNode) Stopper {
	if fn := w.EnterFirstFuncTargetNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneExpr(); child != nil {
		child := *child
		if s := w.WalkExprNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitFirstFuncTargetNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkForStmtForTypeNode(node ForStmtForTypeNode) Stopper {
	if fn := w.EnterForStmtForTypeNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitForStmtForTypeNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkForStmtIndentSepNode(node ForStmtIndentSepNode) Stopper {
	if fn := w.EnterForStmtIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIndentSep() {
		if s := w.WalkIndentSepNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitForStmtIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkForStmtNode(node ForStmtNode) Stopper {
	if fn := w.EnterForStmtNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneForType(); child != nil {
		child := *child
		if s := w.WalkForStmtForTypeNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLevel(); child != nil {
		child := *child
		if s := w.WalkIndentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OnePredicate(); child != nil {
		child := *child
		if fn := w.EnterPredicateNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	for _, child := range node.AllStmt() {
		if s := w.WalkStmtNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitForStmtNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkGroupStmtIndentSepNode(node GroupStmtIndentSepNode) Stopper {
	if fn := w.EnterGroupStmtIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIndentSep() {
		if s := w.WalkIndentSepNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitGroupStmtIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkGroupStmtNode(node GroupStmtNode) Stopper {
	if fn := w.EnterGroupStmtNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLevel(); child != nil {
		child := *child
		if s := w.WalkIndentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	for _, child := range node.AllStmt() {
		if s := w.WalkStmtNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitGroupStmtNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkHttpPathNode(node HttpPathNode) Stopper {
	if fn := w.EnterHttpPathNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllHttpPathPart() {
		if s := w.WalkHttpPathPartNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllHttpPathVarWithType() {
		if s := w.WalkHttpPathVarWithTypeNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitHttpPathNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkHttpPathPartNode(node HttpPathPartNode) Stopper {
	if fn := w.EnterHttpPathPartNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllDigits() {
		if fn := w.EnterDigitsNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	for _, child := range node.AllName() {
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitHttpPathPartNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkHttpPathVarWithTypeNode(node HttpPathVarWithTypeNode) Stopper {
	if fn := w.EnterHttpPathVarWithTypeNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneType(); child != nil {
		child := *child
		if s := w.WalkHttpPathVarWithTypeTypeNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneVar(); child != nil {
		child := *child
		if s := w.WalkHttpPathVarWithTypeVarNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitHttpPathVarWithTypeNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkHttpPathVarWithTypeTypeNode(node HttpPathVarWithTypeTypeNode) Stopper {
	if fn := w.EnterHttpPathVarWithTypeTypeNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneNativeDataTypes(); child != nil {
		child := *child
		if s := w.WalkNativeDataTypesNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneReference(); child != nil {
		child := *child
		if s := w.WalkReferenceNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitHttpPathVarWithTypeTypeNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkHttpPathVarWithTypeVarNode(node HttpPathVarWithTypeVarNode) Stopper {
	if fn := w.EnterHttpPathVarWithTypeVarNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneDigits(); child != nil {
		child := *child
		if fn := w.EnterDigitsNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitHttpPathVarWithTypeVarNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkHttpVerbsNode(node HttpVerbsNode) Stopper {
	if fn := w.EnterHttpVerbsNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitHttpVerbsNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkIfElseNode(node IfElseNode) Stopper {
	if fn := w.EnterIfElseNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllElseStmt() {
		if s := w.WalkElseStmtNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneIfStmt(); child != nil {
		child := *child
		if s := w.WalkIfStmtNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitIfElseNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkIfStmtIndentSepNode(node IfStmtIndentSepNode) Stopper {
	if fn := w.EnterIfStmtIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIndentSep() {
		if s := w.WalkIndentSepNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitIfStmtIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkIfStmtNode(node IfStmtNode) Stopper {
	if fn := w.EnterIfStmtNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLevel(); child != nil {
		child := *child
		if s := w.WalkIndentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OnePredicate(); child != nil {
		child := *child
		if fn := w.EnterPredicateNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	for _, child := range node.AllStmt() {
		if s := w.WalkStmtNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitIfStmtNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkImportNode(node ImportNode) Stopper {
	if fn := w.EnterImportNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneMode(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OnePath(); child != nil {
		child := *child
		if s := w.WalkPathNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OnePrefix(); child != nil {
		child := *child
		if s := w.WalkImportPrefixNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneReference(); child != nil {
		child := *child
		if s := w.WalkReferenceNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitImportNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkImportPrefixNode(node ImportPrefixNode) Stopper {
	if fn := w.EnterImportPrefixNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitImportPrefixNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkIndentNode(node IndentNode) Stopper {
	if fn := w.EnterIndentNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitIndentNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkIndentSepNode(node IndentSepNode) Stopper {
	if fn := w.EnterIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkMatchingNode(node MatchingNode) Stopper {
	if fn := w.EnterMatchingNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneRhs(); child != nil {
		child := *child
		if s := w.WalkMatchingRhsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneSquigglyArgs(); child != nil {
		child := *child
		if s := w.WalkMatchingSquigglyArgsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitMatchingNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkMatchingRhsNode(node MatchingRhsNode) Stopper {
	if fn := w.EnterMatchingRhsNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneExpr(); child != nil {
		child := *child
		if s := w.WalkExprNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneExprTableOfOp(); child != nil {
		child := *child
		if s := w.WalkExprTableOfOpNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneNavigate(); child != nil {
		child := *child
		if s := w.WalkNavigateNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitMatchingRhsNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkMatchingSquigglyArgsNode(node MatchingSquigglyArgsNode) Stopper {
	if fn := w.EnterMatchingSquigglyArgsNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllName() {
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitMatchingSquigglyArgsNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkMethodDefIndentSepNode(node MethodDefIndentSepNode) Stopper {
	if fn := w.EnterMethodDefIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIndentSep() {
		if s := w.WalkIndentSepNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitMethodDefIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkMethodDefNode(node MethodDefNode) Stopper {
	if fn := w.EnterMethodDefNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAttribs(); child != nil {
		child := *child
		if s := w.WalkAttribsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLevel(); child != nil {
		child := *child
		if s := w.WalkIndentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneMethod(); child != nil {
		child := *child
		if s := w.WalkHttpVerbsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneParams(); child != nil {
		child := *child
		if s := w.WalkParamsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneQueryParam(); child != nil {
		child := *child
		if s := w.WalkQueryParamNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllStmt() {
		if s := w.WalkStmtNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitMethodDefNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkMultiLineDocstringIndentSepNode(node MultiLineDocstringIndentSepNode) Stopper {
	if fn := w.EnterMultiLineDocstringIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIndentSep() {
		if s := w.WalkIndentSepNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitMultiLineDocstringIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkMultiLineDocstringNode(node MultiLineDocstringNode) Stopper {
	if fn := w.EnterMultiLineDocstringNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLevel(); child != nil {
		child := *child
		if s := w.WalkIndentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllText() {
		if fn := w.EnterTextNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitMultiLineDocstringNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkNativeDataTypesNode(node NativeDataTypesNode) Stopper {
	if fn := w.EnterNativeDataTypesNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitNativeDataTypesNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkNavigateAttrNode(node NavigateAttrNode) Stopper {
	if fn := w.EnterNavigateAttrNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitNavigateAttrNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkNavigateNode(node NavigateNode) Stopper {
	if fn := w.EnterNavigateNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAttr(); child != nil {
		child := *child
		if s := w.WalkNavigateAttrNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneVia(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitNavigateNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkOneOfCasesIndentSepNode(node OneOfCasesIndentSepNode) Stopper {
	if fn := w.EnterOneOfCasesIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIndentSep() {
		if s := w.WalkIndentSepNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitOneOfCasesIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkOneOfCasesNode(node OneOfCasesNode) Stopper {
	if fn := w.EnterOneOfCasesNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLevel(); child != nil {
		child := *child
		if s := w.WalkIndentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneOneOfCaseLabel(); child != nil {
		child := *child
		if s := w.WalkOneOfCasesOneOfCaseLabelNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllStmt() {
		if s := w.WalkStmtNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitOneOfCasesNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkOneOfCasesOneOfCaseLabelNode(node OneOfCasesOneOfCaseLabelNode) Stopper {
	if fn := w.EnterOneOfCasesOneOfCaseLabelNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneQstring(); child != nil {
		child := *child
		if fn := w.EnterQstringNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneTextLine(); child != nil {
		child := *child
		if fn := w.EnterTextLineNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitOneOfCasesOneOfCaseLabelNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkOneOfStmtIndentSepNode(node OneOfStmtIndentSepNode) Stopper {
	if fn := w.EnterOneOfStmtIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIndentSep() {
		if s := w.WalkIndentSepNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitOneOfStmtIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkOneOfStmtNode(node OneOfStmtNode) Stopper {
	if fn := w.EnterOneOfStmtNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLevel(); child != nil {
		child := *child
		if s := w.WalkIndentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllOneOfCases() {
		if s := w.WalkOneOfCasesNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitOneOfStmtNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkParamsNode(node ParamsNode) Stopper {
	if fn := w.EnterParamsNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllField() {
		if s := w.WalkFieldNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllReference() {
		if s := w.WalkReferenceNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitParamsNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkPathNode(node PathNode) Stopper {
	if fn := w.EnterPathNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitPathNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkQueryParamNode(node QueryParamNode) Stopper {
	if fn := w.EnterQueryParamNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIdent() {
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	for _, child := range node.AllName() {
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	for _, child := range node.AllNativeDataTypes() {
		if s := w.WalkNativeDataTypesNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitQueryParamNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkRankExprFuncNode(node RankExprFuncNode) Stopper {
	if fn := w.EnterRankExprFuncNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitRankExprFuncNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkRankExprNode(node RankExprNode) Stopper {
	if fn := w.EnterRankExprNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllExpr() {
		if s := w.WalkExprNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllFunc() {
		if s := w.WalkRankExprFuncNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitRankExprNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkRankFuncNode(node RankFuncNode) Stopper {
	if fn := w.EnterRankFuncNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAs(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneRankExpr(); child != nil {
		child := *child
		if s := w.WalkRankExprNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneTypeSpec(); child != nil {
		child := *child
		if s := w.WalkTypeSpecNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitRankFuncNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkReferenceNode(node ReferenceNode) Stopper {
	if fn := w.EnterReferenceNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAppname(); child != nil {
		child := *child
		if s := w.WalkAppnameNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OnePkg(); child != nil {
		child := *child
		if s := w.WalkReferencePkgNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitReferenceNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkReferencePkgNode(node ReferencePkgNode) Stopper {
	if fn := w.EnterReferencePkgNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllName() {
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitReferencePkgNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkRelopNode(node RelopNode) Stopper {
	if fn := w.EnterRelopNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAggFunc(); child != nil {
		child := *child
		if s := w.WalkAggFuncNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAnyFunc(); child != nil {
		child := *child
		if s := w.WalkAnyFuncNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneCount(); child != nil {
		child := *child
		if fn := w.EnterCountNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneExprTableOfOp(); child != nil {
		child := *child
		if s := w.WalkExprTableOfOpNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneFirstFunc(); child != nil {
		child := *child
		if s := w.WalkFirstFuncNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneMatching(); child != nil {
		child := *child
		if s := w.WalkMatchingNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneNavigate(); child != nil {
		child := *child
		if s := w.WalkNavigateNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneRankFunc(); child != nil {
		child := *child
		if s := w.WalkRankFuncNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneSingleArgFunc(); child != nil {
		child := *child
		if s := w.WalkSingleArgFuncNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneSingleOrNull(); child != nil {
		child := *child
		if s := w.WalkSingleOrNullNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneSnapshot(); child != nil {
		child := *child
		if fn := w.EnterSnapshotNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitRelopNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkRestEndpointIndentSepNode(node RestEndpointIndentSepNode) Stopper {
	if fn := w.EnterRestEndpointIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIndentSep() {
		if s := w.WalkIndentSepNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitRestEndpointIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkRestEndpointNode(node RestEndpointNode) Stopper {
	if fn := w.EnterRestEndpointNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAttribs(); child != nil {
		child := *child
		if s := w.WalkAttribsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneHttpPath(); child != nil {
		child := *child
		if s := w.WalkHttpPathNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLevel(); child != nil {
		child := *child
		if s := w.WalkIndentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllMethodDef() {
		if s := w.WalkMethodDefNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllRestEndpoint() {
		if s := w.WalkRestEndpointNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitRestEndpointNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkRetStmtNode(node RetStmtNode) Stopper {
	if fn := w.EnterRetStmtNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneRetVal(); child != nil {
		child := *child
		if fn := w.EnterTextNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitRetStmtNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkSimpleEndpointIndentSepNode(node SimpleEndpointIndentSepNode) Stopper {
	if fn := w.EnterSimpleEndpointIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIndentSep() {
		if s := w.WalkIndentSepNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitSimpleEndpointIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkSimpleEndpointNode(node SimpleEndpointNode) Stopper {
	if fn := w.EnterSimpleEndpointNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAttribs(); child != nil {
		child := *child
		if s := w.WalkAttribsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneEndpointName(); child != nil {
		child := *child
		if s := w.WalkAppnameNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLevel(); child != nil {
		child := *child
		if s := w.WalkIndentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneParams(); child != nil {
		child := *child
		if s := w.WalkParamsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneQstring(); child != nil {
		child := *child
		if fn := w.EnterQstringNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneShortcut(); child != nil {
		child := *child
		if fn := w.EnterShortcutNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	for _, child := range node.AllStmt() {
		if s := w.WalkStmtNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitSimpleEndpointNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkSingleArgFuncFuncNode(node SingleArgFuncFuncNode) Stopper {
	if fn := w.EnterSingleArgFuncFuncNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitSingleArgFuncFuncNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkSingleArgFuncNode(node SingleArgFuncNode) Stopper {
	if fn := w.EnterSingleArgFuncNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneExpr(); child != nil {
		child := *child
		if s := w.WalkExprNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneFunc(); child != nil {
		child := *child
		if s := w.WalkSingleArgFuncFuncNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneScopevar(); child != nil {
		child := *child
		if s := w.WalkSingleArgFuncScopevarNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitSingleArgFuncNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkSingleArgFuncScopevarNode(node SingleArgFuncScopevarNode) Stopper {
	if fn := w.EnterSingleArgFuncScopevarNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitSingleArgFuncScopevarNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkSingleOrNullNode(node SingleOrNullNode) Stopper {
	if fn := w.EnterSingleOrNullNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitSingleOrNullNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkStmtNode(node StmtNode) Stopper {
	if fn := w.EnterStmtNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAnnotation(); child != nil {
		child := *child
		if s := w.WalkAnnotationNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAttribs(); child != nil {
		child := *child
		if s := w.WalkAttribsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneCallStmt(); child != nil {
		child := *child
		if s := w.WalkCallStmtNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneForStmt(); child != nil {
		child := *child
		if s := w.WalkForStmtNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneGroupStmt(); child != nil {
		child := *child
		if s := w.WalkGroupStmtNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneHttpMethodComment(); child != nil {
		child := *child
		if s := w.WalkCommentNoNlNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneIfElse(); child != nil {
		child := *child
		if s := w.WalkIfElseNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneOneOfStmt(); child != nil {
		child := *child
		if s := w.WalkOneOfStmtNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneRetStmt(); child != nil {
		child := *child
		if s := w.WalkRetStmtNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneTextStmt(); child != nil {
		child := *child
		if s := w.WalkTextStmtNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitStmtNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkSubscribeIndentSepNode(node SubscribeIndentSepNode) Stopper {
	if fn := w.EnterSubscribeIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIndentSep() {
		if s := w.WalkIndentSepNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitSubscribeIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkSubscribeNode(node SubscribeNode) Stopper {
	if fn := w.EnterSubscribeNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAppname(); child != nil {
		child := *child
		if s := w.WalkAppnameNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAttribs(); child != nil {
		child := *child
		if s := w.WalkAttribsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllComment() {
		if s := w.WalkCommentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLevel(); child != nil {
		child := *child
		if s := w.WalkIndentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneParams(); child != nil {
		child := *child
		if s := w.WalkParamsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneShortcut(); child != nil {
		child := *child
		if fn := w.EnterShortcutNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	for _, child := range node.AllStmt() {
		if s := w.WalkStmtNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitSubscribeNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkSyslFileNode(node SyslFileNode) Stopper {
	if fn := w.EnterSyslFileNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllApplication() {
		if s := w.WalkApplicationNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllEol() {
		if s := w.WalkEolNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllImport() {
		if s := w.WalkImportNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitSyslFileNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkTableIndentSepNode(node TableIndentSepNode) Stopper {
	if fn := w.EnterTableIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIndentSep() {
		if s := w.WalkIndentSepNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitTableIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkTableModeNode(node TableModeNode) Stopper {
	if fn := w.EnterTableModeNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitTableModeNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkTableNode(node TableNode) Stopper {
	if fn := w.EnterTableNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAttribs(); child != nil {
		child := *child
		if s := w.WalkAttribsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllComment() {
		if s := w.WalkCommentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllCommentNoNl() {
		if s := w.WalkCommentNoNlNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLevel(); child != nil {
		child := *child
		if s := w.WalkIndentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneMode(); child != nil {
		child := *child
		if s := w.WalkTableModeNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	for _, child := range node.AllTableRow() {
		if s := w.WalkTableTableRowNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitTableNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkTableTableRowNode(node TableTableRowNode) Stopper {
	if fn := w.EnterTableTableRowNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAnnotations(); child != nil {
		child := *child
		if s := w.WalkAnnotationsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneArraySize(); child != nil {
		child := *child
		if s := w.WalkArraySizeNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAttribs(); child != nil {
		child := *child
		if s := w.WalkAttribsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneType(); child != nil {
		child := *child
		if s := w.WalkTableTableRowTypeNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitTableTableRowNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkTableTableRowTypeNode(node TableTableRowTypeNode) Stopper {
	if fn := w.EnterTableTableRowTypeNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneCollectionType(); child != nil {
		child := *child
		if s := w.WalkCollectionTypeNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneTypeSpec(); child != nil {
		child := *child
		if s := w.WalkTypeSpecNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitTableTableRowTypeNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkTextStmtDocStringNode(node TextStmtDocStringNode) Stopper {
	if fn := w.EnterTextStmtDocStringNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitTextStmtDocStringNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkTextStmtNode(node TextStmtNode) Stopper {
	if fn := w.EnterTextStmtNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneDocString(); child != nil {
		child := *child
		if s := w.WalkTextStmtDocStringNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneQstring(); child != nil {
		child := *child
		if fn := w.EnterQstringNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneShortcut(); child != nil {
		child := *child
		if fn := w.EnterShortcutNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneText(); child != nil {
		child := *child
		if fn := w.EnterTextNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}

	if fn := w.ExitTextStmtNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkTypeDeclNode(node TypeDeclNode) Stopper {
	if fn := w.EnterTypeDeclNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAlias(); child != nil {
		child := *child
		if s := w.WalkAliasNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneEnum(); child != nil {
		child := *child
		if s := w.WalkEnumNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneFacade(); child != nil {
		child := *child
		if s := w.WalkFacadeNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneTable(); child != nil {
		child := *child
		if s := w.WalkTableNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneUnion(); child != nil {
		child := *child
		if s := w.WalkUnionNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitTypeDeclNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkTypeSpecNode(node TypeSpecNode) Stopper {
	if fn := w.EnterTypeSpecNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneNativeDataTypes(); child != nil {
		child := *child
		if s := w.WalkNativeDataTypesNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneReference(); child != nil {
		child := *child
		if s := w.WalkReferenceNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneSizeSpec(); child != nil {
		child := *child
		if s := w.WalkTypeSpecSizeSpecNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitTypeSpecNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkTypeSpecSizeSpecNode(node TypeSpecSizeSpecNode) Stopper {
	if fn := w.EnterTypeSpecSizeSpecNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitTypeSpecSizeSpecNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkUnionIndentSepNode(node UnionIndentSepNode) Stopper {
	if fn := w.EnterUnionIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIndentSep() {
		if s := w.WalkIndentSepNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitUnionIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkUnionNode(node UnionNode) Stopper {
	if fn := w.EnterUnionNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllAnnotation() {
		if s := w.WalkAnnotationNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAttribs(); child != nil {
		child := *child
		if s := w.WalkAttribsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllComment() {
		if s := w.WalkCommentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLevel(); child != nil {
		child := *child
		if s := w.WalkIndentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	for _, child := range node.AllShortcut() {
		if fn := w.EnterShortcutNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	for _, child := range node.AllTypeSpec() {
		if s := w.WalkTypeSpecNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitUnionNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkViewIndentSepNode(node ViewIndentSepNode) Stopper {
	if fn := w.EnterViewIndentSepNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllIndentSep() {
		if s := w.WalkIndentSepNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitViewIndentSepNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkViewNode(node ViewNode) Stopper {
	if fn := w.EnterViewNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneAttribs(); child != nil {
		child := *child
		if s := w.WalkAttribsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllExprBlock() {
		if s := w.WalkExprBlockNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneLevel(); child != nil {
		child := *child
		if s := w.WalkIndentNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneName(); child != nil {
		child := *child
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	if child := node.OneRetType(); child != nil {
		child := *child
		if s := w.WalkViewRetTypeNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneViewParams(); child != nil {
		child := *child
		if s := w.WalkViewParamsNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitViewNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkViewParamsNode(node ViewParamsNode) Stopper {
	if fn := w.EnterViewParamsNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllCollectionType() {
		if s := w.WalkCollectionTypeNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	for _, child := range node.AllName() {
		if fn := w.EnterNameNode; fn != nil {
			if s := fn(child); s != nil {
				if s.ExitNode() {
					return nil
				} else if s.Abort() {
					return s
				}
			}
		}
	}
	for _, child := range node.AllTypeSpec() {
		if s := w.WalkTypeSpecNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitViewParamsNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkViewRetTypeNode(node ViewRetTypeNode) Stopper {
	if fn := w.EnterViewRetTypeNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneCollectionType(); child != nil {
		child := *child
		if s := w.WalkCollectionTypeNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}
	if child := node.OneTypeSpec(); child != nil {
		child := *child
		if s := w.WalkTypeSpecNode(child); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitViewRetTypeNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (w WalkerOps) WalkWrapReNode(node WrapReNode) Stopper {
	if fn := w.EnterWrapReNode; fn != nil {
		if s := fn(node); s != nil {
			if s.ExitNode() {
				return nil
			} else if s.Abort() {
				return s
			}
		}
	}

	if fn := w.ExitWrapReNode; fn != nil {
		if s := fn(node); s != nil && s.Abort() {
			return s
		}
	}
	return nil
}

func (c SyslFileNode) GetAstNode() ast.Node { return c.Node }

func NewSyslFileNode(from ast.Node) SyslFileNode { return SyslFileNode{from} }

func Parse(input *parser.Scanner) (SyslFileNode, error) {
	p := Grammar()
	tree, err := p.Parse("sysl_file", input)
	if err != nil {
		return SyslFileNode{nil}, err
	}
	return SyslFileNode{ast.FromParserNode(p.Grammar(), tree)}, nil
}

func ParseString(input string) (SyslFileNode, error) {
	return Parse(parser.NewScanner(input))
}
