package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/sirupsen/logrus"
)

const binaryInfoFilename = "pkg/cfg/binaryinfo.go"

func main() {
	if err := generateBinaryInfo(); err != nil {
		logrus.Fatalf("generate binary info error: %s\n", generateBinaryInfo())
	}
}

func generateBinaryInfo() error {
	info, err := latestGitReleaseInfo()
	if err != nil {
		return err
	}
	version, gitCommit, buildDate := info[0], info[1], info[2]
	dir, err := os.Getwd()
	if err != nil {
		return err
	}
	fmt.Println("version:", version)
	fmt.Println("git commit:", gitCommit)
	fmt.Println("build date:", buildDate)

	var buf bytes.Buffer
	fmt.Fprintf(&buf, "// Code generated by buildruntime.go; DO NOT EDIT.\n")
	fmt.Fprintln(&buf)
	fmt.Fprintf(&buf, "package cfg\n")
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "// Version   - Binary version")
	fmt.Fprintln(&buf, "// GitCommit - Commit SHA of the source code")
	fmt.Fprintln(&buf, "// BuildDate - Binary build date")
	fmt.Fprintln(&buf, "// BuildOS   - Operating System used to build binary")
	fmt.Fprintln(&buf, "//nolint:gochecknoglobals")
	fmt.Fprintln(&buf, "const (")
	fmt.Fprintf(&buf, "	Version   = `%s`\n", version)
	fmt.Fprintf(&buf, "	GitCommit = `%s`\n", gitCommit)
	fmt.Fprintf(&buf, "	BuildDate = `%s`\n", buildDate)
	fmt.Fprintf(&buf, "	BuildOS   = `%s`\n", runtime.GOOS)
	fmt.Fprintln(&buf, ")")

	writefile(buf.String(), filepath.Join(dir, binaryInfoFilename), writeSkipSame)
	return nil
}

const (
	writeExec = 1 << iota
	writeSkipSame
)

// writefile writes text to the named file, creating it if needed.
// if exec is non-zero, marks the file as executable.
// If the file already exists and has the expected content,
// it is not rewritten, to avoid changing the time stamp.
func writefile(text, file string, flag int) {
	new := []byte(text)
	if flag&writeSkipSame != 0 {
		old, err := ioutil.ReadFile(file)
		if err == nil && bytes.Equal(old, new) {
			logrus.Debugln("same file content")
			return
		}
	}
	mode := os.FileMode(0666)
	if flag&writeExec != 0 {
		mode = 0777
	}

	err := ioutil.WriteFile(file, new, mode)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}

func latestGitReleaseInfo() ([]string, error) {
	fmt.Println("running git command to find release info...")
	c1 := exec.Command("git", "describe", "--match=v[0-9]*", "--tags", "--abbrev=0")
	c2 := exec.Command("xargs", "-I{}", "sh", "-c", "echo $1 $(git log -1 --pretty='%h %cd' --date=short {})", "sh", "{}")

	var err error

	c2.Stdin, err = c1.StdoutPipe()
	if err != nil {
		return nil, err
	}
	var b bytes.Buffer
	c2.Stdout = &b

	err = c2.Start()
	if err != nil {
		return nil, err
	}

	err = c1.Run()
	if err != nil {
		return nil, err
	}

	err = c2.Wait()
	if err != nil {
		return nil, err
	}

	return strings.Fields(b.String()), nil
}
