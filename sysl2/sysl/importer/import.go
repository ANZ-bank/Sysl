package importer

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"sort"
	"strings"

	"github.com/sirupsen/logrus"

	"github.com/go-openapi/spec"

	"github.com/go-openapi/loads"
)

type OutputData struct {
	AppName string
	Package string
}

func LoadSwaggerText(args OutputData, text string, logger *logrus.Logger) (out string, err error) {

	doc, err := loads.Analyzed(json.RawMessage(text), "2.0")
	if err != nil {
		logger.Errorf("Failed to load swagger spec: %s\n", err.Error())
		return "", err
	}

	result := &bytes.Buffer{}

	swagger := doc.Spec()
	types := InitTypes(swagger, logger)
	globalParams := buildGlobalParams(swagger.Parameters, types, logger)

	si := swaggerImporter{
		Writer:       result,
		ind:          NewIndentWriter("    ", result),
		swagger:      doc.Spec(),
		logger:       logger,
		args:         args,
		types:        types,
		endpoints:    InitEndpoints(swagger, types, globalParams, logger),
		globalParams: globalParams,
	}
	if err := si.Write(); err != nil {
		return "", err
	}

	return result.String(), nil
}

type swaggerImporter struct {
	io.Writer
	ind     *IndentWriter
	swagger *spec.Swagger
	logger  *logrus.Logger
	args    OutputData

	types        TypeList
	endpoints    map[string][]Endpoint
	globalParams Parameters
}

func (si *swaggerImporter) mustWrite(s string) {
	if _, err := si.Writer.Write([]byte(s)); err != nil {
		si.logger.Fatalf("failed to complete write: %s", err.Error())
	}
}

const PushIndent = "&& >>"
const PopIndent = "&& <<"
const BlankLine = "&& !!"

func (si *swaggerImporter) writeLines(lines ...string) {
	for _, l := range lines {
		switch l {
		case PushIndent:
			si.ind.Push()
		case PopIndent:
			si.ind.Pop()
		case BlankLine:
			si.mustWrite("\n")
		default:
			_ = si.ind.Write() // nolint: errcheck
			si.mustWrite(l + "\n")
		}
	}
}

func (si *swaggerImporter) Write() error {

	if err := si.writeHeader(); err != nil {
		return err
	}

	if si.swagger.Info != nil {
		if err := si.writeInfo(); err != nil {
			return err
		}
	}

	if si.swagger.BasePath != "" {
		si.writeLines(fmt.Sprintf("%s:", si.swagger.BasePath), PushIndent, BlankLine)
	}
	for _, method := range methodDisplayOrder {
		for _, endpoint := range si.endpoints[method] {
			si.writeEndpoint(method, endpoint)
			si.writeLines(BlankLine)
		}
	}
	if si.swagger.BasePath != "" {
		si.writeLines(PopIndent)
	}

	si.writeDefinitions()

	return nil
}

func (si *swaggerImporter) writeInfo() error {

	desc := ""
	if info := si.swagger.Info; info != nil {
		desc = getDescription(info.Description)
		values := []string{
			"version", info.Version,
			"host", si.swagger.Host,
			"license", "",
			"termsOfService", info.TermsOfService}
		for i := 0; i < len(values); i += 2 {
			key := values[i]
			val := values[i+1]
			if val != "" {
				si.writeLines(fmt.Sprintf("@%s = %s", key, quote(val)))
			}
		}
	}
	si.writeLines("@description =:", PushIndent, "| "+getDescription(desc), PopIndent, BlankLine)
	return nil
}

func getDescription(d string) string {
	if d == "" {
		return "No description."
	}
	return d
}

func quote(s string) string {
	return `"` + s + `"`
}

func (si *swaggerImporter) writeHeader() error {

	si.mustWrite(`##########################################
##                                      ##
##  AUTOGENERATED CODE -- DO NOT EDIT!  ##
##                                      ##
##########################################

`)
	title := ""
	if si.swagger.Info != nil {
		title = si.swagger.Info.Title
	}

	si.writeLines(fmt.Sprintf("%s %s [package=%s]:", si.args.AppName, quote(title), quote(si.args.Package)))
	si.ind.Push()

	return nil
}

func buildQueryString(params []Param) string {
	query := ""
	if len(params) > 0 {
		var parts []string
		for _, p := range params {
			optional := ""
			if p.Optional {
				optional = "?"
			}
			parts = append(parts, fmt.Sprintf("%s=%s%s", p.Name, p.Type.Name(), optional))
		}
		query = " ?" + strings.Join(parts, "&")
	}
	return query
}

func buildRequestBodyString(params []Param) string {
	body := ""
	if len(params) > 0 {
		sort.SliceStable(params, func(i, j int) bool {
			return strings.Compare(params[i].Name, params[j].Name) < 0
		})
		var parts []string
		for _, p := range params {
			parts = append(parts, fmt.Sprintf("%s <: %s [~body]", p.Name, p.Type.Name()))
		}
		body = strings.Join(parts, ", ")
	}
	return body
}

func buildRequestHeadersString(params []Param) string {
	headers := ""
	if len(params) > 0 {
		var parts []string
		for _, p := range params {
			optional := map[bool]string{true: "~optional", false: "~required"}[p.Optional]

			safeName := strings.ToLower(strings.ReplaceAll(p.Name, "-", "_"))
			text := fmt.Sprintf("%s <: %s [~header, %s, name=%s]", safeName, p.Type.Name(), optional, quote(p.Name))
			parts = append(parts, text)
		}
		headers = strings.Join(parts, ", ")
	}
	return headers
}

func buildPathString(path string, params []Param) string {

	result := path

	for _, p := range params {
		replacement := fmt.Sprintf("{%s<:%s}", p.Name, p.Type.Name())
		result = strings.ReplaceAll(result, fmt.Sprintf("{%s}", p.Name), replacement)
	}

	return result
}

func (si *swaggerImporter) writeEndpoint(method string, endpoint Endpoint) {

	header := buildRequestHeadersString(endpoint.Params.HeaderParams())
	body := buildRequestBodyString(endpoint.Params.BodyParams())
	reqStr := ""
	if len(header) > 0 && len(body) > 0 {
		reqStr = fmt.Sprintf(" (%s)", strings.Join([]string{body, header}, ", "))
	} else if len(header) > 0 || len(body) > 0 {
		reqStr = fmt.Sprintf(" (%s)", body+header)
	}

	pathStr := buildPathString(endpoint.Path, endpoint.Params.PathParams())

	si.writeLines(fmt.Sprintf("%s:", pathStr), PushIndent,
		fmt.Sprintf("%s%s%s:", method, reqStr, buildQueryString(endpoint.Params.QueryParams())), PushIndent,
		fmt.Sprintf("| %s", getDescription(endpoint.Description)))

	if len(endpoint.Responses) > 0 {
		var outs []string
		for _, resp := range endpoint.Responses {
			if resp.Type != nil {
				outs = append(outs, getSyslTypeName(resp.Type))
			} else {
				outs = append(outs, resp.Text)
			}
		}
		sort.Strings(outs)
		si.writeLines(fmt.Sprintf("return %s", strings.Join(outs, ", ")))
	}

	si.writeLines(PopIndent, PopIndent)
}

func (si *swaggerImporter) writeDefinitions() {

	si.writeLines("#" + strings.Repeat("-", 75))
	si.writeLines("# definitions")
	var others []Type
	for _, t := range si.types {
		_, isEnum := t.(*Enum)
		switch {
		case isEnum:
			// We want the enum aliases listed with the real types
			si.writeLines(BlankLine)
			si.writeExternalAlias(t)
		case !isExternalAlias(t):
			si.writeLines(BlankLine)
			si.writeDefinition(t.(*StandardType))
		default:
			others = append(others, t)
		}
	}
	for _, t := range others {
		si.writeLines(BlankLine)
		si.writeExternalAlias(t)
	}
}

func (si *swaggerImporter) writeDefinition(t *StandardType) {
	bangName := "type"
	si.writeLines(fmt.Sprintf("!%s %s:", bangName, getSyslTypeName(t)))
	for _, prop := range t.Properties {
		suffix := ""
		if prop.Optional {
			suffix = "?"
		}

		name := prop.Name
		if IsKeyword(name) {
			name += "_"
		}

		si.writeLines(PushIndent, fmt.Sprintf("%s <: %s%s:", name, getSyslTypeName(prop.Type), suffix))
		si.writeLines(PushIndent, fmt.Sprintf("@json_tag = %s", quote(prop.Name)))
		si.writeLines(PopIndent, PopIndent)
	}
}

func isExternalAlias(item Type) bool {
	switch item.(type) {
	case *Alias, *Array, *Enum:
		return true
	}
	return false
}

func (si *swaggerImporter) writeExternalAlias(item Type) {
	aliasType := "string"
	aliasName := getSyslTypeName(item)
	switch t := item.(type) {
	case *StandardType:
		if len(t.Properties) > 0 {
			aliasType = getSyslTypeName(t.Properties[0].Type)
		}
	case *Alias:
		aliasType = getSyslTypeName(t.Target)
	case *Array:
		aliasType = getSyslTypeName(item)
		aliasName = t.name
	}
	si.writeLines(fmt.Sprintf("!alias %s:", aliasName),
		PushIndent, aliasType, PopIndent)
}

func getSyslTypeName(item Type) string {
	switch t := item.(type) {
	case *Array:
		return "sequence of " + getSyslTypeName(t.Items)
	case *Enum:
		return item.Name()
	}
	if isExternalAlias(item) {
		return "EXTERNAL_" + item.Name()
	}
	return item.Name()
}
