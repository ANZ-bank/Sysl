// Generated from grammar/SyslParser.g4 by ANTLR 4.7.

package parser // SyslParser

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 140, 1632,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	4, 152, 9, 152, 4, 153, 9, 153, 4, 154, 9, 154, 4, 155, 9, 155, 4, 156,
	9, 156, 4, 157, 9, 157, 4, 158, 9, 158, 4, 159, 9, 159, 4, 160, 9, 160,
	4, 161, 9, 161, 4, 162, 9, 162, 4, 163, 9, 163, 4, 164, 9, 164, 4, 165,
	9, 165, 4, 166, 9, 166, 4, 167, 9, 167, 4, 168, 9, 168, 4, 169, 9, 169,
	4, 170, 9, 170, 4, 171, 9, 171, 4, 172, 9, 172, 4, 173, 9, 173, 4, 174,
	9, 174, 4, 175, 9, 175, 3, 2, 3, 2, 3, 2, 3, 2, 7, 2, 355, 10, 2, 12, 2,
	14, 2, 358, 11, 2, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 364, 10, 3, 3, 3, 3, 3,
	3, 4, 3, 4, 3, 4, 7, 4, 371, 10, 4, 12, 4, 14, 4, 374, 11, 4, 3, 5, 3,
	5, 3, 5, 3, 5, 3, 6, 3, 6, 3, 7, 3, 7, 3, 7, 6, 7, 385, 10, 7, 13, 7, 14,
	7, 386, 3, 8, 3, 8, 3, 8, 3, 9, 3, 9, 3, 10, 3, 10, 3, 10, 3, 10, 7, 10,
	398, 10, 10, 12, 10, 14, 10, 401, 11, 10, 3, 10, 3, 10, 3, 11, 3, 11, 3,
	11, 3, 11, 7, 11, 409, 10, 11, 12, 11, 14, 11, 412, 11, 11, 3, 11, 3, 11,
	3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 421, 10, 12, 3, 13, 3, 13, 3,
	13, 3, 13, 7, 13, 427, 10, 13, 12, 13, 14, 13, 430, 11, 13, 3, 13, 3, 13,
	3, 14, 3, 14, 5, 14, 436, 10, 14, 3, 15, 3, 15, 3, 15, 3, 15, 7, 15, 442,
	10, 15, 12, 15, 14, 15, 445, 11, 15, 3, 15, 3, 15, 3, 16, 3, 16, 3, 17,
	3, 17, 3, 17, 5, 17, 454, 10, 17, 3, 18, 3, 18, 5, 18, 458, 10, 18, 3,
	19, 3, 19, 3, 19, 5, 19, 463, 10, 19, 3, 20, 3, 20, 3, 21, 3, 21, 3, 21,
	6, 21, 470, 10, 21, 13, 21, 14, 21, 471, 3, 21, 3, 21, 3, 22, 3, 22, 3,
	22, 5, 22, 479, 10, 22, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 24, 3, 24,
	6, 24, 488, 10, 24, 13, 24, 14, 24, 489, 3, 24, 3, 24, 3, 25, 3, 25, 3,
	25, 3, 25, 5, 25, 498, 10, 25, 3, 25, 5, 25, 501, 10, 25, 3, 25, 5, 25,
	504, 10, 25, 3, 25, 3, 25, 5, 25, 508, 10, 25, 5, 25, 510, 10, 25, 3, 26,
	3, 26, 3, 26, 3, 26, 5, 26, 516, 10, 26, 3, 26, 3, 26, 3, 27, 3, 27, 6,
	27, 522, 10, 27, 13, 27, 14, 27, 523, 3, 27, 3, 27, 3, 28, 3, 28, 5, 28,
	530, 10, 28, 3, 28, 3, 28, 3, 28, 5, 28, 535, 10, 28, 3, 28, 5, 28, 538,
	10, 28, 5, 28, 540, 10, 28, 3, 29, 3, 29, 3, 30, 7, 30, 545, 10, 30, 12,
	30, 14, 30, 548, 11, 30, 3, 30, 3, 30, 3, 30, 5, 30, 553, 10, 30, 3, 30,
	3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 6, 30, 563, 10, 30, 13,
	30, 14, 30, 564, 3, 30, 5, 30, 568, 10, 30, 3, 31, 7, 31, 571, 10, 31,
	12, 31, 14, 31, 574, 11, 31, 3, 31, 3, 31, 3, 31, 5, 31, 579, 10, 31, 3,
	31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 6, 31, 588, 10, 31, 13, 31,
	14, 31, 589, 3, 31, 5, 31, 593, 10, 31, 3, 32, 3, 32, 3, 33, 3, 33, 3,
	33, 3, 34, 3, 34, 7, 34, 602, 10, 34, 12, 34, 14, 34, 605, 11, 34, 3, 35,
	3, 35, 5, 35, 609, 10, 35, 3, 35, 5, 35, 612, 10, 35, 3, 36, 3, 36, 3,
	36, 3, 37, 3, 37, 3, 37, 3, 37, 5, 37, 621, 10, 37, 6, 37, 623, 10, 37,
	13, 37, 14, 37, 624, 3, 37, 3, 37, 3, 38, 3, 38, 3, 38, 5, 38, 632, 10,
	38, 3, 39, 7, 39, 635, 10, 39, 12, 39, 14, 39, 638, 11, 39, 3, 39, 3, 39,
	3, 39, 3, 39, 6, 39, 644, 10, 39, 13, 39, 14, 39, 645, 3, 39, 3, 39, 3,
	40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 41, 3, 41, 3, 41, 3, 41, 3, 42,
	3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 665, 10, 42, 3, 42, 5, 42, 668, 10,
	42, 3, 43, 3, 43, 3, 43, 3, 43, 7, 43, 674, 10, 43, 12, 43, 14, 43, 677,
	11, 43, 3, 44, 3, 44, 5, 44, 681, 10, 44, 3, 45, 3, 45, 3, 45, 3, 45, 3,
	45, 5, 45, 688, 10, 45, 3, 45, 3, 45, 3, 46, 3, 46, 3, 47, 3, 47, 3, 47,
	5, 47, 697, 10, 47, 3, 48, 3, 48, 6, 48, 701, 10, 48, 13, 48, 14, 48, 702,
	5, 48, 705, 10, 48, 3, 48, 5, 48, 708, 10, 48, 3, 49, 3, 49, 3, 49, 7,
	49, 713, 10, 49, 12, 49, 14, 49, 716, 11, 49, 3, 50, 3, 50, 3, 50, 3, 51,
	3, 51, 3, 52, 3, 52, 3, 53, 3, 53, 6, 53, 727, 10, 53, 13, 53, 14, 53,
	728, 3, 53, 3, 53, 3, 53, 3, 53, 5, 53, 735, 10, 53, 5, 53, 737, 10, 53,
	3, 54, 3, 54, 3, 54, 3, 54, 7, 54, 743, 10, 54, 12, 54, 14, 54, 746, 11,
	54, 3, 54, 3, 54, 3, 55, 3, 55, 3, 55, 3, 55, 5, 55, 754, 10, 55, 3, 55,
	3, 55, 5, 55, 758, 10, 55, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 7, 56, 765,
	10, 56, 12, 56, 14, 56, 768, 11, 56, 3, 56, 3, 56, 3, 57, 3, 57, 5, 57,
	774, 10, 57, 3, 57, 3, 57, 3, 57, 7, 57, 779, 10, 57, 12, 57, 14, 57, 782,
	11, 57, 3, 57, 3, 57, 3, 58, 3, 58, 7, 58, 788, 10, 58, 12, 58, 14, 58,
	791, 11, 58, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 7, 59, 798, 10, 59, 12,
	59, 14, 59, 801, 11, 59, 3, 59, 3, 59, 3, 60, 3, 60, 3, 61, 3, 61, 3, 61,
	3, 61, 6, 61, 811, 10, 61, 13, 61, 14, 61, 812, 3, 61, 3, 61, 3, 62, 6,
	62, 818, 10, 62, 13, 62, 14, 62, 819, 3, 63, 5, 63, 823, 10, 63, 3, 63,
	3, 63, 3, 63, 6, 63, 828, 10, 63, 13, 63, 14, 63, 829, 3, 63, 3, 63, 3,
	64, 3, 64, 3, 64, 3, 64, 6, 64, 838, 10, 64, 13, 64, 14, 64, 839, 3, 64,
	3, 64, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 5, 65, 849, 10, 65, 3, 65, 5,
	65, 852, 10, 65, 3, 66, 3, 66, 3, 66, 3, 67, 3, 67, 5, 67, 859, 10, 67,
	3, 68, 3, 68, 3, 68, 7, 68, 864, 10, 68, 12, 68, 14, 68, 867, 11, 68, 3,
	69, 3, 69, 3, 69, 3, 69, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70,
	3, 70, 3, 70, 5, 70, 882, 10, 70, 3, 70, 5, 70, 885, 10, 70, 3, 71, 3,
	71, 5, 71, 889, 10, 71, 3, 71, 5, 71, 892, 10, 71, 3, 71, 5, 71, 895, 10,
	71, 3, 71, 3, 71, 3, 71, 6, 71, 900, 10, 71, 13, 71, 14, 71, 901, 3, 71,
	3, 71, 3, 72, 3, 72, 3, 73, 3, 73, 3, 73, 5, 73, 911, 10, 73, 3, 73, 5,
	73, 914, 10, 73, 3, 73, 5, 73, 917, 10, 73, 3, 73, 3, 73, 3, 73, 3, 73,
	6, 73, 923, 10, 73, 13, 73, 14, 73, 924, 3, 73, 3, 73, 5, 73, 929, 10,
	73, 5, 73, 931, 10, 73, 3, 74, 3, 74, 5, 74, 935, 10, 74, 3, 74, 3, 74,
	3, 74, 3, 74, 6, 74, 941, 10, 74, 13, 74, 14, 74, 942, 3, 74, 3, 74, 3,
	75, 3, 75, 3, 75, 3, 75, 5, 75, 951, 10, 75, 3, 76, 3, 76, 3, 76, 3, 76,
	7, 76, 957, 10, 76, 12, 76, 14, 76, 960, 11, 76, 3, 77, 3, 77, 3, 77, 3,
	77, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 5, 78, 971, 10, 78, 3, 79, 3, 79,
	6, 79, 975, 10, 79, 13, 79, 14, 79, 976, 3, 79, 5, 79, 980, 10, 79, 3,
	80, 3, 80, 3, 80, 3, 81, 3, 81, 3, 82, 3, 82, 3, 83, 3, 83, 3, 83, 3, 83,
	3, 83, 3, 83, 3, 84, 3, 84, 3, 85, 3, 85, 3, 85, 3, 85, 5, 85, 1001, 10,
	85, 3, 85, 3, 85, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 6, 86, 1010, 10, 86,
	13, 86, 14, 86, 1011, 3, 86, 3, 86, 5, 86, 1016, 10, 86, 3, 87, 3, 87,
	3, 87, 5, 87, 1021, 10, 87, 3, 87, 5, 87, 1024, 10, 87, 3, 87, 3, 87, 3,
	87, 3, 87, 6, 87, 1030, 10, 87, 13, 87, 14, 87, 1031, 3, 87, 3, 87, 5,
	87, 1036, 10, 87, 3, 88, 3, 88, 3, 88, 3, 88, 5, 88, 1042, 10, 88, 3, 88,
	3, 88, 3, 88, 3, 88, 6, 88, 1048, 10, 88, 13, 88, 14, 88, 1049, 3, 88,
	3, 88, 5, 88, 1054, 10, 88, 3, 89, 3, 89, 5, 89, 1058, 10, 89, 3, 90, 3,
	90, 3, 91, 3, 91, 5, 91, 1064, 10, 91, 3, 91, 3, 91, 3, 92, 3, 92, 3, 93,
	3, 93, 3, 93, 7, 93, 1073, 10, 93, 12, 93, 14, 93, 1076, 11, 93, 3, 94,
	3, 94, 3, 94, 5, 94, 1081, 10, 94, 3, 94, 3, 94, 3, 95, 3, 95, 5, 95, 1087,
	10, 95, 3, 96, 3, 96, 3, 96, 7, 96, 1092, 10, 96, 12, 96, 14, 96, 1095,
	11, 96, 3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 5, 97, 1102, 10, 97, 3, 97,
	3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 3, 98, 3, 98, 3, 98, 5, 98, 1113, 10,
	98, 3, 98, 3, 98, 3, 98, 3, 99, 3, 99, 3, 99, 3, 100, 3, 100, 5, 100, 1123,
	10, 100, 3, 101, 3, 101, 3, 101, 3, 101, 3, 101, 5, 101, 1130, 10, 101,
	3, 101, 3, 101, 3, 101, 3, 102, 3, 102, 3, 103, 3, 103, 3, 103, 5, 103,
	1140, 10, 103, 3, 103, 3, 103, 3, 103, 3, 104, 3, 104, 3, 104, 3, 104,
	3, 104, 3, 105, 3, 105, 3, 106, 3, 106, 3, 107, 3, 107, 3, 108, 5, 108,
	1157, 10, 108, 3, 108, 3, 108, 3, 109, 5, 109, 1162, 10, 109, 3, 109, 3,
	109, 5, 109, 1166, 10, 109, 3, 109, 3, 109, 3, 109, 5, 109, 1171, 10, 109,
	3, 110, 3, 110, 3, 110, 3, 110, 5, 110, 1177, 10, 110, 3, 111, 3, 111,
	3, 111, 3, 111, 7, 111, 1183, 10, 111, 12, 111, 14, 111, 1186, 11, 111,
	3, 111, 3, 111, 3, 112, 5, 112, 1191, 10, 112, 3, 112, 3, 112, 5, 112,
	1195, 10, 112, 3, 112, 3, 112, 3, 112, 3, 113, 3, 113, 3, 113, 3, 113,
	3, 113, 3, 113, 3, 113, 3, 113, 3, 113, 3, 113, 3, 113, 5, 113, 1211, 10,
	113, 3, 114, 3, 114, 3, 115, 3, 115, 3, 115, 7, 115, 1218, 10, 115, 12,
	115, 14, 115, 1221, 11, 115, 3, 116, 3, 116, 3, 116, 3, 116, 3, 117, 3,
	117, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3,
	118, 3, 118, 3, 118, 5, 118, 1240, 10, 118, 3, 119, 3, 119, 3, 119, 3,
	119, 5, 119, 1246, 10, 119, 3, 120, 3, 120, 3, 121, 3, 121, 3, 121, 3,
	121, 3, 122, 3, 122, 3, 122, 3, 122, 3, 123, 3, 123, 3, 123, 3, 123, 3,
	123, 3, 123, 3, 123, 3, 123, 5, 123, 1266, 10, 123, 3, 124, 3, 124, 7,
	124, 1270, 10, 124, 12, 124, 14, 124, 1273, 11, 124, 3, 125, 3, 125, 3,
	125, 3, 126, 3, 126, 5, 126, 1280, 10, 126, 3, 127, 5, 127, 1283, 10, 127,
	3, 127, 3, 127, 3, 128, 3, 128, 3, 128, 3, 129, 3, 129, 7, 129, 1292, 10,
	129, 12, 129, 14, 129, 1295, 11, 129, 3, 130, 3, 130, 3, 130, 3, 131, 3,
	131, 7, 131, 1302, 10, 131, 12, 131, 14, 131, 1305, 11, 131, 3, 132, 3,
	132, 3, 133, 3, 133, 3, 133, 3, 133, 7, 133, 1313, 10, 133, 12, 133, 14,
	133, 1316, 11, 133, 3, 134, 3, 134, 3, 134, 7, 134, 1321, 10, 134, 12,
	134, 14, 134, 1324, 11, 134, 3, 135, 3, 135, 3, 135, 7, 135, 1329, 10,
	135, 12, 135, 14, 135, 1332, 11, 135, 3, 136, 3, 136, 3, 136, 7, 136, 1337,
	10, 136, 12, 136, 14, 136, 1340, 11, 136, 3, 137, 3, 137, 3, 137, 7, 137,
	1345, 10, 137, 12, 137, 14, 137, 1348, 11, 137, 3, 138, 3, 138, 3, 138,
	7, 138, 1353, 10, 138, 12, 138, 14, 138, 1356, 11, 138, 3, 139, 3, 139,
	3, 139, 7, 139, 1361, 10, 139, 12, 139, 14, 139, 1364, 11, 139, 3, 140,
	3, 140, 3, 140, 7, 140, 1369, 10, 140, 12, 140, 14, 140, 1372, 11, 140,
	3, 141, 3, 141, 5, 141, 1376, 10, 141, 3, 141, 3, 141, 3, 141, 3, 141,
	3, 141, 3, 142, 3, 142, 3, 142, 3, 143, 3, 143, 3, 144, 3, 144, 3, 144,
	7, 144, 1391, 10, 144, 12, 144, 14, 144, 1394, 11, 144, 3, 145, 3, 145,
	3, 145, 3, 145, 3, 145, 5, 145, 1401, 10, 145, 3, 146, 3, 146, 3, 146,
	3, 146, 5, 146, 1407, 10, 146, 3, 147, 3, 147, 3, 147, 3, 148, 5, 148,
	1413, 10, 148, 3, 148, 3, 148, 3, 148, 3, 148, 6, 148, 1419, 10, 148, 13,
	148, 14, 148, 1420, 3, 148, 5, 148, 1424, 10, 148, 3, 148, 3, 148, 3, 149,
	3, 149, 3, 149, 3, 149, 3, 149, 5, 149, 1433, 10, 149, 3, 150, 3, 150,
	3, 150, 3, 150, 5, 150, 1439, 10, 150, 3, 151, 3, 151, 3, 151, 3, 151,
	3, 151, 3, 151, 3, 151, 5, 151, 1448, 10, 151, 3, 152, 3, 152, 3, 152,
	3, 152, 3, 153, 3, 153, 3, 153, 3, 153, 3, 153, 3, 154, 3, 154, 3, 154,
	3, 154, 3, 154, 3, 155, 3, 155, 3, 156, 3, 156, 3, 157, 3, 157, 3, 157,
	3, 157, 3, 157, 3, 157, 3, 157, 3, 157, 3, 157, 5, 157, 1477, 10, 157,
	3, 157, 3, 157, 5, 157, 1481, 10, 157, 3, 158, 3, 158, 3, 158, 3, 158,
	3, 158, 3, 159, 3, 159, 3, 159, 5, 159, 1491, 10, 159, 3, 160, 3, 160,
	5, 160, 1495, 10, 160, 3, 161, 3, 161, 3, 162, 3, 162, 3, 163, 3, 163,
	3, 164, 5, 164, 1504, 10, 164, 3, 164, 3, 164, 3, 164, 3, 164, 3, 164,
	5, 164, 1511, 10, 164, 3, 164, 3, 164, 5, 164, 1515, 10, 164, 3, 164, 3,
	164, 3, 164, 3, 164, 6, 164, 1521, 10, 164, 13, 164, 14, 164, 1522, 3,
	164, 3, 164, 3, 164, 3, 164, 3, 165, 3, 165, 3, 165, 3, 165, 3, 166, 3,
	166, 3, 166, 3, 166, 3, 167, 3, 167, 3, 167, 7, 167, 1540, 10, 167, 12,
	167, 14, 167, 1543, 11, 167, 3, 168, 3, 168, 3, 169, 3, 169, 3, 169, 3,
	169, 3, 169, 3, 169, 3, 169, 5, 169, 1554, 10, 169, 3, 169, 5, 169, 1557,
	10, 169, 3, 169, 3, 169, 3, 169, 3, 169, 3, 169, 5, 169, 1564, 10, 169,
	3, 170, 3, 170, 3, 170, 3, 170, 3, 170, 3, 170, 3, 170, 3, 170, 3, 170,
	3, 170, 3, 170, 3, 170, 3, 170, 3, 170, 3, 170, 6, 170, 1581, 10, 170,
	13, 170, 14, 170, 1582, 3, 170, 3, 170, 5, 170, 1587, 10, 170, 3, 171,
	7, 171, 1590, 10, 171, 12, 171, 14, 171, 1593, 11, 171, 3, 171, 3, 171,
	3, 171, 3, 171, 3, 172, 5, 172, 1600, 10, 172, 3, 172, 3, 172, 3, 172,
	7, 172, 1605, 10, 172, 12, 172, 14, 172, 1608, 11, 172, 3, 173, 3, 173,
	7, 173, 1612, 10, 173, 12, 173, 14, 173, 1615, 11, 173, 3, 174, 6, 174,
	1618, 10, 174, 13, 174, 14, 174, 1619, 3, 175, 5, 175, 1623, 10, 175, 3,
	175, 6, 175, 1626, 10, 175, 13, 175, 14, 175, 1627, 3, 175, 3, 175, 3,
	175, 2, 2, 176, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30,
	32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66,
	68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102,
	104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132,
	134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162,
	164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192,
	194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222,
	224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252,
	254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282,
	284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312,
	314, 316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342,
	344, 346, 348, 2, 19, 4, 2, 60, 61, 136, 136, 4, 2, 41, 41, 137, 137, 3,
	2, 8, 9, 3, 2, 8, 10, 4, 2, 15, 17, 19, 21, 4, 2, 57, 57, 60, 61, 4, 2,
	115, 117, 132, 134, 4, 2, 85, 85, 137, 137, 5, 2, 5, 5, 131, 131, 136,
	136, 3, 2, 120, 121, 4, 2, 127, 127, 129, 129, 4, 2, 73, 73, 136, 137,
	5, 2, 94, 94, 97, 97, 99, 100, 4, 2, 95, 96, 108, 108, 4, 2, 94, 94, 97,
	97, 4, 2, 76, 77, 80, 81, 4, 2, 104, 104, 106, 106, 2, 1692, 2, 350, 3,
	2, 2, 2, 4, 359, 3, 2, 2, 2, 6, 367, 3, 2, 2, 2, 8, 375, 3, 2, 2, 2, 10,
	379, 3, 2, 2, 2, 12, 381, 3, 2, 2, 2, 14, 388, 3, 2, 2, 2, 16, 391, 3,
	2, 2, 2, 18, 393, 3, 2, 2, 2, 20, 404, 3, 2, 2, 2, 22, 415, 3, 2, 2, 2,
	24, 422, 3, 2, 2, 2, 26, 435, 3, 2, 2, 2, 28, 437, 3, 2, 2, 2, 30, 448,
	3, 2, 2, 2, 32, 453, 3, 2, 2, 2, 34, 457, 3, 2, 2, 2, 36, 459, 3, 2, 2,
	2, 38, 464, 3, 2, 2, 2, 40, 466, 3, 2, 2, 2, 42, 478, 3, 2, 2, 2, 44, 480,
	3, 2, 2, 2, 46, 485, 3, 2, 2, 2, 48, 509, 3, 2, 2, 2, 50, 511, 3, 2, 2,
	2, 52, 519, 3, 2, 2, 2, 54, 527, 3, 2, 2, 2, 56, 541, 3, 2, 2, 2, 58, 546,
	3, 2, 2, 2, 60, 572, 3, 2, 2, 2, 62, 594, 3, 2, 2, 2, 64, 596, 3, 2, 2,
	2, 66, 599, 3, 2, 2, 2, 68, 606, 3, 2, 2, 2, 70, 613, 3, 2, 2, 2, 72, 616,
	3, 2, 2, 2, 74, 628, 3, 2, 2, 2, 76, 636, 3, 2, 2, 2, 78, 649, 3, 2, 2,
	2, 80, 655, 3, 2, 2, 2, 82, 659, 3, 2, 2, 2, 84, 669, 3, 2, 2, 2, 86, 680,
	3, 2, 2, 2, 88, 682, 3, 2, 2, 2, 90, 691, 3, 2, 2, 2, 92, 693, 3, 2, 2,
	2, 94, 704, 3, 2, 2, 2, 96, 709, 3, 2, 2, 2, 98, 717, 3, 2, 2, 2, 100,
	720, 3, 2, 2, 2, 102, 722, 3, 2, 2, 2, 104, 736, 3, 2, 2, 2, 106, 738,
	3, 2, 2, 2, 108, 753, 3, 2, 2, 2, 110, 759, 3, 2, 2, 2, 112, 771, 3, 2,
	2, 2, 114, 785, 3, 2, 2, 2, 116, 792, 3, 2, 2, 2, 118, 804, 3, 2, 2, 2,
	120, 806, 3, 2, 2, 2, 122, 817, 3, 2, 2, 2, 124, 822, 3, 2, 2, 2, 126,
	833, 3, 2, 2, 2, 128, 851, 3, 2, 2, 2, 130, 853, 3, 2, 2, 2, 132, 858,
	3, 2, 2, 2, 134, 860, 3, 2, 2, 2, 136, 868, 3, 2, 2, 2, 138, 881, 3, 2,
	2, 2, 140, 886, 3, 2, 2, 2, 142, 905, 3, 2, 2, 2, 144, 930, 3, 2, 2, 2,
	146, 932, 3, 2, 2, 2, 148, 946, 3, 2, 2, 2, 150, 952, 3, 2, 2, 2, 152,
	961, 3, 2, 2, 2, 154, 970, 3, 2, 2, 2, 156, 974, 3, 2, 2, 2, 158, 981,
	3, 2, 2, 2, 160, 984, 3, 2, 2, 2, 162, 986, 3, 2, 2, 2, 164, 988, 3, 2,
	2, 2, 166, 994, 3, 2, 2, 2, 168, 1000, 3, 2, 2, 2, 170, 1004, 3, 2, 2,
	2, 172, 1017, 3, 2, 2, 2, 174, 1037, 3, 2, 2, 2, 176, 1057, 3, 2, 2, 2,
	178, 1059, 3, 2, 2, 2, 180, 1061, 3, 2, 2, 2, 182, 1067, 3, 2, 2, 2, 184,
	1069, 3, 2, 2, 2, 186, 1077, 3, 2, 2, 2, 188, 1084, 3, 2, 2, 2, 190, 1088,
	3, 2, 2, 2, 192, 1096, 3, 2, 2, 2, 194, 1109, 3, 2, 2, 2, 196, 1117, 3,
	2, 2, 2, 198, 1122, 3, 2, 2, 2, 200, 1124, 3, 2, 2, 2, 202, 1134, 3, 2,
	2, 2, 204, 1136, 3, 2, 2, 2, 206, 1144, 3, 2, 2, 2, 208, 1149, 3, 2, 2,
	2, 210, 1151, 3, 2, 2, 2, 212, 1153, 3, 2, 2, 2, 214, 1156, 3, 2, 2, 2,
	216, 1161, 3, 2, 2, 2, 218, 1176, 3, 2, 2, 2, 220, 1178, 3, 2, 2, 2, 222,
	1190, 3, 2, 2, 2, 224, 1210, 3, 2, 2, 2, 226, 1212, 3, 2, 2, 2, 228, 1214,
	3, 2, 2, 2, 230, 1222, 3, 2, 2, 2, 232, 1226, 3, 2, 2, 2, 234, 1228, 3,
	2, 2, 2, 236, 1245, 3, 2, 2, 2, 238, 1247, 3, 2, 2, 2, 240, 1249, 3, 2,
	2, 2, 242, 1253, 3, 2, 2, 2, 244, 1265, 3, 2, 2, 2, 246, 1267, 3, 2, 2,
	2, 248, 1274, 3, 2, 2, 2, 250, 1277, 3, 2, 2, 2, 252, 1282, 3, 2, 2, 2,
	254, 1286, 3, 2, 2, 2, 256, 1289, 3, 2, 2, 2, 258, 1296, 3, 2, 2, 2, 260,
	1299, 3, 2, 2, 2, 262, 1306, 3, 2, 2, 2, 264, 1308, 3, 2, 2, 2, 266, 1317,
	3, 2, 2, 2, 268, 1325, 3, 2, 2, 2, 270, 1333, 3, 2, 2, 2, 272, 1341, 3,
	2, 2, 2, 274, 1349, 3, 2, 2, 2, 276, 1357, 3, 2, 2, 2, 278, 1365, 3, 2,
	2, 2, 280, 1373, 3, 2, 2, 2, 282, 1382, 3, 2, 2, 2, 284, 1385, 3, 2, 2,
	2, 286, 1387, 3, 2, 2, 2, 288, 1395, 3, 2, 2, 2, 290, 1402, 3, 2, 2, 2,
	292, 1408, 3, 2, 2, 2, 294, 1412, 3, 2, 2, 2, 296, 1427, 3, 2, 2, 2, 298,
	1438, 3, 2, 2, 2, 300, 1440, 3, 2, 2, 2, 302, 1449, 3, 2, 2, 2, 304, 1453,
	3, 2, 2, 2, 306, 1458, 3, 2, 2, 2, 308, 1463, 3, 2, 2, 2, 310, 1465, 3,
	2, 2, 2, 312, 1476, 3, 2, 2, 2, 314, 1482, 3, 2, 2, 2, 316, 1490, 3, 2,
	2, 2, 318, 1494, 3, 2, 2, 2, 320, 1496, 3, 2, 2, 2, 322, 1498, 3, 2, 2,
	2, 324, 1500, 3, 2, 2, 2, 326, 1503, 3, 2, 2, 2, 328, 1528, 3, 2, 2, 2,
	330, 1532, 3, 2, 2, 2, 332, 1536, 3, 2, 2, 2, 334, 1544, 3, 2, 2, 2, 336,
	1546, 3, 2, 2, 2, 338, 1565, 3, 2, 2, 2, 340, 1591, 3, 2, 2, 2, 342, 1599,
	3, 2, 2, 2, 344, 1609, 3, 2, 2, 2, 346, 1617, 3, 2, 2, 2, 348, 1622, 3,
	2, 2, 2, 350, 351, 7, 36, 2, 2, 351, 356, 7, 61, 2, 2, 352, 353, 7, 34,
	2, 2, 353, 355, 7, 61, 2, 2, 354, 352, 3, 2, 2, 2, 355, 358, 3, 2, 2, 2,
	356, 354, 3, 2, 2, 2, 356, 357, 3, 2, 2, 2, 357, 3, 3, 2, 2, 2, 358, 356,
	3, 2, 2, 2, 359, 360, 7, 49, 2, 2, 360, 363, 7, 56, 2, 2, 361, 362, 7,
	41, 2, 2, 362, 364, 7, 56, 2, 2, 363, 361, 3, 2, 2, 2, 363, 364, 3, 2,
	2, 2, 364, 365, 3, 2, 2, 2, 365, 366, 7, 50, 2, 2, 366, 5, 3, 2, 2, 2,
	367, 372, 5, 2, 2, 2, 368, 369, 7, 37, 2, 2, 369, 371, 5, 2, 2, 2, 370,
	368, 3, 2, 2, 2, 371, 374, 3, 2, 2, 2, 372, 370, 3, 2, 2, 2, 372, 373,
	3, 2, 2, 2, 373, 7, 3, 2, 2, 2, 374, 372, 3, 2, 2, 2, 375, 376, 7, 45,
	2, 2, 376, 377, 5, 6, 4, 2, 377, 378, 7, 46, 2, 2, 378, 9, 3, 2, 2, 2,
	379, 380, 9, 2, 2, 2, 380, 11, 3, 2, 2, 2, 381, 384, 5, 66, 34, 2, 382,
	383, 9, 3, 2, 2, 383, 385, 5, 10, 6, 2, 384, 382, 3, 2, 2, 2, 385, 386,
	3, 2, 2, 2, 386, 384, 3, 2, 2, 2, 386, 387, 3, 2, 2, 2, 387, 13, 3, 2,
	2, 2, 388, 389, 7, 53, 2, 2, 389, 390, 7, 68, 2, 2, 390, 15, 3, 2, 2, 2,
	391, 392, 7, 57, 2, 2, 392, 17, 3, 2, 2, 2, 393, 394, 7, 45, 2, 2, 394,
	399, 5, 16, 9, 2, 395, 396, 7, 37, 2, 2, 396, 398, 5, 16, 9, 2, 397, 395,
	3, 2, 2, 2, 398, 401, 3, 2, 2, 2, 399, 397, 3, 2, 2, 2, 399, 400, 3, 2,
	2, 2, 400, 402, 3, 2, 2, 2, 401, 399, 3, 2, 2, 2, 402, 403, 7, 46, 2, 2,
	403, 19, 3, 2, 2, 2, 404, 405, 7, 45, 2, 2, 405, 410, 5, 18, 10, 2, 406,
	407, 7, 37, 2, 2, 407, 409, 5, 18, 10, 2, 408, 406, 3, 2, 2, 2, 409, 412,
	3, 2, 2, 2, 410, 408, 3, 2, 2, 2, 410, 411, 3, 2, 2, 2, 411, 413, 3, 2,
	2, 2, 412, 410, 3, 2, 2, 2, 413, 414, 7, 46, 2, 2, 414, 21, 3, 2, 2, 2,
	415, 416, 7, 61, 2, 2, 416, 420, 7, 38, 2, 2, 417, 421, 5, 16, 9, 2, 418,
	421, 5, 18, 10, 2, 419, 421, 5, 20, 11, 2, 420, 417, 3, 2, 2, 2, 420, 418,
	3, 2, 2, 2, 420, 419, 3, 2, 2, 2, 421, 23, 3, 2, 2, 2, 422, 423, 7, 45,
	2, 2, 423, 428, 5, 22, 12, 2, 424, 425, 7, 37, 2, 2, 425, 427, 5, 22, 12,
	2, 426, 424, 3, 2, 2, 2, 427, 430, 3, 2, 2, 2, 428, 426, 3, 2, 2, 2, 428,
	429, 3, 2, 2, 2, 429, 431, 3, 2, 2, 2, 430, 428, 3, 2, 2, 2, 431, 432,
	7, 46, 2, 2, 432, 25, 3, 2, 2, 2, 433, 436, 5, 22, 12, 2, 434, 436, 5,
	2, 2, 2, 435, 433, 3, 2, 2, 2, 435, 434, 3, 2, 2, 2, 436, 27, 3, 2, 2,
	2, 437, 438, 7, 45, 2, 2, 438, 443, 5, 26, 14, 2, 439, 440, 7, 37, 2, 2,
	440, 442, 5, 26, 14, 2, 441, 439, 3, 2, 2, 2, 442, 445, 3, 2, 2, 2, 443,
	441, 3, 2, 2, 2, 443, 444, 3, 2, 2, 2, 444, 446, 3, 2, 2, 2, 445, 443,
	3, 2, 2, 2, 446, 447, 7, 46, 2, 2, 447, 29, 3, 2, 2, 2, 448, 449, 5, 10,
	6, 2, 449, 31, 3, 2, 2, 2, 450, 454, 5, 30, 16, 2, 451, 454, 5, 12, 7,
	2, 452, 454, 7, 5, 2, 2, 453, 450, 3, 2, 2, 2, 453, 451, 3, 2, 2, 2, 453,
	452, 3, 2, 2, 2, 454, 33, 3, 2, 2, 2, 455, 458, 7, 24, 2, 2, 456, 458,
	7, 119, 2, 2, 457, 455, 3, 2, 2, 2, 457, 456, 3, 2, 2, 2, 458, 35, 3, 2,
	2, 2, 459, 460, 5, 34, 18, 2, 460, 462, 5, 32, 17, 2, 461, 463, 5, 4, 3,
	2, 462, 461, 3, 2, 2, 2, 462, 463, 3, 2, 2, 2, 463, 37, 3, 2, 2, 2, 464,
	465, 5, 36, 19, 2, 465, 39, 3, 2, 2, 2, 466, 467, 7, 40, 2, 2, 467, 469,
	7, 3, 2, 2, 468, 470, 5, 14, 8, 2, 469, 468, 3, 2, 2, 2, 470, 471, 3, 2,
	2, 2, 471, 469, 3, 2, 2, 2, 471, 472, 3, 2, 2, 2, 472, 473, 3, 2, 2, 2,
	473, 474, 7, 4, 2, 2, 474, 41, 3, 2, 2, 2, 475, 479, 7, 57, 2, 2, 476,
	479, 5, 18, 10, 2, 477, 479, 5, 40, 21, 2, 478, 475, 3, 2, 2, 2, 478, 476,
	3, 2, 2, 2, 478, 477, 3, 2, 2, 2, 479, 43, 3, 2, 2, 2, 480, 481, 7, 43,
	2, 2, 481, 482, 7, 70, 2, 2, 482, 483, 7, 38, 2, 2, 483, 484, 5, 42, 22,
	2, 484, 45, 3, 2, 2, 2, 485, 487, 7, 3, 2, 2, 486, 488, 5, 44, 23, 2, 487,
	486, 3, 2, 2, 2, 488, 489, 3, 2, 2, 2, 489, 487, 3, 2, 2, 2, 489, 490,
	3, 2, 2, 2, 490, 491, 3, 2, 2, 2, 491, 492, 7, 4, 2, 2, 492, 47, 3, 2,
	2, 2, 493, 510, 5, 38, 20, 2, 494, 497, 5, 32, 17, 2, 495, 498, 5, 50,
	26, 2, 496, 498, 5, 4, 3, 2, 497, 495, 3, 2, 2, 2, 497, 496, 3, 2, 2, 2,
	497, 498, 3, 2, 2, 2, 498, 500, 3, 2, 2, 2, 499, 501, 7, 42, 2, 2, 500,
	499, 3, 2, 2, 2, 500, 501, 3, 2, 2, 2, 501, 503, 3, 2, 2, 2, 502, 504,
	5, 28, 15, 2, 503, 502, 3, 2, 2, 2, 503, 504, 3, 2, 2, 2, 504, 507, 3,
	2, 2, 2, 505, 506, 7, 40, 2, 2, 506, 508, 5, 46, 24, 2, 507, 505, 3, 2,
	2, 2, 507, 508, 3, 2, 2, 2, 508, 510, 3, 2, 2, 2, 509, 493, 3, 2, 2, 2,
	509, 494, 3, 2, 2, 2, 510, 49, 3, 2, 2, 2, 511, 512, 7, 49, 2, 2, 512,
	513, 7, 56, 2, 2, 513, 515, 7, 23, 2, 2, 514, 516, 7, 56, 2, 2, 515, 514,
	3, 2, 2, 2, 515, 516, 3, 2, 2, 2, 516, 517, 3, 2, 2, 2, 517, 518, 7, 50,
	2, 2, 518, 51, 3, 2, 2, 2, 519, 521, 7, 3, 2, 2, 520, 522, 5, 54, 28, 2,
	521, 520, 3, 2, 2, 2, 522, 523, 3, 2, 2, 2, 523, 521, 3, 2, 2, 2, 523,
	524, 3, 2, 2, 2, 524, 525, 3, 2, 2, 2, 525, 526, 7, 4, 2, 2, 526, 53, 3,
	2, 2, 2, 527, 539, 5, 10, 6, 2, 528, 530, 5, 50, 26, 2, 529, 528, 3, 2,
	2, 2, 529, 530, 3, 2, 2, 2, 530, 531, 3, 2, 2, 2, 531, 534, 7, 30, 2, 2,
	532, 535, 5, 48, 25, 2, 533, 535, 5, 52, 27, 2, 534, 532, 3, 2, 2, 2, 534,
	533, 3, 2, 2, 2, 535, 537, 3, 2, 2, 2, 536, 538, 7, 57, 2, 2, 537, 536,
	3, 2, 2, 2, 537, 538, 3, 2, 2, 2, 538, 540, 3, 2, 2, 2, 539, 529, 3, 2,
	2, 2, 539, 540, 3, 2, 2, 2, 540, 55, 3, 2, 2, 2, 541, 542, 5, 58, 30, 2,
	542, 57, 3, 2, 2, 2, 543, 545, 7, 59, 2, 2, 544, 543, 3, 2, 2, 2, 545,
	548, 3, 2, 2, 2, 546, 544, 3, 2, 2, 2, 546, 547, 3, 2, 2, 2, 547, 549,
	3, 2, 2, 2, 548, 546, 3, 2, 2, 2, 549, 550, 9, 4, 2, 2, 550, 552, 5, 10,
	6, 2, 551, 553, 5, 28, 15, 2, 552, 551, 3, 2, 2, 2, 552, 553, 3, 2, 2,
	2, 553, 554, 3, 2, 2, 2, 554, 567, 7, 40, 2, 2, 555, 568, 7, 22, 2, 2,
	556, 562, 7, 3, 2, 2, 557, 563, 7, 59, 2, 2, 558, 563, 5, 54, 28, 2, 559,
	563, 5, 44, 23, 2, 560, 563, 5, 56, 29, 2, 561, 563, 7, 22, 2, 2, 562,
	557, 3, 2, 2, 2, 562, 558, 3, 2, 2, 2, 562, 559, 3, 2, 2, 2, 562, 560,
	3, 2, 2, 2, 562, 561, 3, 2, 2, 2, 563, 564, 3, 2, 2, 2, 564, 562, 3, 2,
	2, 2, 564, 565, 3, 2, 2, 2, 565, 566, 3, 2, 2, 2, 566, 568, 7, 4, 2, 2,
	567, 555, 3, 2, 2, 2, 567, 556, 3, 2, 2, 2, 568, 59, 3, 2, 2, 2, 569, 571,
	7, 59, 2, 2, 570, 569, 3, 2, 2, 2, 571, 574, 3, 2, 2, 2, 572, 570, 3, 2,
	2, 2, 572, 573, 3, 2, 2, 2, 573, 575, 3, 2, 2, 2, 574, 572, 3, 2, 2, 2,
	575, 576, 7, 10, 2, 2, 576, 578, 5, 10, 6, 2, 577, 579, 5, 28, 15, 2, 578,
	577, 3, 2, 2, 2, 578, 579, 3, 2, 2, 2, 579, 580, 3, 2, 2, 2, 580, 592,
	7, 40, 2, 2, 581, 593, 7, 22, 2, 2, 582, 587, 7, 3, 2, 2, 583, 588, 7,
	59, 2, 2, 584, 588, 5, 30, 16, 2, 585, 588, 5, 44, 23, 2, 586, 588, 7,
	22, 2, 2, 587, 583, 3, 2, 2, 2, 587, 584, 3, 2, 2, 2, 587, 585, 3, 2, 2,
	2, 587, 586, 3, 2, 2, 2, 588, 589, 3, 2, 2, 2, 589, 587, 3, 2, 2, 2, 589,
	590, 3, 2, 2, 2, 590, 591, 3, 2, 2, 2, 591, 593, 7, 4, 2, 2, 592, 581,
	3, 2, 2, 2, 592, 582, 3, 2, 2, 2, 593, 61, 3, 2, 2, 2, 594, 595, 5, 10,
	6, 2, 595, 63, 3, 2, 2, 2, 596, 597, 7, 29, 2, 2, 597, 598, 5, 62, 32,
	2, 598, 65, 3, 2, 2, 2, 599, 603, 5, 62, 32, 2, 600, 602, 5, 64, 33, 2,
	601, 600, 3, 2, 2, 2, 602, 605, 3, 2, 2, 2, 603, 601, 3, 2, 2, 2, 603,
	604, 3, 2, 2, 2, 604, 67, 3, 2, 2, 2, 605, 603, 3, 2, 2, 2, 606, 608, 5,
	66, 34, 2, 607, 609, 7, 57, 2, 2, 608, 607, 3, 2, 2, 2, 608, 609, 3, 2,
	2, 2, 609, 611, 3, 2, 2, 2, 610, 612, 5, 28, 15, 2, 611, 610, 3, 2, 2,
	2, 611, 612, 3, 2, 2, 2, 612, 69, 3, 2, 2, 2, 613, 614, 7, 61, 2, 2, 614,
	615, 7, 40, 2, 2, 615, 71, 3, 2, 2, 2, 616, 617, 7, 40, 2, 2, 617, 622,
	7, 3, 2, 2, 618, 620, 7, 61, 2, 2, 619, 621, 5, 28, 15, 2, 620, 619, 3,
	2, 2, 2, 620, 621, 3, 2, 2, 2, 621, 623, 3, 2, 2, 2, 622, 618, 3, 2, 2,
	2, 623, 624, 3, 2, 2, 2, 624, 622, 3, 2, 2, 2, 624, 625, 3, 2, 2, 2, 625,
	626, 3, 2, 2, 2, 626, 627, 7, 4, 2, 2, 627, 73, 3, 2, 2, 2, 628, 629, 9,
	5, 2, 2, 629, 631, 7, 61, 2, 2, 630, 632, 5, 72, 37, 2, 631, 630, 3, 2,
	2, 2, 631, 632, 3, 2, 2, 2, 632, 75, 3, 2, 2, 2, 633, 635, 7, 59, 2, 2,
	634, 633, 3, 2, 2, 2, 635, 638, 3, 2, 2, 2, 636, 634, 3, 2, 2, 2, 636,
	637, 3, 2, 2, 2, 637, 639, 3, 2, 2, 2, 638, 636, 3, 2, 2, 2, 639, 640,
	7, 7, 2, 2, 640, 641, 5, 70, 36, 2, 641, 643, 7, 3, 2, 2, 642, 644, 5,
	74, 38, 2, 643, 642, 3, 2, 2, 2, 644, 645, 3, 2, 2, 2, 645, 643, 3, 2,
	2, 2, 645, 646, 3, 2, 2, 2, 646, 647, 3, 2, 2, 2, 647, 648, 7, 4, 2, 2,
	648, 77, 3, 2, 2, 2, 649, 650, 7, 43, 2, 2, 650, 651, 7, 61, 2, 2, 651,
	652, 7, 38, 2, 2, 652, 653, 7, 57, 2, 2, 653, 654, 7, 58, 2, 2, 654, 79,
	3, 2, 2, 2, 655, 656, 7, 47, 2, 2, 656, 657, 7, 61, 2, 2, 657, 658, 7,
	48, 2, 2, 658, 81, 3, 2, 2, 2, 659, 660, 7, 61, 2, 2, 660, 664, 7, 38,
	2, 2, 661, 665, 7, 5, 2, 2, 662, 665, 5, 10, 6, 2, 663, 665, 5, 80, 41,
	2, 664, 661, 3, 2, 2, 2, 664, 662, 3, 2, 2, 2, 664, 663, 3, 2, 2, 2, 665,
	667, 3, 2, 2, 2, 666, 668, 7, 42, 2, 2, 667, 666, 3, 2, 2, 2, 667, 668,
	3, 2, 2, 2, 668, 83, 3, 2, 2, 2, 669, 670, 7, 42, 2, 2, 670, 675, 5, 82,
	42, 2, 671, 672, 7, 44, 2, 2, 672, 674, 5, 82, 42, 2, 673, 671, 3, 2, 2,
	2, 674, 677, 3, 2, 2, 2, 675, 673, 3, 2, 2, 2, 675, 676, 3, 2, 2, 2, 676,
	85, 3, 2, 2, 2, 677, 675, 3, 2, 2, 2, 678, 681, 5, 10, 6, 2, 679, 681,
	7, 56, 2, 2, 680, 678, 3, 2, 2, 2, 680, 679, 3, 2, 2, 2, 681, 87, 3, 2,
	2, 2, 682, 683, 7, 47, 2, 2, 683, 684, 5, 86, 44, 2, 684, 687, 7, 30, 2,
	2, 685, 688, 7, 5, 2, 2, 686, 688, 5, 10, 6, 2, 687, 685, 3, 2, 2, 2, 687,
	686, 3, 2, 2, 2, 688, 689, 3, 2, 2, 2, 689, 690, 7, 48, 2, 2, 690, 89,
	3, 2, 2, 2, 691, 692, 5, 86, 44, 2, 692, 91, 3, 2, 2, 2, 693, 696, 7, 39,
	2, 2, 694, 697, 5, 90, 46, 2, 695, 697, 5, 88, 45, 2, 696, 694, 3, 2, 2,
	2, 696, 695, 3, 2, 2, 2, 697, 93, 3, 2, 2, 2, 698, 705, 7, 39, 2, 2, 699,
	701, 5, 92, 47, 2, 700, 699, 3, 2, 2, 2, 701, 702, 3, 2, 2, 2, 702, 700,
	3, 2, 2, 2, 702, 703, 3, 2, 2, 2, 703, 705, 3, 2, 2, 2, 704, 698, 3, 2,
	2, 2, 704, 700, 3, 2, 2, 2, 705, 707, 3, 2, 2, 2, 706, 708, 5, 84, 43,
	2, 707, 706, 3, 2, 2, 2, 707, 708, 3, 2, 2, 2, 708, 95, 3, 2, 2, 2, 709,
	714, 5, 10, 6, 2, 710, 711, 7, 39, 2, 2, 711, 713, 5, 10, 6, 2, 712, 710,
	3, 2, 2, 2, 713, 716, 3, 2, 2, 2, 714, 712, 3, 2, 2, 2, 714, 715, 3, 2,
	2, 2, 715, 97, 3, 2, 2, 2, 716, 714, 3, 2, 2, 2, 717, 718, 7, 13, 2, 2,
	718, 719, 7, 68, 2, 2, 719, 99, 3, 2, 2, 2, 720, 721, 5, 66, 34, 2, 721,
	101, 3, 2, 2, 2, 722, 723, 5, 10, 6, 2, 723, 103, 3, 2, 2, 2, 724, 727,
	7, 57, 2, 2, 725, 727, 5, 10, 6, 2, 726, 724, 3, 2, 2, 2, 726, 725, 3,
	2, 2, 2, 727, 728, 3, 2, 2, 2, 728, 726, 3, 2, 2, 2, 728, 729, 3, 2, 2,
	2, 729, 737, 3, 2, 2, 2, 730, 731, 5, 10, 6, 2, 731, 734, 7, 30, 2, 2,
	732, 735, 5, 10, 6, 2, 733, 735, 7, 5, 2, 2, 734, 732, 3, 2, 2, 2, 734,
	733, 3, 2, 2, 2, 735, 737, 3, 2, 2, 2, 736, 726, 3, 2, 2, 2, 736, 730,
	3, 2, 2, 2, 737, 105, 3, 2, 2, 2, 738, 739, 7, 49, 2, 2, 739, 744, 5, 104,
	53, 2, 740, 741, 7, 37, 2, 2, 741, 743, 5, 104, 53, 2, 742, 740, 3, 2,
	2, 2, 743, 746, 3, 2, 2, 2, 744, 742, 3, 2, 2, 2, 744, 745, 3, 2, 2, 2,
	745, 747, 3, 2, 2, 2, 746, 744, 3, 2, 2, 2, 747, 748, 7, 50, 2, 2, 748,
	107, 3, 2, 2, 2, 749, 754, 7, 28, 2, 2, 750, 751, 5, 100, 51, 2, 751, 752,
	7, 31, 2, 2, 752, 754, 3, 2, 2, 2, 753, 749, 3, 2, 2, 2, 753, 750, 3, 2,
	2, 2, 754, 755, 3, 2, 2, 2, 755, 757, 5, 102, 52, 2, 756, 758, 5, 106,
	54, 2, 757, 756, 3, 2, 2, 2, 757, 758, 3, 2, 2, 2, 758, 109, 3, 2, 2, 2,
	759, 760, 7, 14, 2, 2, 760, 761, 7, 64, 2, 2, 761, 762, 7, 40, 2, 2, 762,
	766, 7, 3, 2, 2, 763, 765, 5, 138, 70, 2, 764, 763, 3, 2, 2, 2, 765, 768,
	3, 2, 2, 2, 766, 764, 3, 2, 2, 2, 766, 767, 3, 2, 2, 2, 767, 769, 3, 2,
	2, 2, 768, 766, 3, 2, 2, 2, 769, 770, 7, 4, 2, 2, 770, 111, 3, 2, 2, 2,
	771, 773, 7, 18, 2, 2, 772, 774, 7, 64, 2, 2, 773, 772, 3, 2, 2, 2, 773,
	774, 3, 2, 2, 2, 774, 775, 3, 2, 2, 2, 775, 776, 7, 40, 2, 2, 776, 780,
	7, 3, 2, 2, 777, 779, 5, 138, 70, 2, 778, 777, 3, 2, 2, 2, 779, 782, 3,
	2, 2, 2, 780, 778, 3, 2, 2, 2, 780, 781, 3, 2, 2, 2, 781, 783, 3, 2, 2,
	2, 782, 780, 3, 2, 2, 2, 783, 784, 7, 4, 2, 2, 784, 113, 3, 2, 2, 2, 785,
	789, 5, 110, 56, 2, 786, 788, 5, 112, 57, 2, 787, 786, 3, 2, 2, 2, 788,
	791, 3, 2, 2, 2, 789, 787, 3, 2, 2, 2, 789, 790, 3, 2, 2, 2, 790, 115,
	3, 2, 2, 2, 791, 789, 3, 2, 2, 2, 792, 793, 9, 6, 2, 2, 793, 794, 7, 64,
	2, 2, 794, 795, 7, 40, 2, 2, 795, 799, 7, 3, 2, 2, 796, 798, 5, 138, 70,
	2, 797, 796, 3, 2, 2, 2, 798, 801, 3, 2, 2, 2, 799, 797, 3, 2, 2, 2, 799,
	800, 3, 2, 2, 2, 800, 802, 3, 2, 2, 2, 801, 799, 3, 2, 2, 2, 802, 803,
	7, 4, 2, 2, 803, 117, 3, 2, 2, 2, 804, 805, 7, 59, 2, 2, 805, 119, 3, 2,
	2, 2, 806, 807, 5, 10, 6, 2, 807, 808, 7, 40, 2, 2, 808, 810, 7, 3, 2,
	2, 809, 811, 5, 138, 70, 2, 810, 809, 3, 2, 2, 2, 811, 812, 3, 2, 2, 2,
	812, 810, 3, 2, 2, 2, 812, 813, 3, 2, 2, 2, 813, 814, 3, 2, 2, 2, 814,
	815, 7, 4, 2, 2, 815, 121, 3, 2, 2, 2, 816, 818, 9, 7, 2, 2, 817, 816,
	3, 2, 2, 2, 818, 819, 3, 2, 2, 2, 819, 817, 3, 2, 2, 2, 819, 820, 3, 2,
	2, 2, 820, 123, 3, 2, 2, 2, 821, 823, 5, 122, 62, 2, 822, 821, 3, 2, 2,
	2, 822, 823, 3, 2, 2, 2, 823, 824, 3, 2, 2, 2, 824, 825, 7, 40, 2, 2, 825,
	827, 7, 3, 2, 2, 826, 828, 5, 138, 70, 2, 827, 826, 3, 2, 2, 2, 828, 829,
	3, 2, 2, 2, 829, 827, 3, 2, 2, 2, 829, 830, 3, 2, 2, 2, 830, 831, 3, 2,
	2, 2, 831, 832, 7, 4, 2, 2, 832, 125, 3, 2, 2, 2, 833, 834, 7, 25, 2, 2,
	834, 835, 7, 40, 2, 2, 835, 837, 7, 3, 2, 2, 836, 838, 5, 124, 63, 2, 837,
	836, 3, 2, 2, 2, 838, 839, 3, 2, 2, 2, 839, 837, 3, 2, 2, 2, 839, 840,
	3, 2, 2, 2, 840, 841, 3, 2, 2, 2, 841, 842, 7, 4, 2, 2, 842, 127, 3, 2,
	2, 2, 843, 852, 5, 14, 8, 2, 844, 852, 7, 57, 2, 2, 845, 848, 5, 66, 34,
	2, 846, 847, 7, 32, 2, 2, 847, 849, 5, 10, 6, 2, 848, 846, 3, 2, 2, 2,
	848, 849, 3, 2, 2, 2, 849, 852, 3, 2, 2, 2, 850, 852, 7, 22, 2, 2, 851,
	843, 3, 2, 2, 2, 851, 844, 3, 2, 2, 2, 851, 845, 3, 2, 2, 2, 851, 850,
	3, 2, 2, 2, 852, 129, 3, 2, 2, 2, 853, 854, 7, 26, 2, 2, 854, 855, 5, 66,
	34, 2, 855, 131, 3, 2, 2, 2, 856, 859, 5, 12, 7, 2, 857, 859, 5, 54, 28,
	2, 858, 856, 3, 2, 2, 2, 858, 857, 3, 2, 2, 2, 859, 133, 3, 2, 2, 2, 860,
	865, 5, 132, 67, 2, 861, 862, 7, 37, 2, 2, 862, 864, 5, 132, 67, 2, 863,
	861, 3, 2, 2, 2, 864, 867, 3, 2, 2, 2, 865, 863, 3, 2, 2, 2, 865, 866,
	3, 2, 2, 2, 866, 135, 3, 2, 2, 2, 867, 865, 3, 2, 2, 2, 868, 869, 7, 49,
	2, 2, 869, 870, 5, 134, 68, 2, 870, 871, 7, 50, 2, 2, 871, 137, 3, 2, 2,
	2, 872, 882, 5, 114, 58, 2, 873, 882, 5, 116, 59, 2, 874, 882, 5, 98, 50,
	2, 875, 882, 5, 108, 55, 2, 876, 882, 5, 126, 64, 2, 877, 882, 5, 118,
	60, 2, 878, 882, 5, 120, 61, 2, 879, 882, 5, 128, 65, 2, 880, 882, 5, 44,
	23, 2, 881, 872, 3, 2, 2, 2, 881, 873, 3, 2, 2, 2, 881, 874, 3, 2, 2, 2,
	881, 875, 3, 2, 2, 2, 881, 876, 3, 2, 2, 2, 881, 877, 3, 2, 2, 2, 881,
	878, 3, 2, 2, 2, 881, 879, 3, 2, 2, 2, 881, 880, 3, 2, 2, 2, 882, 884,
	3, 2, 2, 2, 883, 885, 5, 28, 15, 2, 884, 883, 3, 2, 2, 2, 884, 885, 3,
	2, 2, 2, 885, 139, 3, 2, 2, 2, 886, 888, 7, 6, 2, 2, 887, 889, 5, 84, 43,
	2, 888, 887, 3, 2, 2, 2, 888, 889, 3, 2, 2, 2, 889, 891, 3, 2, 2, 2, 890,
	892, 5, 136, 69, 2, 891, 890, 3, 2, 2, 2, 891, 892, 3, 2, 2, 2, 892, 894,
	3, 2, 2, 2, 893, 895, 5, 28, 15, 2, 894, 893, 3, 2, 2, 2, 894, 895, 3,
	2, 2, 2, 895, 896, 3, 2, 2, 2, 896, 897, 7, 40, 2, 2, 897, 899, 7, 3, 2,
	2, 898, 900, 5, 138, 70, 2, 899, 898, 3, 2, 2, 2, 900, 901, 3, 2, 2, 2,
	901, 899, 3, 2, 2, 2, 901, 902, 3, 2, 2, 2, 902, 903, 3, 2, 2, 2, 903,
	904, 7, 4, 2, 2, 904, 141, 3, 2, 2, 2, 905, 906, 7, 22, 2, 2, 906, 143,
	3, 2, 2, 2, 907, 931, 7, 22, 2, 2, 908, 910, 5, 96, 49, 2, 909, 911, 7,
	57, 2, 2, 910, 909, 3, 2, 2, 2, 910, 911, 3, 2, 2, 2, 911, 913, 3, 2, 2,
	2, 912, 914, 5, 136, 69, 2, 913, 912, 3, 2, 2, 2, 913, 914, 3, 2, 2, 2,
	914, 916, 3, 2, 2, 2, 915, 917, 5, 28, 15, 2, 916, 915, 3, 2, 2, 2, 916,
	917, 3, 2, 2, 2, 917, 918, 3, 2, 2, 2, 918, 928, 7, 40, 2, 2, 919, 929,
	5, 142, 72, 2, 920, 922, 7, 3, 2, 2, 921, 923, 5, 138, 70, 2, 922, 921,
	3, 2, 2, 2, 923, 924, 3, 2, 2, 2, 924, 922, 3, 2, 2, 2, 924, 925, 3, 2,
	2, 2, 925, 926, 3, 2, 2, 2, 926, 927, 7, 4, 2, 2, 927, 929, 3, 2, 2, 2,
	928, 919, 3, 2, 2, 2, 928, 920, 3, 2, 2, 2, 929, 931, 3, 2, 2, 2, 930,
	907, 3, 2, 2, 2, 930, 908, 3, 2, 2, 2, 931, 145, 3, 2, 2, 2, 932, 934,
	5, 94, 48, 2, 933, 935, 5, 28, 15, 2, 934, 933, 3, 2, 2, 2, 934, 935, 3,
	2, 2, 2, 935, 936, 3, 2, 2, 2, 936, 937, 7, 40, 2, 2, 937, 940, 7, 3, 2,
	2, 938, 941, 5, 140, 71, 2, 939, 941, 5, 146, 74, 2, 940, 938, 3, 2, 2,
	2, 940, 939, 3, 2, 2, 2, 941, 942, 3, 2, 2, 2, 942, 940, 3, 2, 2, 2, 942,
	943, 3, 2, 2, 2, 943, 944, 3, 2, 2, 2, 944, 945, 7, 4, 2, 2, 945, 147,
	3, 2, 2, 2, 946, 947, 5, 10, 6, 2, 947, 950, 7, 38, 2, 2, 948, 951, 7,
	5, 2, 2, 949, 951, 5, 10, 6, 2, 950, 948, 3, 2, 2, 2, 950, 949, 3, 2, 2,
	2, 951, 149, 3, 2, 2, 2, 952, 953, 7, 42, 2, 2, 953, 958, 5, 148, 75, 2,
	954, 955, 7, 44, 2, 2, 955, 957, 5, 148, 75, 2, 956, 954, 3, 2, 2, 2, 957,
	960, 3, 2, 2, 2, 958, 956, 3, 2, 2, 2, 958, 959, 3, 2, 2, 2, 959, 151,
	3, 2, 2, 2, 960, 958, 3, 2, 2, 2, 961, 962, 5, 100, 51, 2, 962, 963, 7,
	31, 2, 2, 963, 964, 5, 102, 52, 2, 964, 153, 3, 2, 2, 2, 965, 971, 5, 10,
	6, 2, 966, 967, 7, 47, 2, 2, 967, 968, 5, 10, 6, 2, 968, 969, 7, 48, 2,
	2, 969, 971, 3, 2, 2, 2, 970, 965, 3, 2, 2, 2, 970, 966, 3, 2, 2, 2, 971,
	155, 3, 2, 2, 2, 972, 973, 7, 39, 2, 2, 973, 975, 5, 154, 78, 2, 974, 972,
	3, 2, 2, 2, 975, 976, 3, 2, 2, 2, 976, 974, 3, 2, 2, 2, 976, 977, 3, 2,
	2, 2, 977, 979, 3, 2, 2, 2, 978, 980, 5, 150, 76, 2, 979, 978, 3, 2, 2,
	2, 979, 980, 3, 2, 2, 2, 980, 157, 3, 2, 2, 2, 981, 982, 7, 6, 2, 2, 982,
	983, 5, 156, 79, 2, 983, 159, 3, 2, 2, 2, 984, 985, 5, 66, 34, 2, 985,
	161, 3, 2, 2, 2, 986, 987, 5, 66, 34, 2, 987, 163, 3, 2, 2, 2, 988, 989,
	5, 162, 82, 2, 989, 990, 7, 31, 2, 2, 990, 991, 5, 160, 81, 2, 991, 992,
	7, 32, 2, 2, 992, 993, 5, 10, 6, 2, 993, 165, 3, 2, 2, 2, 994, 995, 5,
	10, 6, 2, 995, 167, 3, 2, 2, 2, 996, 1001, 5, 166, 84, 2, 997, 1001, 5,
	152, 77, 2, 998, 1001, 5, 158, 80, 2, 999, 1001, 5, 164, 83, 2, 1000, 996,
	3, 2, 2, 2, 1000, 997, 3, 2, 2, 2, 1000, 998, 3, 2, 2, 2, 1000, 999, 3,
	2, 2, 2, 1001, 1002, 3, 2, 2, 2, 1002, 1003, 5, 28, 15, 2, 1003, 169, 3,
	2, 2, 2, 1004, 1005, 7, 33, 2, 2, 1005, 1015, 7, 40, 2, 2, 1006, 1016,
	7, 22, 2, 2, 1007, 1009, 7, 3, 2, 2, 1008, 1010, 5, 168, 85, 2, 1009, 1008,
	3, 2, 2, 2, 1010, 1011, 3, 2, 2, 2, 1011, 1009, 3, 2, 2, 2, 1011, 1012,
	3, 2, 2, 2, 1012, 1013, 3, 2, 2, 2, 1013, 1014, 7, 4, 2, 2, 1014, 1016,
	3, 2, 2, 2, 1015, 1006, 3, 2, 2, 2, 1015, 1007, 3, 2, 2, 2, 1016, 171,
	3, 2, 2, 2, 1017, 1018, 7, 27, 2, 2, 1018, 1020, 5, 10, 6, 2, 1019, 1021,
	5, 136, 69, 2, 1020, 1019, 3, 2, 2, 2, 1020, 1021, 3, 2, 2, 2, 1021, 1023,
	3, 2, 2, 2, 1022, 1024, 5, 28, 15, 2, 1023, 1022, 3, 2, 2, 2, 1023, 1024,
	3, 2, 2, 2, 1024, 1025, 3, 2, 2, 2, 1025, 1035, 7, 40, 2, 2, 1026, 1036,
	7, 22, 2, 2, 1027, 1029, 7, 3, 2, 2, 1028, 1030, 5, 138, 70, 2, 1029, 1028,
	3, 2, 2, 2, 1030, 1031, 3, 2, 2, 2, 1031, 1029, 3, 2, 2, 2, 1031, 1032,
	3, 2, 2, 2, 1032, 1033, 3, 2, 2, 2, 1033, 1034, 7, 4, 2, 2, 1034, 1036,
	3, 2, 2, 2, 1035, 1026, 3, 2, 2, 2, 1035, 1027, 3, 2, 2, 2, 1036, 173,
	3, 2, 2, 2, 1037, 1038, 5, 66, 34, 2, 1038, 1039, 7, 32, 2, 2, 1039, 1041,
	5, 10, 6, 2, 1040, 1042, 5, 28, 15, 2, 1041, 1040, 3, 2, 2, 2, 1041, 1042,
	3, 2, 2, 2, 1042, 1043, 3, 2, 2, 2, 1043, 1053, 7, 40, 2, 2, 1044, 1054,
	7, 22, 2, 2, 1045, 1047, 7, 3, 2, 2, 1046, 1048, 5, 138, 70, 2, 1047, 1046,
	3, 2, 2, 2, 1048, 1049, 3, 2, 2, 2, 1049, 1047, 3, 2, 2, 2, 1049, 1050,
	3, 2, 2, 2, 1050, 1051, 3, 2, 2, 2, 1051, 1052, 7, 4, 2, 2, 1052, 1054,
	3, 2, 2, 2, 1053, 1044, 3, 2, 2, 2, 1053, 1045, 3, 2, 2, 2, 1054, 175,
	3, 2, 2, 2, 1055, 1058, 5, 38, 20, 2, 1056, 1058, 5, 32, 17, 2, 1057, 1055,
	3, 2, 2, 2, 1057, 1056, 3, 2, 2, 2, 1058, 177, 3, 2, 2, 2, 1059, 1060,
	9, 8, 2, 2, 1060, 179, 3, 2, 2, 2, 1061, 1063, 9, 9, 2, 2, 1062, 1064,
	7, 86, 2, 2, 1063, 1062, 3, 2, 2, 2, 1063, 1064, 3, 2, 2, 2, 1064, 1065,
	3, 2, 2, 2, 1065, 1066, 7, 136, 2, 2, 1066, 181, 3, 2, 2, 2, 1067, 1068,
	5, 298, 150, 2, 1068, 183, 3, 2, 2, 2, 1069, 1074, 5, 182, 92, 2, 1070,
	1071, 7, 92, 2, 2, 1071, 1073, 5, 182, 92, 2, 1072, 1070, 3, 2, 2, 2, 1073,
	1076, 3, 2, 2, 2, 1074, 1072, 3, 2, 2, 2, 1074, 1075, 3, 2, 2, 2, 1075,
	185, 3, 2, 2, 2, 1076, 1074, 3, 2, 2, 2, 1077, 1078, 9, 10, 2, 2, 1078,
	1080, 7, 90, 2, 2, 1079, 1081, 5, 184, 93, 2, 1080, 1079, 3, 2, 2, 2, 1080,
	1081, 3, 2, 2, 2, 1081, 1082, 3, 2, 2, 2, 1082, 1083, 7, 91, 2, 2, 1083,
	187, 3, 2, 2, 2, 1084, 1086, 5, 298, 150, 2, 1085, 1087, 9, 11, 2, 2, 1086,
	1085, 3, 2, 2, 2, 1086, 1087, 3, 2, 2, 2, 1087, 189, 3, 2, 2, 2, 1088,
	1093, 5, 188, 95, 2, 1089, 1090, 7, 92, 2, 2, 1090, 1092, 5, 188, 95, 2,
	1091, 1089, 3, 2, 2, 2, 1092, 1095, 3, 2, 2, 2, 1093, 1091, 3, 2, 2, 2,
	1093, 1094, 3, 2, 2, 2, 1094, 191, 3, 2, 2, 2, 1095, 1093, 3, 2, 2, 2,
	1096, 1101, 7, 122, 2, 2, 1097, 1098, 7, 80, 2, 2, 1098, 1099, 5, 176,
	89, 2, 1099, 1100, 7, 81, 2, 2, 1100, 1102, 3, 2, 2, 2, 1101, 1097, 3,
	2, 2, 2, 1101, 1102, 3, 2, 2, 2, 1102, 1103, 3, 2, 2, 2, 1103, 1104, 7,
	90, 2, 2, 1104, 1105, 5, 190, 96, 2, 1105, 1106, 7, 109, 2, 2, 1106, 1107,
	7, 136, 2, 2, 1107, 1108, 7, 91, 2, 2, 1108, 193, 3, 2, 2, 2, 1109, 1110,
	7, 123, 2, 2, 1110, 1112, 7, 90, 2, 2, 1111, 1113, 5, 196, 99, 2, 1112,
	1111, 3, 2, 2, 2, 1112, 1113, 3, 2, 2, 2, 1113, 1114, 3, 2, 2, 2, 1114,
	1115, 5, 184, 93, 2, 1115, 1116, 7, 91, 2, 2, 1116, 195, 3, 2, 2, 2, 1117,
	1118, 7, 136, 2, 2, 1118, 1119, 7, 89, 2, 2, 1119, 197, 3, 2, 2, 2, 1120,
	1123, 7, 117, 2, 2, 1121, 1123, 5, 298, 150, 2, 1122, 1120, 3, 2, 2, 2,
	1122, 1121, 3, 2, 2, 2, 1123, 199, 3, 2, 2, 2, 1124, 1125, 7, 130, 2, 2,
	1125, 1126, 5, 198, 100, 2, 1126, 1127, 7, 105, 2, 2, 1127, 1129, 7, 90,
	2, 2, 1128, 1130, 5, 196, 99, 2, 1129, 1128, 3, 2, 2, 2, 1129, 1130, 3,
	2, 2, 2, 1130, 1131, 3, 2, 2, 2, 1131, 1132, 5, 190, 96, 2, 1132, 1133,
	7, 91, 2, 2, 1133, 201, 3, 2, 2, 2, 1134, 1135, 9, 12, 2, 2, 1135, 203,
	3, 2, 2, 2, 1136, 1137, 5, 202, 102, 2, 1137, 1139, 7, 90, 2, 2, 1138,
	1140, 5, 196, 99, 2, 1139, 1138, 3, 2, 2, 2, 1139, 1140, 3, 2, 2, 2, 1140,
	1141, 3, 2, 2, 2, 1141, 1142, 5, 298, 150, 2, 1142, 1143, 7, 91, 2, 2,
	1143, 205, 3, 2, 2, 2, 1144, 1145, 7, 124, 2, 2, 1145, 1146, 7, 90, 2,
	2, 1146, 1147, 5, 298, 150, 2, 1147, 1148, 7, 91, 2, 2, 1148, 207, 3, 2,
	2, 2, 1149, 1150, 7, 125, 2, 2, 1150, 209, 3, 2, 2, 2, 1151, 1152, 7, 126,
	2, 2, 1152, 211, 3, 2, 2, 2, 1153, 1154, 7, 128, 2, 2, 1154, 213, 3, 2,
	2, 2, 1155, 1157, 7, 137, 2, 2, 1156, 1155, 3, 2, 2, 2, 1156, 1157, 3,
	2, 2, 2, 1157, 1158, 3, 2, 2, 2, 1158, 1159, 7, 136, 2, 2, 1159, 215, 3,
	2, 2, 2, 1160, 1162, 7, 98, 2, 2, 1161, 1160, 3, 2, 2, 2, 1161, 1162, 3,
	2, 2, 2, 1162, 1163, 3, 2, 2, 2, 1163, 1165, 7, 75, 2, 2, 1164, 1166, 7,
	119, 2, 2, 1165, 1164, 3, 2, 2, 2, 1165, 1166, 3, 2, 2, 2, 1166, 1167,
	3, 2, 2, 2, 1167, 1170, 5, 214, 108, 2, 1168, 1169, 7, 110, 2, 2, 1169,
	1171, 7, 136, 2, 2, 1170, 1168, 3, 2, 2, 2, 1170, 1171, 3, 2, 2, 2, 1171,
	217, 3, 2, 2, 2, 1172, 1177, 5, 180, 91, 2, 1173, 1177, 5, 216, 109, 2,
	1174, 1177, 5, 240, 121, 2, 1175, 1177, 7, 136, 2, 2, 1176, 1172, 3, 2,
	2, 2, 1176, 1173, 3, 2, 2, 2, 1176, 1174, 3, 2, 2, 2, 1176, 1175, 3, 2,
	2, 2, 1177, 219, 3, 2, 2, 2, 1178, 1179, 7, 78, 2, 2, 1179, 1184, 7, 136,
	2, 2, 1180, 1181, 7, 92, 2, 2, 1181, 1183, 7, 136, 2, 2, 1182, 1180, 3,
	2, 2, 2, 1183, 1186, 3, 2, 2, 2, 1184, 1182, 3, 2, 2, 2, 1184, 1185, 3,
	2, 2, 2, 1185, 1187, 3, 2, 2, 2, 1186, 1184, 3, 2, 2, 2, 1187, 1188, 7,
	79, 2, 2, 1188, 221, 3, 2, 2, 2, 1189, 1191, 7, 100, 2, 2, 1190, 1189,
	3, 2, 2, 2, 1190, 1191, 3, 2, 2, 2, 1191, 1192, 3, 2, 2, 2, 1192, 1194,
	7, 99, 2, 2, 1193, 1195, 5, 220, 111, 2, 1194, 1193, 3, 2, 2, 2, 1194,
	1195, 3, 2, 2, 2, 1195, 1196, 3, 2, 2, 2, 1196, 1197, 7, 81, 2, 2, 1197,
	1198, 5, 218, 110, 2, 1198, 223, 3, 2, 2, 2, 1199, 1211, 5, 180, 91, 2,
	1200, 1211, 5, 192, 97, 2, 1201, 1211, 5, 194, 98, 2, 1202, 1211, 5, 204,
	103, 2, 1203, 1211, 5, 206, 104, 2, 1204, 1211, 5, 212, 107, 2, 1205, 1211,
	5, 208, 105, 2, 1206, 1211, 5, 210, 106, 2, 1207, 1211, 5, 200, 101, 2,
	1208, 1211, 5, 216, 109, 2, 1209, 1211, 5, 222, 112, 2, 1210, 1199, 3,
	2, 2, 2, 1210, 1200, 3, 2, 2, 2, 1210, 1201, 3, 2, 2, 2, 1210, 1202, 3,
	2, 2, 2, 1210, 1203, 3, 2, 2, 2, 1210, 1204, 3, 2, 2, 2, 1210, 1205, 3,
	2, 2, 2, 1210, 1206, 3, 2, 2, 2, 1210, 1207, 3, 2, 2, 2, 1210, 1208, 3,
	2, 2, 2, 1210, 1209, 3, 2, 2, 2, 1211, 225, 3, 2, 2, 2, 1212, 1213, 5,
	298, 150, 2, 1213, 227, 3, 2, 2, 2, 1214, 1219, 5, 226, 114, 2, 1215, 1216,
	7, 92, 2, 2, 1216, 1218, 5, 226, 114, 2, 1217, 1215, 3, 2, 2, 2, 1218,
	1221, 3, 2, 2, 2, 1219, 1217, 3, 2, 2, 2, 1219, 1220, 3, 2, 2, 2, 1220,
	229, 3, 2, 2, 2, 1221, 1219, 3, 2, 2, 2, 1222, 1223, 7, 83, 2, 2, 1223,
	1224, 5, 228, 115, 2, 1224, 1225, 7, 84, 2, 2, 1225, 231, 3, 2, 2, 2, 1226,
	1227, 7, 82, 2, 2, 1227, 233, 3, 2, 2, 2, 1228, 1239, 7, 137, 2, 2, 1229,
	1240, 5, 192, 97, 2, 1230, 1240, 5, 194, 98, 2, 1231, 1240, 5, 204, 103,
	2, 1232, 1240, 5, 206, 104, 2, 1233, 1240, 5, 212, 107, 2, 1234, 1240,
	5, 208, 105, 2, 1235, 1240, 5, 210, 106, 2, 1236, 1240, 5, 200, 101, 2,
	1237, 1240, 5, 216, 109, 2, 1238, 1240, 5, 222, 112, 2, 1239, 1229, 3,
	2, 2, 2, 1239, 1230, 3, 2, 2, 2, 1239, 1231, 3, 2, 2, 2, 1239, 1232, 3,
	2, 2, 2, 1239, 1233, 3, 2, 2, 2, 1239, 1234, 3, 2, 2, 2, 1239, 1235, 3,
	2, 2, 2, 1239, 1236, 3, 2, 2, 2, 1239, 1237, 3, 2, 2, 2, 1239, 1238, 3,
	2, 2, 2, 1240, 235, 3, 2, 2, 2, 1241, 1246, 5, 234, 118, 2, 1242, 1246,
	5, 216, 109, 2, 1243, 1246, 5, 222, 112, 2, 1244, 1246, 5, 180, 91, 2,
	1245, 1241, 3, 2, 2, 2, 1245, 1242, 3, 2, 2, 2, 1245, 1243, 3, 2, 2, 2,
	1245, 1244, 3, 2, 2, 2, 1246, 237, 3, 2, 2, 2, 1247, 1248, 9, 13, 2, 2,
	1248, 239, 3, 2, 2, 2, 1249, 1250, 7, 90, 2, 2, 1250, 1251, 5, 298, 150,
	2, 1251, 1252, 7, 91, 2, 2, 1252, 241, 3, 2, 2, 2, 1253, 1254, 7, 78, 2,
	2, 1254, 1255, 5, 228, 115, 2, 1255, 1256, 7, 79, 2, 2, 1256, 243, 3, 2,
	2, 2, 1257, 1266, 5, 186, 94, 2, 1258, 1266, 5, 230, 116, 2, 1259, 1266,
	5, 242, 122, 2, 1260, 1266, 5, 232, 117, 2, 1261, 1266, 5, 240, 121, 2,
	1262, 1266, 5, 178, 90, 2, 1263, 1266, 5, 236, 119, 2, 1264, 1266, 5, 238,
	120, 2, 1265, 1257, 3, 2, 2, 2, 1265, 1258, 3, 2, 2, 2, 1265, 1259, 3,
	2, 2, 2, 1265, 1260, 3, 2, 2, 2, 1265, 1261, 3, 2, 2, 2, 1265, 1262, 3,
	2, 2, 2, 1265, 1263, 3, 2, 2, 2, 1265, 1264, 3, 2, 2, 2, 1266, 245, 3,
	2, 2, 2, 1267, 1271, 5, 244, 123, 2, 1268, 1270, 5, 224, 113, 2, 1269,
	1268, 3, 2, 2, 2, 1270, 1273, 3, 2, 2, 2, 1271, 1269, 3, 2, 2, 2, 1271,
	1272, 3, 2, 2, 2, 1272, 247, 3, 2, 2, 2, 1273, 1271, 3, 2, 2, 2, 1274,
	1275, 7, 87, 2, 2, 1275, 1276, 5, 252, 127, 2, 1276, 249, 3, 2, 2, 2, 1277,
	1279, 5, 246, 124, 2, 1278, 1280, 5, 248, 125, 2, 1279, 1278, 3, 2, 2,
	2, 1279, 1280, 3, 2, 2, 2, 1280, 251, 3, 2, 2, 2, 1281, 1283, 9, 14, 2,
	2, 1282, 1281, 3, 2, 2, 2, 1282, 1283, 3, 2, 2, 2, 1283, 1284, 3, 2, 2,
	2, 1284, 1285, 5, 250, 126, 2, 1285, 253, 3, 2, 2, 2, 1286, 1287, 9, 15,
	2, 2, 1287, 1288, 5, 252, 127, 2, 1288, 255, 3, 2, 2, 2, 1289, 1293, 5,
	252, 127, 2, 1290, 1292, 5, 254, 128, 2, 1291, 1290, 3, 2, 2, 2, 1292,
	1295, 3, 2, 2, 2, 1293, 1291, 3, 2, 2, 2, 1293, 1294, 3, 2, 2, 2, 1294,
	257, 3, 2, 2, 2, 1295, 1293, 3, 2, 2, 2, 1296, 1297, 9, 16, 2, 2, 1297,
	1298, 5, 256, 129, 2, 1298, 259, 3, 2, 2, 2, 1299, 1303, 5, 256, 129, 2,
	1300, 1302, 5, 258, 130, 2, 1301, 1300, 3, 2, 2, 2, 1302, 1305, 3, 2, 2,
	2, 1303, 1301, 3, 2, 2, 2, 1303, 1304, 3, 2, 2, 2, 1304, 261, 3, 2, 2,
	2, 1305, 1303, 3, 2, 2, 2, 1306, 1307, 9, 17, 2, 2, 1307, 263, 3, 2, 2,
	2, 1308, 1314, 5, 260, 131, 2, 1309, 1310, 5, 262, 132, 2, 1310, 1311,
	5, 260, 131, 2, 1311, 1313, 3, 2, 2, 2, 1312, 1309, 3, 2, 2, 2, 1313, 1316,
	3, 2, 2, 2, 1314, 1312, 3, 2, 2, 2, 1314, 1315, 3, 2, 2, 2, 1315, 265,
	3, 2, 2, 2, 1316, 1314, 3, 2, 2, 2, 1317, 1322, 5, 264, 133, 2, 1318, 1319,
	9, 18, 2, 2, 1319, 1321, 5, 264, 133, 2, 1320, 1318, 3, 2, 2, 2, 1321,
	1324, 3, 2, 2, 2, 1322, 1320, 3, 2, 2, 2, 1322, 1323, 3, 2, 2, 2, 1323,
	267, 3, 2, 2, 2, 1324, 1322, 3, 2, 2, 2, 1325, 1330, 5, 266, 134, 2, 1326,
	1327, 7, 101, 2, 2, 1327, 1329, 5, 266, 134, 2, 1328, 1326, 3, 2, 2, 2,
	1329, 1332, 3, 2, 2, 2, 1330, 1328, 3, 2, 2, 2, 1330, 1331, 3, 2, 2, 2,
	1331, 269, 3, 2, 2, 2, 1332, 1330, 3, 2, 2, 2, 1333, 1338, 5, 268, 135,
	2, 1334, 1335, 7, 107, 2, 2, 1335, 1337, 5, 268, 135, 2, 1336, 1334, 3,
	2, 2, 2, 1337, 1340, 3, 2, 2, 2, 1338, 1336, 3, 2, 2, 2, 1338, 1339, 3,
	2, 2, 2, 1339, 271, 3, 2, 2, 2, 1340, 1338, 3, 2, 2, 2, 1341, 1346, 5,
	270, 136, 2, 1342, 1343, 7, 103, 2, 2, 1343, 1345, 5, 270, 136, 2, 1344,
	1342, 3, 2, 2, 2, 1345, 1348, 3, 2, 2, 2, 1346, 1344, 3, 2, 2, 2, 1346,
	1347, 3, 2, 2, 2, 1347, 273, 3, 2, 2, 2, 1348, 1346, 3, 2, 2, 2, 1349,
	1354, 5, 272, 137, 2, 1350, 1351, 7, 102, 2, 2, 1351, 1353, 5, 272, 137,
	2, 1352, 1350, 3, 2, 2, 2, 1353, 1356, 3, 2, 2, 2, 1354, 1352, 3, 2, 2,
	2, 1354, 1355, 3, 2, 2, 2, 1355, 275, 3, 2, 2, 2, 1356, 1354, 3, 2, 2,
	2, 1357, 1362, 5, 274, 138, 2, 1358, 1359, 7, 118, 2, 2, 1359, 1361, 5,
	274, 138, 2, 1360, 1358, 3, 2, 2, 2, 1361, 1364, 3, 2, 2, 2, 1362, 1360,
	3, 2, 2, 2, 1362, 1363, 3, 2, 2, 2, 1363, 277, 3, 2, 2, 2, 1364, 1362,
	3, 2, 2, 2, 1365, 1370, 5, 276, 139, 2, 1366, 1367, 7, 88, 2, 2, 1367,
	1369, 5, 276, 139, 2, 1368, 1366, 3, 2, 2, 2, 1369, 1372, 3, 2, 2, 2, 1370,
	1368, 3, 2, 2, 2, 1370, 1371, 3, 2, 2, 2, 1371, 279, 3, 2, 2, 2, 1372,
	1370, 3, 2, 2, 2, 1373, 1375, 5, 298, 150, 2, 1374, 1376, 7, 98, 2, 2,
	1375, 1374, 3, 2, 2, 2, 1375, 1376, 3, 2, 2, 2, 1376, 1377, 3, 2, 2, 2,
	1377, 1378, 7, 112, 2, 2, 1378, 1379, 5, 298, 150, 2, 1379, 1380, 7, 113,
	2, 2, 1380, 1381, 5, 298, 150, 2, 1381, 281, 3, 2, 2, 2, 1382, 1383, 5,
	298, 150, 2, 1383, 1384, 8, 142, 1, 2, 1384, 283, 3, 2, 2, 2, 1385, 1386,
	5, 298, 150, 2, 1386, 285, 3, 2, 2, 2, 1387, 1392, 5, 284, 143, 2, 1388,
	1389, 7, 92, 2, 2, 1389, 1391, 5, 284, 143, 2, 1390, 1388, 3, 2, 2, 2,
	1391, 1394, 3, 2, 2, 2, 1392, 1390, 3, 2, 2, 2, 1392, 1393, 3, 2, 2, 2,
	1393, 287, 3, 2, 2, 2, 1394, 1392, 3, 2, 2, 2, 1395, 1396, 5, 286, 144,
	2, 1396, 1397, 7, 74, 2, 2, 1397, 1400, 5, 282, 142, 2, 1398, 1401, 6,
	145, 2, 3, 1399, 1401, 7, 140, 2, 2, 1400, 1398, 3, 2, 2, 2, 1400, 1399,
	3, 2, 2, 2, 1401, 289, 3, 2, 2, 2, 1402, 1403, 7, 113, 2, 2, 1403, 1406,
	5, 298, 150, 2, 1404, 1407, 6, 146, 3, 3, 1405, 1407, 7, 140, 2, 2, 1406,
	1404, 3, 2, 2, 2, 1406, 1405, 3, 2, 2, 2, 1407, 291, 3, 2, 2, 2, 1408,
	1409, 5, 298, 150, 2, 1409, 1410, 7, 76, 2, 2, 1410, 293, 3, 2, 2, 2, 1411,
	1413, 5, 292, 147, 2, 1412, 1411, 3, 2, 2, 2, 1412, 1413, 3, 2, 2, 2, 1413,
	1414, 3, 2, 2, 2, 1414, 1415, 7, 89, 2, 2, 1415, 1416, 7, 140, 2, 2, 1416,
	1418, 7, 3, 2, 2, 1417, 1419, 5, 288, 145, 2, 1418, 1417, 3, 2, 2, 2, 1419,
	1420, 3, 2, 2, 2, 1420, 1418, 3, 2, 2, 2, 1420, 1421, 3, 2, 2, 2, 1421,
	1423, 3, 2, 2, 2, 1422, 1424, 5, 290, 146, 2, 1423, 1422, 3, 2, 2, 2, 1423,
	1424, 3, 2, 2, 2, 1424, 1425, 3, 2, 2, 2, 1425, 1426, 7, 4, 2, 2, 1426,
	295, 3, 2, 2, 2, 1427, 1432, 7, 111, 2, 2, 1428, 1433, 5, 280, 141, 2,
	1429, 1430, 5, 294, 148, 2, 1430, 1431, 8, 149, 1, 2, 1431, 1433, 3, 2,
	2, 2, 1432, 1428, 3, 2, 2, 2, 1432, 1429, 3, 2, 2, 2, 1433, 297, 3, 2,
	2, 2, 1434, 1435, 5, 296, 149, 2, 1435, 1436, 8, 150, 1, 2, 1436, 1439,
	3, 2, 2, 2, 1437, 1439, 5, 278, 140, 2, 1438, 1434, 3, 2, 2, 2, 1438, 1437,
	3, 2, 2, 2, 1439, 299, 3, 2, 2, 2, 1440, 1447, 7, 93, 2, 2, 1441, 1442,
	5, 298, 150, 2, 1442, 1443, 8, 151, 1, 2, 1443, 1448, 3, 2, 2, 2, 1444,
	1445, 5, 326, 164, 2, 1445, 1446, 8, 151, 1, 2, 1446, 1448, 3, 2, 2, 2,
	1447, 1441, 3, 2, 2, 2, 1447, 1444, 3, 2, 2, 2, 1448, 301, 3, 2, 2, 2,
	1449, 1450, 7, 136, 2, 2, 1450, 1451, 5, 300, 151, 2, 1451, 1452, 8, 152,
	1, 2, 1452, 303, 3, 2, 2, 2, 1453, 1454, 7, 114, 2, 2, 1454, 1455, 7, 136,
	2, 2, 1455, 1456, 5, 300, 151, 2, 1456, 1457, 8, 153, 1, 2, 1457, 305,
	3, 2, 2, 2, 1458, 1459, 7, 86, 2, 2, 1459, 1460, 7, 136, 2, 2, 1460, 1461,
	5, 300, 151, 2, 1461, 1462, 8, 154, 1, 2, 1462, 307, 3, 2, 2, 2, 1463,
	1464, 7, 135, 2, 2, 1464, 309, 3, 2, 2, 2, 1465, 1466, 5, 308, 155, 2,
	1466, 311, 3, 2, 2, 2, 1467, 1468, 5, 304, 153, 2, 1468, 1469, 8, 157,
	1, 2, 1469, 1477, 3, 2, 2, 2, 1470, 1471, 5, 306, 154, 2, 1471, 1472, 8,
	157, 1, 2, 1472, 1477, 3, 2, 2, 2, 1473, 1474, 5, 302, 152, 2, 1474, 1475,
	8, 157, 1, 2, 1475, 1477, 3, 2, 2, 2, 1476, 1467, 3, 2, 2, 2, 1476, 1470,
	3, 2, 2, 2, 1476, 1473, 3, 2, 2, 2, 1477, 1480, 3, 2, 2, 2, 1478, 1481,
	6, 157, 4, 3, 1479, 1481, 7, 140, 2, 2, 1480, 1478, 3, 2, 2, 2, 1480, 1479,
	3, 2, 2, 2, 1481, 313, 3, 2, 2, 2, 1482, 1483, 5, 186, 94, 2, 1483, 1484,
	7, 137, 2, 2, 1484, 1485, 7, 108, 2, 2, 1485, 1486, 7, 140, 2, 2, 1486,
	315, 3, 2, 2, 2, 1487, 1491, 5, 310, 156, 2, 1488, 1491, 5, 312, 157, 2,
	1489, 1491, 5, 314, 158, 2, 1490, 1487, 3, 2, 2, 2, 1490, 1488, 3, 2, 2,
	2, 1490, 1489, 3, 2, 2, 2, 1491, 317, 3, 2, 2, 2, 1492, 1495, 5, 34, 18,
	2, 1493, 1495, 5, 176, 89, 2, 1494, 1492, 3, 2, 2, 2, 1494, 1493, 3, 2,
	2, 2, 1495, 319, 3, 2, 2, 2, 1496, 1497, 5, 176, 89, 2, 1497, 321, 3, 2,
	2, 2, 1498, 1499, 7, 136, 2, 2, 1499, 323, 3, 2, 2, 2, 1500, 1501, 5, 298,
	150, 2, 1501, 325, 3, 2, 2, 2, 1502, 1504, 5, 324, 163, 2, 1503, 1502,
	3, 2, 2, 2, 1503, 1504, 3, 2, 2, 2, 1504, 1505, 3, 2, 2, 2, 1505, 1510,
	7, 75, 2, 2, 1506, 1507, 7, 80, 2, 2, 1507, 1508, 5, 318, 160, 2, 1508,
	1509, 7, 81, 2, 2, 1509, 1511, 3, 2, 2, 2, 1510, 1506, 3, 2, 2, 2, 1510,
	1511, 3, 2, 2, 2, 1511, 1512, 3, 2, 2, 2, 1512, 1514, 7, 90, 2, 2, 1513,
	1515, 5, 322, 162, 2, 1514, 1513, 3, 2, 2, 2, 1514, 1515, 3, 2, 2, 2, 1515,
	1516, 3, 2, 2, 2, 1516, 1517, 7, 89, 2, 2, 1517, 1518, 7, 140, 2, 2, 1518,
	1520, 7, 3, 2, 2, 1519, 1521, 5, 316, 159, 2, 1520, 1519, 3, 2, 2, 2, 1521,
	1522, 3, 2, 2, 2, 1522, 1520, 3, 2, 2, 2, 1522, 1523, 3, 2, 2, 2, 1523,
	1524, 3, 2, 2, 2, 1524, 1525, 7, 4, 2, 2, 1525, 1526, 7, 91, 2, 2, 1526,
	1527, 7, 140, 2, 2, 1527, 327, 3, 2, 2, 2, 1528, 1529, 7, 3, 2, 2, 1529,
	1530, 5, 326, 164, 2, 1530, 1531, 7, 4, 2, 2, 1531, 329, 3, 2, 2, 2, 1532,
	1533, 5, 10, 6, 2, 1533, 1534, 7, 30, 2, 2, 1534, 1535, 5, 176, 89, 2,
	1535, 331, 3, 2, 2, 2, 1536, 1541, 5, 330, 166, 2, 1537, 1538, 7, 37, 2,
	2, 1538, 1540, 5, 330, 166, 2, 1539, 1537, 3, 2, 2, 2, 1540, 1543, 3, 2,
	2, 2, 1541, 1539, 3, 2, 2, 2, 1541, 1542, 3, 2, 2, 2, 1542, 333, 3, 2,
	2, 2, 1543, 1541, 3, 2, 2, 2, 1544, 1545, 7, 35, 2, 2, 1545, 335, 3, 2,
	2, 2, 1546, 1547, 7, 11, 2, 2, 1547, 1548, 5, 10, 6, 2, 1548, 1549, 7,
	49, 2, 2, 1549, 1550, 5, 332, 167, 2, 1550, 1553, 7, 50, 2, 2, 1551, 1552,
	7, 32, 2, 2, 1552, 1554, 5, 320, 161, 2, 1553, 1551, 3, 2, 2, 2, 1553,
	1554, 3, 2, 2, 2, 1554, 1563, 3, 2, 2, 2, 1555, 1557, 5, 28, 15, 2, 1556,
	1555, 3, 2, 2, 2, 1556, 1557, 3, 2, 2, 2, 1557, 1558, 3, 2, 2, 2, 1558,
	1559, 7, 40, 2, 2, 1559, 1564, 5, 328, 165, 2, 1560, 1561, 5, 334, 168,
	2, 1561, 1562, 8, 169, 1, 2, 1562, 1564, 3, 2, 2, 2, 1563, 1556, 3, 2,
	2, 2, 1563, 1560, 3, 2, 2, 2, 1564, 337, 3, 2, 2, 2, 1565, 1580, 7, 3,
	2, 2, 1566, 1581, 5, 58, 30, 2, 1567, 1581, 5, 60, 31, 2, 1568, 1581, 5,
	76, 39, 2, 1569, 1581, 7, 59, 2, 2, 1570, 1581, 5, 146, 74, 2, 1571, 1581,
	5, 144, 73, 2, 1572, 1581, 5, 170, 86, 2, 1573, 1581, 5, 172, 87, 2, 1574,
	1581, 5, 174, 88, 2, 1575, 1581, 5, 44, 23, 2, 1576, 1581, 5, 130, 66,
	2, 1577, 1578, 5, 336, 169, 2, 1578, 1579, 8, 170, 1, 2, 1579, 1581, 3,
	2, 2, 2, 1580, 1566, 3, 2, 2, 2, 1580, 1567, 3, 2, 2, 2, 1580, 1568, 3,
	2, 2, 2, 1580, 1569, 3, 2, 2, 2, 1580, 1570, 3, 2, 2, 2, 1580, 1571, 3,
	2, 2, 2, 1580, 1572, 3, 2, 2, 2, 1580, 1573, 3, 2, 2, 2, 1580, 1574, 3,
	2, 2, 2, 1580, 1575, 3, 2, 2, 2, 1580, 1576, 3, 2, 2, 2, 1580, 1577, 3,
	2, 2, 2, 1581, 1582, 3, 2, 2, 2, 1582, 1580, 3, 2, 2, 2, 1582, 1583, 3,
	2, 2, 2, 1583, 1586, 3, 2, 2, 2, 1584, 1587, 6, 170, 5, 3, 1585, 1587,
	7, 4, 2, 2, 1586, 1584, 3, 2, 2, 2, 1586, 1585, 3, 2, 2, 2, 1587, 339,
	3, 2, 2, 2, 1588, 1590, 7, 59, 2, 2, 1589, 1588, 3, 2, 2, 2, 1590, 1593,
	3, 2, 2, 2, 1591, 1589, 3, 2, 2, 2, 1591, 1592, 3, 2, 2, 2, 1592, 1594,
	3, 2, 2, 2, 1593, 1591, 3, 2, 2, 2, 1594, 1595, 5, 68, 35, 2, 1595, 1596,
	7, 40, 2, 2, 1596, 1597, 5, 338, 170, 2, 1597, 341, 3, 2, 2, 2, 1598, 1600,
	7, 39, 2, 2, 1599, 1598, 3, 2, 2, 2, 1599, 1600, 3, 2, 2, 2, 1600, 1601,
	3, 2, 2, 2, 1601, 1606, 7, 61, 2, 2, 1602, 1603, 7, 39, 2, 2, 1603, 1605,
	7, 61, 2, 2, 1604, 1602, 3, 2, 2, 2, 1605, 1608, 3, 2, 2, 2, 1606, 1604,
	3, 2, 2, 2, 1606, 1607, 3, 2, 2, 2, 1607, 343, 3, 2, 2, 2, 1608, 1606,
	3, 2, 2, 2, 1609, 1613, 7, 12, 2, 2, 1610, 1612, 7, 59, 2, 2, 1611, 1610,
	3, 2, 2, 2, 1612, 1615, 3, 2, 2, 2, 1613, 1611, 3, 2, 2, 2, 1613, 1614,
	3, 2, 2, 2, 1614, 345, 3, 2, 2, 2, 1615, 1613, 3, 2, 2, 2, 1616, 1618,
	5, 344, 173, 2, 1617, 1616, 3, 2, 2, 2, 1618, 1619, 3, 2, 2, 2, 1619, 1617,
	3, 2, 2, 2, 1619, 1620, 3, 2, 2, 2, 1620, 347, 3, 2, 2, 2, 1621, 1623,
	5, 346, 174, 2, 1622, 1621, 3, 2, 2, 2, 1622, 1623, 3, 2, 2, 2, 1623, 1625,
	3, 2, 2, 2, 1624, 1626, 5, 340, 171, 2, 1625, 1624, 3, 2, 2, 2, 1626, 1627,
	3, 2, 2, 2, 1627, 1625, 3, 2, 2, 2, 1627, 1628, 3, 2, 2, 2, 1628, 1629,
	3, 2, 2, 2, 1629, 1630, 7, 2, 2, 3, 1630, 349, 3, 2, 2, 2, 177, 356, 363,
	372, 386, 399, 410, 420, 428, 435, 443, 453, 457, 462, 471, 478, 489, 497,
	500, 503, 507, 509, 515, 523, 529, 534, 537, 539, 546, 552, 562, 564, 567,
	572, 578, 587, 589, 592, 603, 608, 611, 620, 624, 631, 636, 645, 664, 667,
	675, 680, 687, 696, 702, 704, 707, 714, 726, 728, 734, 736, 744, 753, 757,
	766, 773, 780, 789, 799, 812, 819, 822, 829, 839, 848, 851, 858, 865, 881,
	884, 888, 891, 894, 901, 910, 913, 916, 924, 928, 930, 934, 940, 942, 950,
	958, 970, 976, 979, 1000, 1011, 1015, 1020, 1023, 1031, 1035, 1041, 1049,
	1053, 1057, 1063, 1074, 1080, 1086, 1093, 1101, 1112, 1122, 1129, 1139,
	1156, 1161, 1165, 1170, 1176, 1184, 1190, 1194, 1210, 1219, 1239, 1245,
	1265, 1271, 1279, 1282, 1293, 1303, 1314, 1322, 1330, 1338, 1346, 1354,
	1362, 1370, 1375, 1392, 1400, 1406, 1412, 1420, 1423, 1432, 1438, 1447,
	1476, 1480, 1490, 1494, 1503, 1510, 1514, 1522, 1541, 1553, 1556, 1563,
	1580, 1582, 1586, 1591, 1599, 1606, 1613, 1619, 1622, 1627,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "", "", "", "", "'!wrap'", "'!table'", "'!type'", "'!union'", "'!view'",
	"", "", "", "", "", "", "", "", "", "", "", "'..'", "", "", "", "'<->'",
	"", "", "", "", "", "'.. * <- *'", "", "", "", "", "", "", "", "", "",
	"'@'", "", "", "", "", "", "", "", "", "'#'", "'|'", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "'=>'", "'->'",
	"'=='", "", "", "", "'<'", "'>'", "'{:}'", "", "", "'?.'", "", "'**'",
	"", "", "", "", "", "", "", "", "'%'", "'-'", "", "", "'!'", "", "'||'",
	"'&&'", "", "'by'", "'and'", "", "'*'", "'as'", "'via'", "'if'", "'then'",
	"'else'", "'let'", "'true'", "'false'", "'null'", "", "", "'asc'", "'desc'",
	"'rank'", "", "'any'", "", "'snapshot'", "'where'", "'count'", "'flatten'",
	"'first'",
}
var symbolicNames = []string{
	"", "INDENT", "DEDENT", "NativeDataTypes", "HTTP_VERBS", "WRAP", "TABLE",
	"TYPE", "UNION", "VIEW", "IMPORT", "RETURN", "IF", "FOR_EACH", "FOR", "UNTIL",
	"ELSE", "LOOP", "ALT", "WHILE", "WHATEVER", "DOTDOT", "SET_OF", "ONE_OF",
	"MIXIN", "DISTANCE", "DOT_ARROW", "NAME_SEP", "LESS_COLON", "ARROW_LEFT",
	"ARROW_RIGHT", "COLLECTOR", "PLUS", "ABSTRACT", "TILDE", "COMMA", "EQ",
	"FORWARD_SLASH", "COLON", "DOT", "QN", "AT", "AMP", "SQ_OPEN", "SQ_CLOSE",
	"CURLY_OPEN", "CURLY_CLOSE", "OPEN_PAREN", "CLOSE_PAREN", "EMPTY_COMMENT",
	"HASH", "PIPE", "EMPTY_LINE", "INDENTED_COMMENT", "DIGITS", "QSTRING",
	"NEWLINE", "SYSL_COMMENT", "TEXT_LINE", "Name", "WS", "ErrorChar", "PREDICATE_VALUE",
	"SKIP_WS_ARG", "TEXT_VALUE", "NEWLINE_2", "TEXT", "POP_WS", "VAR_NAME",
	"E_NativeDataTypes", "E_INDENTED_COMMENT", "E_WHATEVER", "E_EQ_RIGHT",
	"E_ARROW_RIGHT", "E_DOUBLE_EQ", "E_REL", "E_SQ_OPEN", "E_SQ_CLOSE", "E_ANGLE_OPEN",
	"E_ANGLE_CLOSE", "E_EMPTY_TUPLE", "E_CURLY_OPEN", "E_CURLY_CLOSE", "E_NULLSAFE_DOT",
	"E_TABLE_OF", "E_POW", "E_COALESCE", "E_COLON", "E_OPEN_PAREN", "E_CLOSE_PAREN",
	"E_COMMA", "E_EQ", "E_PLUS", "E_DIVIDE", "E_MOD", "E_MINUS", "E_QN", "E_TILDE",
	"E_NOT", "E_XOR", "E_LOGIC_OR", "E_DOUBLE_AMP", "E_AMP", "E_BY", "E_AND",
	"E_BITOR", "E_STAR", "E_AS", "E_VIA", "E_IF", "E_THEN", "E_ELSE", "E_LET",
	"E_TRUE", "E_FALSE", "E_NULL", "E_BUTNOT", "E_SET_OF", "E_ASC", "E_DESC",
	"E_RELOPS_RANK", "E_RELOPS_AGG", "E_RELOPS_ANY", "E_RELOPS_SINGLE_NULL",
	"E_RELOPS_SNAPSHOT", "E_RELOPS_WHERE", "E_RELOPS_COUNT", "E_RELOPS_FLATTEN",
	"E_RELOPS_FIRST", "E_FUNC", "E_STRING", "E_DECIMAL", "E_DIGITS", "E_DOT_NAME_NL",
	"E_Name", "E_DOT", "E_WS", "E_EMPTY_LINE", "E_NL",
}

var ruleNames = []string{
	"modifier", "size_spec", "modifier_list", "modifiers", "name_str", "reference",
	"doc_string", "quoted_string", "array_of_strings", "array_of_arrays", "nvp",
	"attributes", "entry", "attribs_or_modifiers", "user_defined_type", "types",
	"set_of", "set_type", "collection_type", "multi_line_docstring", "annotation_value",
	"annotation", "annotations", "field_type", "array_size", "inplace_tuple",
	"field", "inplace_table", "table", "union", "package_name", "sub_package",
	"app_name", "name_with_attribs", "model_name", "inplace_table_def", "table_refs",
	"facade", "documentation_stmts", "var_in_curly", "query_var", "query_param",
	"http_path_part", "http_path_var_with_type", "http_path_static", "http_path_suffix",
	"http_path", "endpoint_name", "ret_stmt", "target", "target_endpoint",
	"call_arg", "call_args", "call_stmt", "if_stmt", "else_stmt", "if_else",
	"for_stmt", "http_method_comment", "group_stmt", "one_of_case_label", "one_of_cases",
	"one_of_stmt", "text_stmt", "mixin", "param", "param_list", "params", "statements",
	"method_def", "shortcut", "simple_endpoint", "rest_endpoint", "collector_query_var",
	"collector_query_param", "collector_call_stmt", "collector_http_stmt_part",
	"collector_http_stmt_suffix", "collector_http_stmt", "publisher", "subscriber",
	"collector_pubsub_call", "collector_action_stmt", "collector_stmts", "collector",
	"event", "subscribe", "view_type_spec", "literal", "expr_table_of_op",
	"func_arg", "func_args", "expr_func", "rank_expr", "rank_expr_list", "expr_rank_func",
	"expr_agg_func", "e_scope_var", "first_func_target", "expr_first_func",
	"e_single_arg_func", "expr_single_arg_func", "expr_any_func", "expr_single_or_null",
	"expr_snapshot", "expr_count", "expr_navigate_attr", "expr_navigate", "matching_rhs",
	"squiggly_args", "expr_matching", "relop", "list_item", "expr_list", "expr_set",
	"empty_tuple", "atom_dot_relop", "atomT_implied_dot", "atomT_name", "atomT_paren",
	"expr_atom_list", "atomT", "atom", "powerT", "power", "unaryTerm", "termT",
	"term", "binexprT", "binexpr", "e_compare_ops", "expr_rel", "expr_bitand",
	"expr_bitxor", "expr_bitor", "expr_and", "expr_or", "expr_but_not", "expr_coalesce",
	"if_one_liner", "else_block_stmt", "control_item", "if_controls", "cond_block",
	"final_else", "ifvar", "if_multiple_lines", "expr_if_else", "expr", "expr_assign",
	"expr_simple_assign", "expr_let_statement", "expr_table_of_statement",
	"expr_dot_assign", "expr_statement_no_nl", "expr_statement", "expr_inject_stmt",
	"expr_stmt", "transform_return_type", "view_return_type", "transform_scope_var",
	"transform_arg", "transform", "expr_block", "view_param", "view_params",
	"abstract_view", "view", "app_decl", "application", "path", "import_stmt",
	"imports_decl", "sysl_file",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type SyslParser struct {
	*antlr.BaseParser
}

func NewSyslParser(input antlr.TokenStream) *SyslParser {
	this := new(SyslParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "SyslParser.g4"

	return this
}

// SyslParser tokens.
const (
	SyslParserEOF                  = antlr.TokenEOF
	SyslParserINDENT               = 1
	SyslParserDEDENT               = 2
	SyslParserNativeDataTypes      = 3
	SyslParserHTTP_VERBS           = 4
	SyslParserWRAP                 = 5
	SyslParserTABLE                = 6
	SyslParserTYPE                 = 7
	SyslParserUNION                = 8
	SyslParserVIEW                 = 9
	SyslParserIMPORT               = 10
	SyslParserRETURN               = 11
	SyslParserIF                   = 12
	SyslParserFOR_EACH             = 13
	SyslParserFOR                  = 14
	SyslParserUNTIL                = 15
	SyslParserELSE                 = 16
	SyslParserLOOP                 = 17
	SyslParserALT                  = 18
	SyslParserWHILE                = 19
	SyslParserWHATEVER             = 20
	SyslParserDOTDOT               = 21
	SyslParserSET_OF               = 22
	SyslParserONE_OF               = 23
	SyslParserMIXIN                = 24
	SyslParserDISTANCE             = 25
	SyslParserDOT_ARROW            = 26
	SyslParserNAME_SEP             = 27
	SyslParserLESS_COLON           = 28
	SyslParserARROW_LEFT           = 29
	SyslParserARROW_RIGHT          = 30
	SyslParserCOLLECTOR            = 31
	SyslParserPLUS                 = 32
	SyslParserABSTRACT             = 33
	SyslParserTILDE                = 34
	SyslParserCOMMA                = 35
	SyslParserEQ                   = 36
	SyslParserFORWARD_SLASH        = 37
	SyslParserCOLON                = 38
	SyslParserDOT                  = 39
	SyslParserQN                   = 40
	SyslParserAT                   = 41
	SyslParserAMP                  = 42
	SyslParserSQ_OPEN              = 43
	SyslParserSQ_CLOSE             = 44
	SyslParserCURLY_OPEN           = 45
	SyslParserCURLY_CLOSE          = 46
	SyslParserOPEN_PAREN           = 47
	SyslParserCLOSE_PAREN          = 48
	SyslParserEMPTY_COMMENT        = 49
	SyslParserHASH                 = 50
	SyslParserPIPE                 = 51
	SyslParserEMPTY_LINE           = 52
	SyslParserINDENTED_COMMENT     = 53
	SyslParserDIGITS               = 54
	SyslParserQSTRING              = 55
	SyslParserNEWLINE              = 56
	SyslParserSYSL_COMMENT         = 57
	SyslParserTEXT_LINE            = 58
	SyslParserName                 = 59
	SyslParserWS                   = 60
	SyslParserErrorChar            = 61
	SyslParserPREDICATE_VALUE      = 62
	SyslParserSKIP_WS_ARG          = 63
	SyslParserTEXT_VALUE           = 64
	SyslParserNEWLINE_2            = 65
	SyslParserTEXT                 = 66
	SyslParserPOP_WS               = 67
	SyslParserVAR_NAME             = 68
	SyslParserE_NativeDataTypes    = 69
	SyslParserE_INDENTED_COMMENT   = 70
	SyslParserE_WHATEVER           = 71
	SyslParserE_EQ_RIGHT           = 72
	SyslParserE_ARROW_RIGHT        = 73
	SyslParserE_DOUBLE_EQ          = 74
	SyslParserE_REL                = 75
	SyslParserE_SQ_OPEN            = 76
	SyslParserE_SQ_CLOSE           = 77
	SyslParserE_ANGLE_OPEN         = 78
	SyslParserE_ANGLE_CLOSE        = 79
	SyslParserE_EMPTY_TUPLE        = 80
	SyslParserE_CURLY_OPEN         = 81
	SyslParserE_CURLY_CLOSE        = 82
	SyslParserE_NULLSAFE_DOT       = 83
	SyslParserE_TABLE_OF           = 84
	SyslParserE_POW                = 85
	SyslParserE_COALESCE           = 86
	SyslParserE_COLON              = 87
	SyslParserE_OPEN_PAREN         = 88
	SyslParserE_CLOSE_PAREN        = 89
	SyslParserE_COMMA              = 90
	SyslParserE_EQ                 = 91
	SyslParserE_PLUS               = 92
	SyslParserE_DIVIDE             = 93
	SyslParserE_MOD                = 94
	SyslParserE_MINUS              = 95
	SyslParserE_QN                 = 96
	SyslParserE_TILDE              = 97
	SyslParserE_NOT                = 98
	SyslParserE_XOR                = 99
	SyslParserE_LOGIC_OR           = 100
	SyslParserE_DOUBLE_AMP         = 101
	SyslParserE_AMP                = 102
	SyslParserE_BY                 = 103
	SyslParserE_AND                = 104
	SyslParserE_BITOR              = 105
	SyslParserE_STAR               = 106
	SyslParserE_AS                 = 107
	SyslParserE_VIA                = 108
	SyslParserE_IF                 = 109
	SyslParserE_THEN               = 110
	SyslParserE_ELSE               = 111
	SyslParserE_LET                = 112
	SyslParserE_TRUE               = 113
	SyslParserE_FALSE              = 114
	SyslParserE_NULL               = 115
	SyslParserE_BUTNOT             = 116
	SyslParserE_SET_OF             = 117
	SyslParserE_ASC                = 118
	SyslParserE_DESC               = 119
	SyslParserE_RELOPS_RANK        = 120
	SyslParserE_RELOPS_AGG         = 121
	SyslParserE_RELOPS_ANY         = 122
	SyslParserE_RELOPS_SINGLE_NULL = 123
	SyslParserE_RELOPS_SNAPSHOT    = 124
	SyslParserE_RELOPS_WHERE       = 125
	SyslParserE_RELOPS_COUNT       = 126
	SyslParserE_RELOPS_FLATTEN     = 127
	SyslParserE_RELOPS_FIRST       = 128
	SyslParserE_FUNC               = 129
	SyslParserE_STRING             = 130
	SyslParserE_DECIMAL            = 131
	SyslParserE_DIGITS             = 132
	SyslParserE_DOT_NAME_NL        = 133
	SyslParserE_Name               = 134
	SyslParserE_DOT                = 135
	SyslParserE_WS                 = 136
	SyslParserE_EMPTY_LINE         = 137
	SyslParserE_NL                 = 138
)

// SyslParser rules.
const (
	SyslParserRULE_modifier                   = 0
	SyslParserRULE_size_spec                  = 1
	SyslParserRULE_modifier_list              = 2
	SyslParserRULE_modifiers                  = 3
	SyslParserRULE_name_str                   = 4
	SyslParserRULE_reference                  = 5
	SyslParserRULE_doc_string                 = 6
	SyslParserRULE_quoted_string              = 7
	SyslParserRULE_array_of_strings           = 8
	SyslParserRULE_array_of_arrays            = 9
	SyslParserRULE_nvp                        = 10
	SyslParserRULE_attributes                 = 11
	SyslParserRULE_entry                      = 12
	SyslParserRULE_attribs_or_modifiers       = 13
	SyslParserRULE_user_defined_type          = 14
	SyslParserRULE_types                      = 15
	SyslParserRULE_set_of                     = 16
	SyslParserRULE_set_type                   = 17
	SyslParserRULE_collection_type            = 18
	SyslParserRULE_multi_line_docstring       = 19
	SyslParserRULE_annotation_value           = 20
	SyslParserRULE_annotation                 = 21
	SyslParserRULE_annotations                = 22
	SyslParserRULE_field_type                 = 23
	SyslParserRULE_array_size                 = 24
	SyslParserRULE_inplace_tuple              = 25
	SyslParserRULE_field                      = 26
	SyslParserRULE_inplace_table              = 27
	SyslParserRULE_table                      = 28
	SyslParserRULE_union                      = 29
	SyslParserRULE_package_name               = 30
	SyslParserRULE_sub_package                = 31
	SyslParserRULE_app_name                   = 32
	SyslParserRULE_name_with_attribs          = 33
	SyslParserRULE_model_name                 = 34
	SyslParserRULE_inplace_table_def          = 35
	SyslParserRULE_table_refs                 = 36
	SyslParserRULE_facade                     = 37
	SyslParserRULE_documentation_stmts        = 38
	SyslParserRULE_var_in_curly               = 39
	SyslParserRULE_query_var                  = 40
	SyslParserRULE_query_param                = 41
	SyslParserRULE_http_path_part             = 42
	SyslParserRULE_http_path_var_with_type    = 43
	SyslParserRULE_http_path_static           = 44
	SyslParserRULE_http_path_suffix           = 45
	SyslParserRULE_http_path                  = 46
	SyslParserRULE_endpoint_name              = 47
	SyslParserRULE_ret_stmt                   = 48
	SyslParserRULE_target                     = 49
	SyslParserRULE_target_endpoint            = 50
	SyslParserRULE_call_arg                   = 51
	SyslParserRULE_call_args                  = 52
	SyslParserRULE_call_stmt                  = 53
	SyslParserRULE_if_stmt                    = 54
	SyslParserRULE_else_stmt                  = 55
	SyslParserRULE_if_else                    = 56
	SyslParserRULE_for_stmt                   = 57
	SyslParserRULE_http_method_comment        = 58
	SyslParserRULE_group_stmt                 = 59
	SyslParserRULE_one_of_case_label          = 60
	SyslParserRULE_one_of_cases               = 61
	SyslParserRULE_one_of_stmt                = 62
	SyslParserRULE_text_stmt                  = 63
	SyslParserRULE_mixin                      = 64
	SyslParserRULE_param                      = 65
	SyslParserRULE_param_list                 = 66
	SyslParserRULE_params                     = 67
	SyslParserRULE_statements                 = 68
	SyslParserRULE_method_def                 = 69
	SyslParserRULE_shortcut                   = 70
	SyslParserRULE_simple_endpoint            = 71
	SyslParserRULE_rest_endpoint              = 72
	SyslParserRULE_collector_query_var        = 73
	SyslParserRULE_collector_query_param      = 74
	SyslParserRULE_collector_call_stmt        = 75
	SyslParserRULE_collector_http_stmt_part   = 76
	SyslParserRULE_collector_http_stmt_suffix = 77
	SyslParserRULE_collector_http_stmt        = 78
	SyslParserRULE_publisher                  = 79
	SyslParserRULE_subscriber                 = 80
	SyslParserRULE_collector_pubsub_call      = 81
	SyslParserRULE_collector_action_stmt      = 82
	SyslParserRULE_collector_stmts            = 83
	SyslParserRULE_collector                  = 84
	SyslParserRULE_event                      = 85
	SyslParserRULE_subscribe                  = 86
	SyslParserRULE_view_type_spec             = 87
	SyslParserRULE_literal                    = 88
	SyslParserRULE_expr_table_of_op           = 89
	SyslParserRULE_func_arg                   = 90
	SyslParserRULE_func_args                  = 91
	SyslParserRULE_expr_func                  = 92
	SyslParserRULE_rank_expr                  = 93
	SyslParserRULE_rank_expr_list             = 94
	SyslParserRULE_expr_rank_func             = 95
	SyslParserRULE_expr_agg_func              = 96
	SyslParserRULE_e_scope_var                = 97
	SyslParserRULE_first_func_target          = 98
	SyslParserRULE_expr_first_func            = 99
	SyslParserRULE_e_single_arg_func          = 100
	SyslParserRULE_expr_single_arg_func       = 101
	SyslParserRULE_expr_any_func              = 102
	SyslParserRULE_expr_single_or_null        = 103
	SyslParserRULE_expr_snapshot              = 104
	SyslParserRULE_expr_count                 = 105
	SyslParserRULE_expr_navigate_attr         = 106
	SyslParserRULE_expr_navigate              = 107
	SyslParserRULE_matching_rhs               = 108
	SyslParserRULE_squiggly_args              = 109
	SyslParserRULE_expr_matching              = 110
	SyslParserRULE_relop                      = 111
	SyslParserRULE_list_item                  = 112
	SyslParserRULE_expr_list                  = 113
	SyslParserRULE_expr_set                   = 114
	SyslParserRULE_empty_tuple                = 115
	SyslParserRULE_atom_dot_relop             = 116
	SyslParserRULE_atomT_implied_dot          = 117
	SyslParserRULE_atomT_name                 = 118
	SyslParserRULE_atomT_paren                = 119
	SyslParserRULE_expr_atom_list             = 120
	SyslParserRULE_atomT                      = 121
	SyslParserRULE_atom                       = 122
	SyslParserRULE_powerT                     = 123
	SyslParserRULE_power                      = 124
	SyslParserRULE_unaryTerm                  = 125
	SyslParserRULE_termT                      = 126
	SyslParserRULE_term                       = 127
	SyslParserRULE_binexprT                   = 128
	SyslParserRULE_binexpr                    = 129
	SyslParserRULE_e_compare_ops              = 130
	SyslParserRULE_expr_rel                   = 131
	SyslParserRULE_expr_bitand                = 132
	SyslParserRULE_expr_bitxor                = 133
	SyslParserRULE_expr_bitor                 = 134
	SyslParserRULE_expr_and                   = 135
	SyslParserRULE_expr_or                    = 136
	SyslParserRULE_expr_but_not               = 137
	SyslParserRULE_expr_coalesce              = 138
	SyslParserRULE_if_one_liner               = 139
	SyslParserRULE_else_block_stmt            = 140
	SyslParserRULE_control_item               = 141
	SyslParserRULE_if_controls                = 142
	SyslParserRULE_cond_block                 = 143
	SyslParserRULE_final_else                 = 144
	SyslParserRULE_ifvar                      = 145
	SyslParserRULE_if_multiple_lines          = 146
	SyslParserRULE_expr_if_else               = 147
	SyslParserRULE_expr                       = 148
	SyslParserRULE_expr_assign                = 149
	SyslParserRULE_expr_simple_assign         = 150
	SyslParserRULE_expr_let_statement         = 151
	SyslParserRULE_expr_table_of_statement    = 152
	SyslParserRULE_expr_dot_assign            = 153
	SyslParserRULE_expr_statement_no_nl       = 154
	SyslParserRULE_expr_statement             = 155
	SyslParserRULE_expr_inject_stmt           = 156
	SyslParserRULE_expr_stmt                  = 157
	SyslParserRULE_transform_return_type      = 158
	SyslParserRULE_view_return_type           = 159
	SyslParserRULE_transform_scope_var        = 160
	SyslParserRULE_transform_arg              = 161
	SyslParserRULE_transform                  = 162
	SyslParserRULE_expr_block                 = 163
	SyslParserRULE_view_param                 = 164
	SyslParserRULE_view_params                = 165
	SyslParserRULE_abstract_view              = 166
	SyslParserRULE_view                       = 167
	SyslParserRULE_app_decl                   = 168
	SyslParserRULE_application                = 169
	SyslParserRULE_path                       = 170
	SyslParserRULE_import_stmt                = 171
	SyslParserRULE_imports_decl               = 172
	SyslParserRULE_sysl_file                  = 173
)

// IModifierContext is an interface to support dynamic dispatch.
type IModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifierContext differentiates from other interfaces.
	IsModifierContext()
}

type ModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierContext() *ModifierContext {
	var p = new(ModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_modifier
	return p
}

func (*ModifierContext) IsModifierContext() {}

func NewModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierContext {
	var p = new(ModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_modifier

	return p
}

func (s *ModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierContext) TILDE() antlr.TerminalNode {
	return s.GetToken(SyslParserTILDE, 0)
}

func (s *ModifierContext) AllName() []antlr.TerminalNode {
	return s.GetTokens(SyslParserName)
}

func (s *ModifierContext) Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserName, i)
}

func (s *ModifierContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(SyslParserPLUS)
}

func (s *ModifierContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserPLUS, i)
}

func (s *ModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterModifier(s)
	}
}

func (s *ModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitModifier(s)
	}
}

func (p *SyslParser) Modifier() (localctx IModifierContext) {
	localctx = NewModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SyslParserRULE_modifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(348)
		p.Match(SyslParserTILDE)
	}
	{
		p.SetState(349)
		p.Match(SyslParserName)
	}
	p.SetState(354)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserPLUS {
		{
			p.SetState(350)
			p.Match(SyslParserPLUS)
		}
		{
			p.SetState(351)
			p.Match(SyslParserName)
		}

		p.SetState(356)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISize_specContext is an interface to support dynamic dispatch.
type ISize_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSize_specContext differentiates from other interfaces.
	IsSize_specContext()
}

type Size_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySize_specContext() *Size_specContext {
	var p = new(Size_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_size_spec
	return p
}

func (*Size_specContext) IsSize_specContext() {}

func NewSize_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Size_specContext {
	var p = new(Size_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_size_spec

	return p
}

func (s *Size_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Size_specContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *Size_specContext) AllDIGITS() []antlr.TerminalNode {
	return s.GetTokens(SyslParserDIGITS)
}

func (s *Size_specContext) DIGITS(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserDIGITS, i)
}

func (s *Size_specContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *Size_specContext) DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserDOT, 0)
}

func (s *Size_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Size_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Size_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSize_spec(s)
	}
}

func (s *Size_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSize_spec(s)
	}
}

func (p *SyslParser) Size_spec() (localctx ISize_specContext) {
	localctx = NewSize_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SyslParserRULE_size_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(357)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(358)
		p.Match(SyslParserDIGITS)
	}
	p.SetState(361)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserDOT {
		{
			p.SetState(359)
			p.Match(SyslParserDOT)
		}
		{
			p.SetState(360)
			p.Match(SyslParserDIGITS)
		}

	}
	{
		p.SetState(363)
		p.Match(SyslParserCLOSE_PAREN)
	}

	return localctx
}

// IModifier_listContext is an interface to support dynamic dispatch.
type IModifier_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifier_listContext differentiates from other interfaces.
	IsModifier_listContext()
}

type Modifier_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifier_listContext() *Modifier_listContext {
	var p = new(Modifier_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_modifier_list
	return p
}

func (*Modifier_listContext) IsModifier_listContext() {}

func NewModifier_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Modifier_listContext {
	var p = new(Modifier_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_modifier_list

	return p
}

func (s *Modifier_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Modifier_listContext) AllModifier() []IModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModifierContext)(nil)).Elem())
	var tst = make([]IModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModifierContext)
		}
	}

	return tst
}

func (s *Modifier_listContext) Modifier(i int) IModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *Modifier_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Modifier_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Modifier_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Modifier_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Modifier_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterModifier_list(s)
	}
}

func (s *Modifier_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitModifier_list(s)
	}
}

func (p *SyslParser) Modifier_list() (localctx IModifier_listContext) {
	localctx = NewModifier_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SyslParserRULE_modifier_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(365)
		p.Modifier()
	}
	p.SetState(370)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(366)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(367)
			p.Modifier()
		}

		p.SetState(372)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IModifiersContext is an interface to support dynamic dispatch.
type IModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifiersContext differentiates from other interfaces.
	IsModifiersContext()
}

type ModifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifiersContext() *ModifiersContext {
	var p = new(ModifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_modifiers
	return p
}

func (*ModifiersContext) IsModifiersContext() {}

func NewModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifiersContext {
	var p = new(ModifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_modifiers

	return p
}

func (s *ModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifiersContext) SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_OPEN, 0)
}

func (s *ModifiersContext) Modifier_list() IModifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifier_listContext)
}

func (s *ModifiersContext) SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_CLOSE, 0)
}

func (s *ModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterModifiers(s)
	}
}

func (s *ModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitModifiers(s)
	}
}

func (p *SyslParser) Modifiers() (localctx IModifiersContext) {
	localctx = NewModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SyslParserRULE_modifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(373)
		p.Match(SyslParserSQ_OPEN)
	}
	{
		p.SetState(374)
		p.Modifier_list()
	}
	{
		p.SetState(375)
		p.Match(SyslParserSQ_CLOSE)
	}

	return localctx
}

// IName_strContext is an interface to support dynamic dispatch.
type IName_strContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_strContext differentiates from other interfaces.
	IsName_strContext()
}

type Name_strContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_strContext() *Name_strContext {
	var p = new(Name_strContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_name_str
	return p
}

func (*Name_strContext) IsName_strContext() {}

func NewName_strContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_strContext {
	var p = new(Name_strContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_name_str

	return p
}

func (s *Name_strContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_strContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Name_strContext) TEXT_LINE() antlr.TerminalNode {
	return s.GetToken(SyslParserTEXT_LINE, 0)
}

func (s *Name_strContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Name_strContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_strContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_strContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterName_str(s)
	}
}

func (s *Name_strContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitName_str(s)
	}
}

func (p *SyslParser) Name_str() (localctx IName_strContext) {
	localctx = NewName_strContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SyslParserRULE_name_str)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(377)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserTEXT_LINE || _la == SyslParserName || _la == SyslParserE_Name) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IReferenceContext is an interface to support dynamic dispatch.
type IReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceContext differentiates from other interfaces.
	IsReferenceContext()
}

type ReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceContext() *ReferenceContext {
	var p = new(ReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_reference
	return p
}

func (*ReferenceContext) IsReferenceContext() {}

func NewReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceContext {
	var p = new(ReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_reference

	return p
}

func (s *ReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *ReferenceContext) AllName_str() []IName_strContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IName_strContext)(nil)).Elem())
	var tst = make([]IName_strContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IName_strContext)
		}
	}

	return tst
}

func (s *ReferenceContext) Name_str(i int) IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *ReferenceContext) AllE_DOT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_DOT)
}

func (s *ReferenceContext) E_DOT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, i)
}

func (s *ReferenceContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserDOT)
}

func (s *ReferenceContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserDOT, i)
}

func (s *ReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterReference(s)
	}
}

func (s *ReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitReference(s)
	}
}

func (p *SyslParser) Reference() (localctx IReferenceContext) {
	localctx = NewReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SyslParserRULE_reference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(379)
		p.App_name()
	}
	p.SetState(382)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserDOT || _la == SyslParserE_DOT {
		p.SetState(380)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SyslParserDOT || _la == SyslParserE_DOT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		{
			p.SetState(381)
			p.Name_str()
		}

		p.SetState(384)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDoc_stringContext is an interface to support dynamic dispatch.
type IDoc_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDoc_stringContext differentiates from other interfaces.
	IsDoc_stringContext()
}

type Doc_stringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoc_stringContext() *Doc_stringContext {
	var p = new(Doc_stringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_doc_string
	return p
}

func (*Doc_stringContext) IsDoc_stringContext() {}

func NewDoc_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Doc_stringContext {
	var p = new(Doc_stringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_doc_string

	return p
}

func (s *Doc_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Doc_stringContext) PIPE() antlr.TerminalNode {
	return s.GetToken(SyslParserPIPE, 0)
}

func (s *Doc_stringContext) TEXT() antlr.TerminalNode {
	return s.GetToken(SyslParserTEXT, 0)
}

func (s *Doc_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Doc_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Doc_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterDoc_string(s)
	}
}

func (s *Doc_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitDoc_string(s)
	}
}

func (p *SyslParser) Doc_string() (localctx IDoc_stringContext) {
	localctx = NewDoc_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SyslParserRULE_doc_string)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(386)
		p.Match(SyslParserPIPE)
	}
	{
		p.SetState(387)
		p.Match(SyslParserTEXT)
	}

	return localctx
}

// IQuoted_stringContext is an interface to support dynamic dispatch.
type IQuoted_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuoted_stringContext differentiates from other interfaces.
	IsQuoted_stringContext()
}

type Quoted_stringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuoted_stringContext() *Quoted_stringContext {
	var p = new(Quoted_stringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_quoted_string
	return p
}

func (*Quoted_stringContext) IsQuoted_stringContext() {}

func NewQuoted_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Quoted_stringContext {
	var p = new(Quoted_stringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_quoted_string

	return p
}

func (s *Quoted_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Quoted_stringContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Quoted_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quoted_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Quoted_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterQuoted_string(s)
	}
}

func (s *Quoted_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitQuoted_string(s)
	}
}

func (p *SyslParser) Quoted_string() (localctx IQuoted_stringContext) {
	localctx = NewQuoted_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SyslParserRULE_quoted_string)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(389)
		p.Match(SyslParserQSTRING)
	}

	return localctx
}

// IArray_of_stringsContext is an interface to support dynamic dispatch.
type IArray_of_stringsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_of_stringsContext differentiates from other interfaces.
	IsArray_of_stringsContext()
}

type Array_of_stringsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_of_stringsContext() *Array_of_stringsContext {
	var p = new(Array_of_stringsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_array_of_strings
	return p
}

func (*Array_of_stringsContext) IsArray_of_stringsContext() {}

func NewArray_of_stringsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_of_stringsContext {
	var p = new(Array_of_stringsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_array_of_strings

	return p
}

func (s *Array_of_stringsContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_of_stringsContext) SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_OPEN, 0)
}

func (s *Array_of_stringsContext) AllQuoted_string() []IQuoted_stringContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem())
	var tst = make([]IQuoted_stringContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQuoted_stringContext)
		}
	}

	return tst
}

func (s *Array_of_stringsContext) Quoted_string(i int) IQuoted_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *Array_of_stringsContext) SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_CLOSE, 0)
}

func (s *Array_of_stringsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Array_of_stringsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Array_of_stringsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_of_stringsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_of_stringsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterArray_of_strings(s)
	}
}

func (s *Array_of_stringsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitArray_of_strings(s)
	}
}

func (p *SyslParser) Array_of_strings() (localctx IArray_of_stringsContext) {
	localctx = NewArray_of_stringsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SyslParserRULE_array_of_strings)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(391)
		p.Match(SyslParserSQ_OPEN)
	}
	{
		p.SetState(392)
		p.Quoted_string()
	}
	p.SetState(397)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(393)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(394)
			p.Quoted_string()
		}

		p.SetState(399)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(400)
		p.Match(SyslParserSQ_CLOSE)
	}

	return localctx
}

// IArray_of_arraysContext is an interface to support dynamic dispatch.
type IArray_of_arraysContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_of_arraysContext differentiates from other interfaces.
	IsArray_of_arraysContext()
}

type Array_of_arraysContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_of_arraysContext() *Array_of_arraysContext {
	var p = new(Array_of_arraysContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_array_of_arrays
	return p
}

func (*Array_of_arraysContext) IsArray_of_arraysContext() {}

func NewArray_of_arraysContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_of_arraysContext {
	var p = new(Array_of_arraysContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_array_of_arrays

	return p
}

func (s *Array_of_arraysContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_of_arraysContext) SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_OPEN, 0)
}

func (s *Array_of_arraysContext) AllArray_of_strings() []IArray_of_stringsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArray_of_stringsContext)(nil)).Elem())
	var tst = make([]IArray_of_stringsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArray_of_stringsContext)
		}
	}

	return tst
}

func (s *Array_of_arraysContext) Array_of_strings(i int) IArray_of_stringsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_of_stringsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArray_of_stringsContext)
}

func (s *Array_of_arraysContext) SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_CLOSE, 0)
}

func (s *Array_of_arraysContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Array_of_arraysContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Array_of_arraysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_of_arraysContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_of_arraysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterArray_of_arrays(s)
	}
}

func (s *Array_of_arraysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitArray_of_arrays(s)
	}
}

func (p *SyslParser) Array_of_arrays() (localctx IArray_of_arraysContext) {
	localctx = NewArray_of_arraysContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SyslParserRULE_array_of_arrays)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(402)
		p.Match(SyslParserSQ_OPEN)
	}
	{
		p.SetState(403)
		p.Array_of_strings()
	}
	p.SetState(408)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(404)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(405)
			p.Array_of_strings()
		}

		p.SetState(410)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(411)
		p.Match(SyslParserSQ_CLOSE)
	}

	return localctx
}

// INvpContext is an interface to support dynamic dispatch.
type INvpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNvpContext differentiates from other interfaces.
	IsNvpContext()
}

type NvpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNvpContext() *NvpContext {
	var p = new(NvpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_nvp
	return p
}

func (*NvpContext) IsNvpContext() {}

func NewNvpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NvpContext {
	var p = new(NvpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_nvp

	return p
}

func (s *NvpContext) GetParser() antlr.Parser { return s.parser }

func (s *NvpContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *NvpContext) EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserEQ, 0)
}

func (s *NvpContext) Quoted_string() IQuoted_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *NvpContext) Array_of_strings() IArray_of_stringsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_of_stringsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_of_stringsContext)
}

func (s *NvpContext) Array_of_arrays() IArray_of_arraysContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_of_arraysContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_of_arraysContext)
}

func (s *NvpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NvpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NvpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterNvp(s)
	}
}

func (s *NvpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitNvp(s)
	}
}

func (p *SyslParser) Nvp() (localctx INvpContext) {
	localctx = NewNvpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SyslParserRULE_nvp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(413)
		p.Match(SyslParserName)
	}
	{
		p.SetState(414)
		p.Match(SyslParserEQ)
	}
	p.SetState(418)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(415)
			p.Quoted_string()
		}

	case 2:
		{
			p.SetState(416)
			p.Array_of_strings()
		}

	case 3:
		{
			p.SetState(417)
			p.Array_of_arrays()
		}

	}

	return localctx
}

// IAttributesContext is an interface to support dynamic dispatch.
type IAttributesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributesContext differentiates from other interfaces.
	IsAttributesContext()
}

type AttributesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributesContext() *AttributesContext {
	var p = new(AttributesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_attributes
	return p
}

func (*AttributesContext) IsAttributesContext() {}

func NewAttributesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributesContext {
	var p = new(AttributesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_attributes

	return p
}

func (s *AttributesContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributesContext) SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_OPEN, 0)
}

func (s *AttributesContext) AllNvp() []INvpContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INvpContext)(nil)).Elem())
	var tst = make([]INvpContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INvpContext)
		}
	}

	return tst
}

func (s *AttributesContext) Nvp(i int) INvpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INvpContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INvpContext)
}

func (s *AttributesContext) SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_CLOSE, 0)
}

func (s *AttributesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *AttributesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *AttributesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAttributes(s)
	}
}

func (s *AttributesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAttributes(s)
	}
}

func (p *SyslParser) Attributes() (localctx IAttributesContext) {
	localctx = NewAttributesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SyslParserRULE_attributes)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(420)
		p.Match(SyslParserSQ_OPEN)
	}
	{
		p.SetState(421)
		p.Nvp()
	}
	p.SetState(426)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(422)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(423)
			p.Nvp()
		}

		p.SetState(428)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(429)
		p.Match(SyslParserSQ_CLOSE)
	}

	return localctx
}

// IEntryContext is an interface to support dynamic dispatch.
type IEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntryContext differentiates from other interfaces.
	IsEntryContext()
}

type EntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntryContext() *EntryContext {
	var p = new(EntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_entry
	return p
}

func (*EntryContext) IsEntryContext() {}

func NewEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EntryContext {
	var p = new(EntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_entry

	return p
}

func (s *EntryContext) GetParser() antlr.Parser { return s.parser }

func (s *EntryContext) Nvp() INvpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INvpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INvpContext)
}

func (s *EntryContext) Modifier() IModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *EntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterEntry(s)
	}
}

func (s *EntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitEntry(s)
	}
}

func (p *SyslParser) Entry() (localctx IEntryContext) {
	localctx = NewEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SyslParserRULE_entry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(433)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(431)
			p.Nvp()
		}

	case SyslParserTILDE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(432)
			p.Modifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAttribs_or_modifiersContext is an interface to support dynamic dispatch.
type IAttribs_or_modifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribs_or_modifiersContext differentiates from other interfaces.
	IsAttribs_or_modifiersContext()
}

type Attribs_or_modifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribs_or_modifiersContext() *Attribs_or_modifiersContext {
	var p = new(Attribs_or_modifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_attribs_or_modifiers
	return p
}

func (*Attribs_or_modifiersContext) IsAttribs_or_modifiersContext() {}

func NewAttribs_or_modifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribs_or_modifiersContext {
	var p = new(Attribs_or_modifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_attribs_or_modifiers

	return p
}

func (s *Attribs_or_modifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribs_or_modifiersContext) SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_OPEN, 0)
}

func (s *Attribs_or_modifiersContext) AllEntry() []IEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEntryContext)(nil)).Elem())
	var tst = make([]IEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEntryContext)
		}
	}

	return tst
}

func (s *Attribs_or_modifiersContext) Entry(i int) IEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEntryContext)
}

func (s *Attribs_or_modifiersContext) SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_CLOSE, 0)
}

func (s *Attribs_or_modifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Attribs_or_modifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Attribs_or_modifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribs_or_modifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribs_or_modifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAttribs_or_modifiers(s)
	}
}

func (s *Attribs_or_modifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAttribs_or_modifiers(s)
	}
}

func (p *SyslParser) Attribs_or_modifiers() (localctx IAttribs_or_modifiersContext) {
	localctx = NewAttribs_or_modifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SyslParserRULE_attribs_or_modifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(435)
		p.Match(SyslParserSQ_OPEN)
	}
	{
		p.SetState(436)
		p.Entry()
	}
	p.SetState(441)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(437)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(438)
			p.Entry()
		}

		p.SetState(443)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(444)
		p.Match(SyslParserSQ_CLOSE)
	}

	return localctx
}

// IUser_defined_typeContext is an interface to support dynamic dispatch.
type IUser_defined_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUser_defined_typeContext differentiates from other interfaces.
	IsUser_defined_typeContext()
}

type User_defined_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUser_defined_typeContext() *User_defined_typeContext {
	var p = new(User_defined_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_user_defined_type
	return p
}

func (*User_defined_typeContext) IsUser_defined_typeContext() {}

func NewUser_defined_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *User_defined_typeContext {
	var p = new(User_defined_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_user_defined_type

	return p
}

func (s *User_defined_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *User_defined_typeContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *User_defined_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *User_defined_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *User_defined_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterUser_defined_type(s)
	}
}

func (s *User_defined_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitUser_defined_type(s)
	}
}

func (p *SyslParser) User_defined_type() (localctx IUser_defined_typeContext) {
	localctx = NewUser_defined_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SyslParserRULE_user_defined_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(446)
		p.Name_str()
	}

	return localctx
}

// ITypesContext is an interface to support dynamic dispatch.
type ITypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypesContext differentiates from other interfaces.
	IsTypesContext()
}

type TypesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypesContext() *TypesContext {
	var p = new(TypesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_types
	return p
}

func (*TypesContext) IsTypesContext() {}

func NewTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypesContext {
	var p = new(TypesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_types

	return p
}

func (s *TypesContext) GetParser() antlr.Parser { return s.parser }

func (s *TypesContext) User_defined_type() IUser_defined_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUser_defined_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUser_defined_typeContext)
}

func (s *TypesContext) Reference() IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *TypesContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *TypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTypes(s)
	}
}

func (s *TypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTypes(s)
	}
}

func (p *SyslParser) Types() (localctx ITypesContext) {
	localctx = NewTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SyslParserRULE_types)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(451)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(448)
			p.User_defined_type()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(449)
			p.Reference()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(450)
			p.Match(SyslParserNativeDataTypes)
		}

	}

	return localctx
}

// ISet_ofContext is an interface to support dynamic dispatch.
type ISet_ofContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_ofContext differentiates from other interfaces.
	IsSet_ofContext()
}

type Set_ofContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_ofContext() *Set_ofContext {
	var p = new(Set_ofContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_set_of
	return p
}

func (*Set_ofContext) IsSet_ofContext() {}

func NewSet_ofContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_ofContext {
	var p = new(Set_ofContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_set_of

	return p
}

func (s *Set_ofContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_ofContext) SET_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserSET_OF, 0)
}

func (s *Set_ofContext) E_SET_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SET_OF, 0)
}

func (s *Set_ofContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_ofContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_ofContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSet_of(s)
	}
}

func (s *Set_ofContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSet_of(s)
	}
}

func (p *SyslParser) Set_of() (localctx ISet_ofContext) {
	localctx = NewSet_ofContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SyslParserRULE_set_of)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(455)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserSET_OF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(453)
			p.Match(SyslParserSET_OF)
		}

	case SyslParserE_SET_OF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(454)
			p.Match(SyslParserE_SET_OF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISet_typeContext is an interface to support dynamic dispatch.
type ISet_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_typeContext differentiates from other interfaces.
	IsSet_typeContext()
}

type Set_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_typeContext() *Set_typeContext {
	var p = new(Set_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_set_type
	return p
}

func (*Set_typeContext) IsSet_typeContext() {}

func NewSet_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_typeContext {
	var p = new(Set_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_set_type

	return p
}

func (s *Set_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_typeContext) Set_of() ISet_ofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_ofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_ofContext)
}

func (s *Set_typeContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *Set_typeContext) Size_spec() ISize_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISize_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISize_specContext)
}

func (s *Set_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSet_type(s)
	}
}

func (s *Set_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSet_type(s)
	}
}

func (p *SyslParser) Set_type() (localctx ISet_typeContext) {
	localctx = NewSet_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SyslParserRULE_set_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(457)
		p.Set_of()
	}
	{
		p.SetState(458)
		p.Types()
	}
	p.SetState(460)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserOPEN_PAREN {
		{
			p.SetState(459)
			p.Size_spec()
		}

	}

	return localctx
}

// ICollection_typeContext is an interface to support dynamic dispatch.
type ICollection_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollection_typeContext differentiates from other interfaces.
	IsCollection_typeContext()
}

type Collection_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollection_typeContext() *Collection_typeContext {
	var p = new(Collection_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collection_type
	return p
}

func (*Collection_typeContext) IsCollection_typeContext() {}

func NewCollection_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collection_typeContext {
	var p = new(Collection_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collection_type

	return p
}

func (s *Collection_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Collection_typeContext) Set_type() ISet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_typeContext)
}

func (s *Collection_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collection_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collection_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollection_type(s)
	}
}

func (s *Collection_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollection_type(s)
	}
}

func (p *SyslParser) Collection_type() (localctx ICollection_typeContext) {
	localctx = NewCollection_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SyslParserRULE_collection_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(462)
		p.Set_type()
	}

	return localctx
}

// IMulti_line_docstringContext is an interface to support dynamic dispatch.
type IMulti_line_docstringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMulti_line_docstringContext differentiates from other interfaces.
	IsMulti_line_docstringContext()
}

type Multi_line_docstringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMulti_line_docstringContext() *Multi_line_docstringContext {
	var p = new(Multi_line_docstringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_multi_line_docstring
	return p
}

func (*Multi_line_docstringContext) IsMulti_line_docstringContext() {}

func NewMulti_line_docstringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multi_line_docstringContext {
	var p = new(Multi_line_docstringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_multi_line_docstring

	return p
}

func (s *Multi_line_docstringContext) GetParser() antlr.Parser { return s.parser }

func (s *Multi_line_docstringContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Multi_line_docstringContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Multi_line_docstringContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Multi_line_docstringContext) AllDoc_string() []IDoc_stringContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDoc_stringContext)(nil)).Elem())
	var tst = make([]IDoc_stringContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDoc_stringContext)
		}
	}

	return tst
}

func (s *Multi_line_docstringContext) Doc_string(i int) IDoc_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDoc_stringContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDoc_stringContext)
}

func (s *Multi_line_docstringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multi_line_docstringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multi_line_docstringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterMulti_line_docstring(s)
	}
}

func (s *Multi_line_docstringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitMulti_line_docstring(s)
	}
}

func (p *SyslParser) Multi_line_docstring() (localctx IMulti_line_docstringContext) {
	localctx = NewMulti_line_docstringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SyslParserRULE_multi_line_docstring)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(464)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(465)
		p.Match(SyslParserINDENT)
	}
	p.SetState(467)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserPIPE {
		{
			p.SetState(466)
			p.Doc_string()
		}

		p.SetState(469)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(471)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IAnnotation_valueContext is an interface to support dynamic dispatch.
type IAnnotation_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotation_valueContext differentiates from other interfaces.
	IsAnnotation_valueContext()
}

type Annotation_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotation_valueContext() *Annotation_valueContext {
	var p = new(Annotation_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_annotation_value
	return p
}

func (*Annotation_valueContext) IsAnnotation_valueContext() {}

func NewAnnotation_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Annotation_valueContext {
	var p = new(Annotation_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_annotation_value

	return p
}

func (s *Annotation_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Annotation_valueContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Annotation_valueContext) Array_of_strings() IArray_of_stringsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_of_stringsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_of_stringsContext)
}

func (s *Annotation_valueContext) Multi_line_docstring() IMulti_line_docstringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_line_docstringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_line_docstringContext)
}

func (s *Annotation_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Annotation_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Annotation_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAnnotation_value(s)
	}
}

func (s *Annotation_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAnnotation_value(s)
	}
}

func (p *SyslParser) Annotation_value() (localctx IAnnotation_valueContext) {
	localctx = NewAnnotation_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SyslParserRULE_annotation_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(476)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserQSTRING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(473)
			p.Match(SyslParserQSTRING)
		}

	case SyslParserSQ_OPEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(474)
			p.Array_of_strings()
		}

	case SyslParserCOLON:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(475)
			p.Multi_line_docstring()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_annotation
	return p
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) AT() antlr.TerminalNode {
	return s.GetToken(SyslParserAT, 0)
}

func (s *AnnotationContext) VAR_NAME() antlr.TerminalNode {
	return s.GetToken(SyslParserVAR_NAME, 0)
}

func (s *AnnotationContext) EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserEQ, 0)
}

func (s *AnnotationContext) Annotation_value() IAnnotation_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotation_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotation_valueContext)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAnnotation(s)
	}
}

func (s *AnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAnnotation(s)
	}
}

func (p *SyslParser) Annotation() (localctx IAnnotationContext) {
	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SyslParserRULE_annotation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(478)
		p.Match(SyslParserAT)
	}
	{
		p.SetState(479)
		p.Match(SyslParserVAR_NAME)
	}
	{
		p.SetState(480)
		p.Match(SyslParserEQ)
	}
	{
		p.SetState(481)
		p.Annotation_value()
	}

	return localctx
}

// IAnnotationsContext is an interface to support dynamic dispatch.
type IAnnotationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationsContext differentiates from other interfaces.
	IsAnnotationsContext()
}

type AnnotationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationsContext() *AnnotationsContext {
	var p = new(AnnotationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_annotations
	return p
}

func (*AnnotationsContext) IsAnnotationsContext() {}

func NewAnnotationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationsContext {
	var p = new(AnnotationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_annotations

	return p
}

func (s *AnnotationsContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationsContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *AnnotationsContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *AnnotationsContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *AnnotationsContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AnnotationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAnnotations(s)
	}
}

func (s *AnnotationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAnnotations(s)
	}
}

func (p *SyslParser) Annotations() (localctx IAnnotationsContext) {
	localctx = NewAnnotationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SyslParserRULE_annotations)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(483)
		p.Match(SyslParserINDENT)
	}
	p.SetState(485)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserAT {
		{
			p.SetState(484)
			p.Annotation()
		}

		p.SetState(487)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(489)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IField_typeContext is an interface to support dynamic dispatch.
type IField_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsField_typeContext differentiates from other interfaces.
	IsField_typeContext()
}

type Field_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyField_typeContext() *Field_typeContext {
	var p = new(Field_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_field_type
	return p
}

func (*Field_typeContext) IsField_typeContext() {}

func NewField_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Field_typeContext {
	var p = new(Field_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_field_type

	return p
}

func (s *Field_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Field_typeContext) Collection_type() ICollection_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollection_typeContext)
}

func (s *Field_typeContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *Field_typeContext) Array_size() IArray_sizeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_sizeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_sizeContext)
}

func (s *Field_typeContext) Size_spec() ISize_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISize_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISize_specContext)
}

func (s *Field_typeContext) QN() antlr.TerminalNode {
	return s.GetToken(SyslParserQN, 0)
}

func (s *Field_typeContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Field_typeContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Field_typeContext) Annotations() IAnnotationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsContext)
}

func (s *Field_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Field_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Field_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterField_type(s)
	}
}

func (s *Field_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitField_type(s)
	}
}

func (p *SyslParser) Field_type() (localctx IField_typeContext) {
	localctx = NewField_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SyslParserRULE_field_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(507)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserSET_OF, SyslParserE_SET_OF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(491)
			p.Collection_type()
		}

	case SyslParserNativeDataTypes, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(492)
			p.Types()
		}
		p.SetState(495)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(493)
				p.Array_size()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(494)
				p.Size_spec()
			}

		}
		p.SetState(498)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserQN {
			{
				p.SetState(497)
				p.Match(SyslParserQN)
			}

		}
		p.SetState(501)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserSQ_OPEN {
			{
				p.SetState(500)
				p.Attribs_or_modifiers()
			}

		}
		p.SetState(505)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserCOLON {
			{
				p.SetState(503)
				p.Match(SyslParserCOLON)
			}
			{
				p.SetState(504)
				p.Annotations()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArray_sizeContext is an interface to support dynamic dispatch.
type IArray_sizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_sizeContext differentiates from other interfaces.
	IsArray_sizeContext()
}

type Array_sizeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_sizeContext() *Array_sizeContext {
	var p = new(Array_sizeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_array_size
	return p
}

func (*Array_sizeContext) IsArray_sizeContext() {}

func NewArray_sizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_sizeContext {
	var p = new(Array_sizeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_array_size

	return p
}

func (s *Array_sizeContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_sizeContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *Array_sizeContext) AllDIGITS() []antlr.TerminalNode {
	return s.GetTokens(SyslParserDIGITS)
}

func (s *Array_sizeContext) DIGITS(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserDIGITS, i)
}

func (s *Array_sizeContext) DOTDOT() antlr.TerminalNode {
	return s.GetToken(SyslParserDOTDOT, 0)
}

func (s *Array_sizeContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *Array_sizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_sizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_sizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterArray_size(s)
	}
}

func (s *Array_sizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitArray_size(s)
	}
}

func (p *SyslParser) Array_size() (localctx IArray_sizeContext) {
	localctx = NewArray_sizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SyslParserRULE_array_size)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(509)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(510)
		p.Match(SyslParserDIGITS)
	}
	{
		p.SetState(511)
		p.Match(SyslParserDOTDOT)
	}
	p.SetState(513)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserDIGITS {
		{
			p.SetState(512)
			p.Match(SyslParserDIGITS)
		}

	}
	{
		p.SetState(515)
		p.Match(SyslParserCLOSE_PAREN)
	}

	return localctx
}

// IInplace_tupleContext is an interface to support dynamic dispatch.
type IInplace_tupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInplace_tupleContext differentiates from other interfaces.
	IsInplace_tupleContext()
}

type Inplace_tupleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInplace_tupleContext() *Inplace_tupleContext {
	var p = new(Inplace_tupleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_inplace_tuple
	return p
}

func (*Inplace_tupleContext) IsInplace_tupleContext() {}

func NewInplace_tupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inplace_tupleContext {
	var p = new(Inplace_tupleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_inplace_tuple

	return p
}

func (s *Inplace_tupleContext) GetParser() antlr.Parser { return s.parser }

func (s *Inplace_tupleContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Inplace_tupleContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Inplace_tupleContext) AllField() []IFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFieldContext)(nil)).Elem())
	var tst = make([]IFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFieldContext)
		}
	}

	return tst
}

func (s *Inplace_tupleContext) Field(i int) IFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFieldContext)
}

func (s *Inplace_tupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inplace_tupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inplace_tupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterInplace_tuple(s)
	}
}

func (s *Inplace_tupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitInplace_tuple(s)
	}
}

func (p *SyslParser) Inplace_tuple() (localctx IInplace_tupleContext) {
	localctx = NewInplace_tupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SyslParserRULE_inplace_tuple)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(517)
		p.Match(SyslParserINDENT)
	}
	p.SetState(519)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserTEXT_LINE || _la == SyslParserName || _la == SyslParserE_Name {
		{
			p.SetState(518)
			p.Field()
		}

		p.SetState(521)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(523)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IFieldContext is an interface to support dynamic dispatch.
type IFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldContext differentiates from other interfaces.
	IsFieldContext()
}

type FieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldContext() *FieldContext {
	var p = new(FieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_field
	return p
}

func (*FieldContext) IsFieldContext() {}

func NewFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldContext {
	var p = new(FieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_field

	return p
}

func (s *FieldContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *FieldContext) LESS_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserLESS_COLON, 0)
}

func (s *FieldContext) Field_type() IField_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IField_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IField_typeContext)
}

func (s *FieldContext) Inplace_tuple() IInplace_tupleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInplace_tupleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInplace_tupleContext)
}

func (s *FieldContext) Array_size() IArray_sizeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_sizeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_sizeContext)
}

func (s *FieldContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *FieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterField(s)
	}
}

func (s *FieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitField(s)
	}
}

func (p *SyslParser) Field() (localctx IFieldContext) {
	localctx = NewFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SyslParserRULE_field)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(525)
		p.Name_str()
	}
	p.SetState(537)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserLESS_COLON || _la == SyslParserOPEN_PAREN {
		p.SetState(527)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserOPEN_PAREN {
			{
				p.SetState(526)
				p.Array_size()
			}

		}
		{
			p.SetState(529)
			p.Match(SyslParserLESS_COLON)
		}
		p.SetState(532)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserNativeDataTypes, SyslParserSET_OF, SyslParserTEXT_LINE, SyslParserName, SyslParserE_SET_OF, SyslParserE_Name:
			{
				p.SetState(530)
				p.Field_type()
			}

		case SyslParserINDENT:
			{
				p.SetState(531)
				p.Inplace_tuple()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(535)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserQSTRING {
			{
				p.SetState(534)
				p.Match(SyslParserQSTRING)
			}

		}

	}

	return localctx
}

// IInplace_tableContext is an interface to support dynamic dispatch.
type IInplace_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInplace_tableContext differentiates from other interfaces.
	IsInplace_tableContext()
}

type Inplace_tableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInplace_tableContext() *Inplace_tableContext {
	var p = new(Inplace_tableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_inplace_table
	return p
}

func (*Inplace_tableContext) IsInplace_tableContext() {}

func NewInplace_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inplace_tableContext {
	var p = new(Inplace_tableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_inplace_table

	return p
}

func (s *Inplace_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *Inplace_tableContext) Table() ITableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *Inplace_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inplace_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inplace_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterInplace_table(s)
	}
}

func (s *Inplace_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitInplace_table(s)
	}
}

func (p *SyslParser) Inplace_table() (localctx IInplace_tableContext) {
	localctx = NewInplace_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SyslParserRULE_inplace_table)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(539)
		p.Table()
	}

	return localctx
}

// ITableContext is an interface to support dynamic dispatch.
type ITableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableContext differentiates from other interfaces.
	IsTableContext()
}

type TableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableContext() *TableContext {
	var p = new(TableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_table
	return p
}

func (*TableContext) IsTableContext() {}

func NewTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableContext {
	var p = new(TableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_table

	return p
}

func (s *TableContext) GetParser() antlr.Parser { return s.parser }

func (s *TableContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *TableContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *TableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SyslParserTABLE, 0)
}

func (s *TableContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SyslParserTYPE, 0)
}

func (s *TableContext) AllWHATEVER() []antlr.TerminalNode {
	return s.GetTokens(SyslParserWHATEVER)
}

func (s *TableContext) WHATEVER(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, i)
}

func (s *TableContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *TableContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *TableContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *TableContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *TableContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *TableContext) AllField() []IFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFieldContext)(nil)).Elem())
	var tst = make([]IFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFieldContext)
		}
	}

	return tst
}

func (s *TableContext) Field(i int) IFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFieldContext)
}

func (s *TableContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *TableContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TableContext) AllInplace_table() []IInplace_tableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInplace_tableContext)(nil)).Elem())
	var tst = make([]IInplace_tableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInplace_tableContext)
		}
	}

	return tst
}

func (s *TableContext) Inplace_table(i int) IInplace_tableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInplace_tableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInplace_tableContext)
}

func (s *TableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTable(s)
	}
}

func (s *TableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTable(s)
	}
}

func (p *SyslParser) Table() (localctx ITableContext) {
	localctx = NewTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SyslParserRULE_table)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(544)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserSYSL_COMMENT {
		{
			p.SetState(541)
			p.Match(SyslParserSYSL_COMMENT)
		}

		p.SetState(546)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(547)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserTABLE || _la == SyslParserTYPE) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(548)
		p.Name_str()
	}
	p.SetState(550)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(549)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(552)
		p.Match(SyslParserCOLON)
	}
	p.SetState(565)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(553)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(554)
			p.Match(SyslParserINDENT)
		}
		p.SetState(560)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserTABLE)|(1<<SyslParserTYPE)|(1<<SyslParserWHATEVER))) != 0) || (((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(SyslParserAT-41))|(1<<(SyslParserSYSL_COMMENT-41))|(1<<(SyslParserTEXT_LINE-41))|(1<<(SyslParserName-41)))) != 0) || _la == SyslParserE_Name {
			p.SetState(560)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(555)
					p.Match(SyslParserSYSL_COMMENT)
				}

			case 2:
				{
					p.SetState(556)
					p.Field()
				}

			case 3:
				{
					p.SetState(557)
					p.Annotation()
				}

			case 4:
				{
					p.SetState(558)
					p.Inplace_table()
				}

			case 5:
				{
					p.SetState(559)
					p.Match(SyslParserWHATEVER)
				}

			}

			p.SetState(562)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(564)
			p.Match(SyslParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnionContext is an interface to support dynamic dispatch.
type IUnionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnionContext differentiates from other interfaces.
	IsUnionContext()
}

type UnionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionContext() *UnionContext {
	var p = new(UnionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_union
	return p
}

func (*UnionContext) IsUnionContext() {}

func NewUnionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionContext {
	var p = new(UnionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_union

	return p
}

func (s *UnionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionContext) UNION() antlr.TerminalNode {
	return s.GetToken(SyslParserUNION, 0)
}

func (s *UnionContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *UnionContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *UnionContext) AllWHATEVER() []antlr.TerminalNode {
	return s.GetTokens(SyslParserWHATEVER)
}

func (s *UnionContext) WHATEVER(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, i)
}

func (s *UnionContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *UnionContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *UnionContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *UnionContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *UnionContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *UnionContext) AllUser_defined_type() []IUser_defined_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUser_defined_typeContext)(nil)).Elem())
	var tst = make([]IUser_defined_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUser_defined_typeContext)
		}
	}

	return tst
}

func (s *UnionContext) User_defined_type(i int) IUser_defined_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUser_defined_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUser_defined_typeContext)
}

func (s *UnionContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *UnionContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *UnionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterUnion(s)
	}
}

func (s *UnionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitUnion(s)
	}
}

func (p *SyslParser) Union() (localctx IUnionContext) {
	localctx = NewUnionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SyslParserRULE_union)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(570)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserSYSL_COMMENT {
		{
			p.SetState(567)
			p.Match(SyslParserSYSL_COMMENT)
		}

		p.SetState(572)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(573)
		p.Match(SyslParserUNION)
	}
	{
		p.SetState(574)
		p.Name_str()
	}
	p.SetState(576)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(575)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(578)
		p.Match(SyslParserCOLON)
	}
	p.SetState(590)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(579)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(580)
			p.Match(SyslParserINDENT)
		}
		p.SetState(585)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SyslParserWHATEVER || (((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(SyslParserAT-41))|(1<<(SyslParserSYSL_COMMENT-41))|(1<<(SyslParserTEXT_LINE-41))|(1<<(SyslParserName-41)))) != 0) || _la == SyslParserE_Name {
			p.SetState(585)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case SyslParserSYSL_COMMENT:
				{
					p.SetState(581)
					p.Match(SyslParserSYSL_COMMENT)
				}

			case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
				{
					p.SetState(582)
					p.User_defined_type()
				}

			case SyslParserAT:
				{
					p.SetState(583)
					p.Annotation()
				}

			case SyslParserWHATEVER:
				{
					p.SetState(584)
					p.Match(SyslParserWHATEVER)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(587)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(589)
			p.Match(SyslParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPackage_nameContext is an interface to support dynamic dispatch.
type IPackage_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_nameContext differentiates from other interfaces.
	IsPackage_nameContext()
}

type Package_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_nameContext() *Package_nameContext {
	var p = new(Package_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_package_name
	return p
}

func (*Package_nameContext) IsPackage_nameContext() {}

func NewPackage_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_nameContext {
	var p = new(Package_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_package_name

	return p
}

func (s *Package_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_nameContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Package_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterPackage_name(s)
	}
}

func (s *Package_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitPackage_name(s)
	}
}

func (p *SyslParser) Package_name() (localctx IPackage_nameContext) {
	localctx = NewPackage_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SyslParserRULE_package_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(592)
		p.Name_str()
	}

	return localctx
}

// ISub_packageContext is an interface to support dynamic dispatch.
type ISub_packageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSub_packageContext differentiates from other interfaces.
	IsSub_packageContext()
}

type Sub_packageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySub_packageContext() *Sub_packageContext {
	var p = new(Sub_packageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_sub_package
	return p
}

func (*Sub_packageContext) IsSub_packageContext() {}

func NewSub_packageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sub_packageContext {
	var p = new(Sub_packageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_sub_package

	return p
}

func (s *Sub_packageContext) GetParser() antlr.Parser { return s.parser }

func (s *Sub_packageContext) NAME_SEP() antlr.TerminalNode {
	return s.GetToken(SyslParserNAME_SEP, 0)
}

func (s *Sub_packageContext) Package_name() IPackage_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_nameContext)
}

func (s *Sub_packageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sub_packageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sub_packageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSub_package(s)
	}
}

func (s *Sub_packageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSub_package(s)
	}
}

func (p *SyslParser) Sub_package() (localctx ISub_packageContext) {
	localctx = NewSub_packageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SyslParserRULE_sub_package)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(594)
		p.Match(SyslParserNAME_SEP)
	}
	{
		p.SetState(595)
		p.Package_name()
	}

	return localctx
}

// IApp_nameContext is an interface to support dynamic dispatch.
type IApp_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsApp_nameContext differentiates from other interfaces.
	IsApp_nameContext()
}

type App_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyApp_nameContext() *App_nameContext {
	var p = new(App_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_app_name
	return p
}

func (*App_nameContext) IsApp_nameContext() {}

func NewApp_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *App_nameContext {
	var p = new(App_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_app_name

	return p
}

func (s *App_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *App_nameContext) Package_name() IPackage_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_nameContext)
}

func (s *App_nameContext) AllSub_package() []ISub_packageContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISub_packageContext)(nil)).Elem())
	var tst = make([]ISub_packageContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISub_packageContext)
		}
	}

	return tst
}

func (s *App_nameContext) Sub_package(i int) ISub_packageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISub_packageContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISub_packageContext)
}

func (s *App_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *App_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *App_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterApp_name(s)
	}
}

func (s *App_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitApp_name(s)
	}
}

func (p *SyslParser) App_name() (localctx IApp_nameContext) {
	localctx = NewApp_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SyslParserRULE_app_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(597)
		p.Package_name()
	}
	p.SetState(601)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(598)
				p.Sub_package()
			}

		}
		p.SetState(603)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext())
	}

	return localctx
}

// IName_with_attribsContext is an interface to support dynamic dispatch.
type IName_with_attribsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_with_attribsContext differentiates from other interfaces.
	IsName_with_attribsContext()
}

type Name_with_attribsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_with_attribsContext() *Name_with_attribsContext {
	var p = new(Name_with_attribsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_name_with_attribs
	return p
}

func (*Name_with_attribsContext) IsName_with_attribsContext() {}

func NewName_with_attribsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_with_attribsContext {
	var p = new(Name_with_attribsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_name_with_attribs

	return p
}

func (s *Name_with_attribsContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_with_attribsContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *Name_with_attribsContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Name_with_attribsContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Name_with_attribsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_with_attribsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_with_attribsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterName_with_attribs(s)
	}
}

func (s *Name_with_attribsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitName_with_attribs(s)
	}
}

func (p *SyslParser) Name_with_attribs() (localctx IName_with_attribsContext) {
	localctx = NewName_with_attribsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SyslParserRULE_name_with_attribs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(604)
		p.App_name()
	}
	p.SetState(606)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQSTRING {
		{
			p.SetState(605)
			p.Match(SyslParserQSTRING)
		}

	}
	p.SetState(609)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(608)
			p.Attribs_or_modifiers()
		}

	}

	return localctx
}

// IModel_nameContext is an interface to support dynamic dispatch.
type IModel_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModel_nameContext differentiates from other interfaces.
	IsModel_nameContext()
}

type Model_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModel_nameContext() *Model_nameContext {
	var p = new(Model_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_model_name
	return p
}

func (*Model_nameContext) IsModel_nameContext() {}

func NewModel_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Model_nameContext {
	var p = new(Model_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_model_name

	return p
}

func (s *Model_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Model_nameContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Model_nameContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Model_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Model_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Model_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterModel_name(s)
	}
}

func (s *Model_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitModel_name(s)
	}
}

func (p *SyslParser) Model_name() (localctx IModel_nameContext) {
	localctx = NewModel_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SyslParserRULE_model_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(611)
		p.Match(SyslParserName)
	}
	{
		p.SetState(612)
		p.Match(SyslParserCOLON)
	}

	return localctx
}

// IInplace_table_defContext is an interface to support dynamic dispatch.
type IInplace_table_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInplace_table_defContext differentiates from other interfaces.
	IsInplace_table_defContext()
}

type Inplace_table_defContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInplace_table_defContext() *Inplace_table_defContext {
	var p = new(Inplace_table_defContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_inplace_table_def
	return p
}

func (*Inplace_table_defContext) IsInplace_table_defContext() {}

func NewInplace_table_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inplace_table_defContext {
	var p = new(Inplace_table_defContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_inplace_table_def

	return p
}

func (s *Inplace_table_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Inplace_table_defContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Inplace_table_defContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Inplace_table_defContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Inplace_table_defContext) AllName() []antlr.TerminalNode {
	return s.GetTokens(SyslParserName)
}

func (s *Inplace_table_defContext) Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserName, i)
}

func (s *Inplace_table_defContext) AllAttribs_or_modifiers() []IAttribs_or_modifiersContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem())
	var tst = make([]IAttribs_or_modifiersContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribs_or_modifiersContext)
		}
	}

	return tst
}

func (s *Inplace_table_defContext) Attribs_or_modifiers(i int) IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Inplace_table_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inplace_table_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inplace_table_defContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterInplace_table_def(s)
	}
}

func (s *Inplace_table_defContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitInplace_table_def(s)
	}
}

func (p *SyslParser) Inplace_table_def() (localctx IInplace_table_defContext) {
	localctx = NewInplace_table_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SyslParserRULE_inplace_table_def)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(614)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(615)
		p.Match(SyslParserINDENT)
	}
	p.SetState(620)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserName {
		{
			p.SetState(616)
			p.Match(SyslParserName)
		}
		p.SetState(618)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserSQ_OPEN {
			{
				p.SetState(617)
				p.Attribs_or_modifiers()
			}

		}

		p.SetState(622)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(624)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// ITable_refsContext is an interface to support dynamic dispatch.
type ITable_refsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_refsContext differentiates from other interfaces.
	IsTable_refsContext()
}

type Table_refsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_refsContext() *Table_refsContext {
	var p = new(Table_refsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_table_refs
	return p
}

func (*Table_refsContext) IsTable_refsContext() {}

func NewTable_refsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_refsContext {
	var p = new(Table_refsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_table_refs

	return p
}

func (s *Table_refsContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_refsContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Table_refsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SyslParserTABLE, 0)
}

func (s *Table_refsContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SyslParserTYPE, 0)
}

func (s *Table_refsContext) UNION() antlr.TerminalNode {
	return s.GetToken(SyslParserUNION, 0)
}

func (s *Table_refsContext) Inplace_table_def() IInplace_table_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInplace_table_defContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInplace_table_defContext)
}

func (s *Table_refsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_refsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_refsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTable_refs(s)
	}
}

func (s *Table_refsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTable_refs(s)
	}
}

func (p *SyslParser) Table_refs() (localctx ITable_refsContext) {
	localctx = NewTable_refsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SyslParserRULE_table_refs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(626)
	_la = p.GetTokenStream().LA(1)

	if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserTABLE)|(1<<SyslParserTYPE)|(1<<SyslParserUNION))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(627)
		p.Match(SyslParserName)
	}
	p.SetState(629)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserCOLON {
		{
			p.SetState(628)
			p.Inplace_table_def()
		}

	}

	return localctx
}

// IFacadeContext is an interface to support dynamic dispatch.
type IFacadeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFacadeContext differentiates from other interfaces.
	IsFacadeContext()
}

type FacadeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFacadeContext() *FacadeContext {
	var p = new(FacadeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_facade
	return p
}

func (*FacadeContext) IsFacadeContext() {}

func NewFacadeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FacadeContext {
	var p = new(FacadeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_facade

	return p
}

func (s *FacadeContext) GetParser() antlr.Parser { return s.parser }

func (s *FacadeContext) WRAP() antlr.TerminalNode {
	return s.GetToken(SyslParserWRAP, 0)
}

func (s *FacadeContext) Model_name() IModel_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModel_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModel_nameContext)
}

func (s *FacadeContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *FacadeContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *FacadeContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *FacadeContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *FacadeContext) AllTable_refs() []ITable_refsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITable_refsContext)(nil)).Elem())
	var tst = make([]ITable_refsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITable_refsContext)
		}
	}

	return tst
}

func (s *FacadeContext) Table_refs(i int) ITable_refsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_refsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITable_refsContext)
}

func (s *FacadeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FacadeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FacadeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFacade(s)
	}
}

func (s *FacadeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFacade(s)
	}
}

func (p *SyslParser) Facade() (localctx IFacadeContext) {
	localctx = NewFacadeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SyslParserRULE_facade)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(634)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserSYSL_COMMENT {
		{
			p.SetState(631)
			p.Match(SyslParserSYSL_COMMENT)
		}

		p.SetState(636)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(637)
		p.Match(SyslParserWRAP)
	}
	{
		p.SetState(638)
		p.Model_name()
	}
	{
		p.SetState(639)
		p.Match(SyslParserINDENT)
	}
	p.SetState(641)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserTABLE)|(1<<SyslParserTYPE)|(1<<SyslParserUNION))) != 0) {
		{
			p.SetState(640)
			p.Table_refs()
		}

		p.SetState(643)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(645)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IDocumentation_stmtsContext is an interface to support dynamic dispatch.
type IDocumentation_stmtsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDocumentation_stmtsContext differentiates from other interfaces.
	IsDocumentation_stmtsContext()
}

type Documentation_stmtsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDocumentation_stmtsContext() *Documentation_stmtsContext {
	var p = new(Documentation_stmtsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_documentation_stmts
	return p
}

func (*Documentation_stmtsContext) IsDocumentation_stmtsContext() {}

func NewDocumentation_stmtsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Documentation_stmtsContext {
	var p = new(Documentation_stmtsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_documentation_stmts

	return p
}

func (s *Documentation_stmtsContext) GetParser() antlr.Parser { return s.parser }

func (s *Documentation_stmtsContext) AT() antlr.TerminalNode {
	return s.GetToken(SyslParserAT, 0)
}

func (s *Documentation_stmtsContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Documentation_stmtsContext) EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserEQ, 0)
}

func (s *Documentation_stmtsContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Documentation_stmtsContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(SyslParserNEWLINE, 0)
}

func (s *Documentation_stmtsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Documentation_stmtsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Documentation_stmtsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterDocumentation_stmts(s)
	}
}

func (s *Documentation_stmtsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitDocumentation_stmts(s)
	}
}

func (p *SyslParser) Documentation_stmts() (localctx IDocumentation_stmtsContext) {
	localctx = NewDocumentation_stmtsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SyslParserRULE_documentation_stmts)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(647)
		p.Match(SyslParserAT)
	}
	{
		p.SetState(648)
		p.Match(SyslParserName)
	}
	{
		p.SetState(649)
		p.Match(SyslParserEQ)
	}
	{
		p.SetState(650)
		p.Match(SyslParserQSTRING)
	}
	{
		p.SetState(651)
		p.Match(SyslParserNEWLINE)
	}

	return localctx
}

// IVar_in_curlyContext is an interface to support dynamic dispatch.
type IVar_in_curlyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVar_in_curlyContext differentiates from other interfaces.
	IsVar_in_curlyContext()
}

type Var_in_curlyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVar_in_curlyContext() *Var_in_curlyContext {
	var p = new(Var_in_curlyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_var_in_curly
	return p
}

func (*Var_in_curlyContext) IsVar_in_curlyContext() {}

func NewVar_in_curlyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Var_in_curlyContext {
	var p = new(Var_in_curlyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_var_in_curly

	return p
}

func (s *Var_in_curlyContext) GetParser() antlr.Parser { return s.parser }

func (s *Var_in_curlyContext) CURLY_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_OPEN, 0)
}

func (s *Var_in_curlyContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Var_in_curlyContext) CURLY_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_CLOSE, 0)
}

func (s *Var_in_curlyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Var_in_curlyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Var_in_curlyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterVar_in_curly(s)
	}
}

func (s *Var_in_curlyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitVar_in_curly(s)
	}
}

func (p *SyslParser) Var_in_curly() (localctx IVar_in_curlyContext) {
	localctx = NewVar_in_curlyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SyslParserRULE_var_in_curly)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(653)
		p.Match(SyslParserCURLY_OPEN)
	}
	{
		p.SetState(654)
		p.Match(SyslParserName)
	}
	{
		p.SetState(655)
		p.Match(SyslParserCURLY_CLOSE)
	}

	return localctx
}

// IQuery_varContext is an interface to support dynamic dispatch.
type IQuery_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuery_varContext differentiates from other interfaces.
	IsQuery_varContext()
}

type Query_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_varContext() *Query_varContext {
	var p = new(Query_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_query_var
	return p
}

func (*Query_varContext) IsQuery_varContext() {}

func NewQuery_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_varContext {
	var p = new(Query_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_query_var

	return p
}

func (s *Query_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_varContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Query_varContext) EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserEQ, 0)
}

func (s *Query_varContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Query_varContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Query_varContext) Var_in_curly() IVar_in_curlyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVar_in_curlyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVar_in_curlyContext)
}

func (s *Query_varContext) QN() antlr.TerminalNode {
	return s.GetToken(SyslParserQN, 0)
}

func (s *Query_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Query_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterQuery_var(s)
	}
}

func (s *Query_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitQuery_var(s)
	}
}

func (p *SyslParser) Query_var() (localctx IQuery_varContext) {
	localctx = NewQuery_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SyslParserRULE_query_var)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(657)
		p.Match(SyslParserName)
	}
	{
		p.SetState(658)
		p.Match(SyslParserEQ)
	}
	p.SetState(662)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserNativeDataTypes:
		{
			p.SetState(659)
			p.Match(SyslParserNativeDataTypes)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(660)
			p.Name_str()
		}

	case SyslParserCURLY_OPEN:
		{
			p.SetState(661)
			p.Var_in_curly()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(665)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQN {
		{
			p.SetState(664)
			p.Match(SyslParserQN)
		}

	}

	return localctx
}

// IQuery_paramContext is an interface to support dynamic dispatch.
type IQuery_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuery_paramContext differentiates from other interfaces.
	IsQuery_paramContext()
}

type Query_paramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_paramContext() *Query_paramContext {
	var p = new(Query_paramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_query_param
	return p
}

func (*Query_paramContext) IsQuery_paramContext() {}

func NewQuery_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_paramContext {
	var p = new(Query_paramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_query_param

	return p
}

func (s *Query_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_paramContext) QN() antlr.TerminalNode {
	return s.GetToken(SyslParserQN, 0)
}

func (s *Query_paramContext) AllQuery_var() []IQuery_varContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQuery_varContext)(nil)).Elem())
	var tst = make([]IQuery_varContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQuery_varContext)
		}
	}

	return tst
}

func (s *Query_paramContext) Query_var(i int) IQuery_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuery_varContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQuery_varContext)
}

func (s *Query_paramContext) AllAMP() []antlr.TerminalNode {
	return s.GetTokens(SyslParserAMP)
}

func (s *Query_paramContext) AMP(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserAMP, i)
}

func (s *Query_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Query_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterQuery_param(s)
	}
}

func (s *Query_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitQuery_param(s)
	}
}

func (p *SyslParser) Query_param() (localctx IQuery_paramContext) {
	localctx = NewQuery_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SyslParserRULE_query_param)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(667)
		p.Match(SyslParserQN)
	}
	{
		p.SetState(668)
		p.Query_var()
	}
	p.SetState(673)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserAMP {
		{
			p.SetState(669)
			p.Match(SyslParserAMP)
		}
		{
			p.SetState(670)
			p.Query_var()
		}

		p.SetState(675)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IHttp_path_partContext is an interface to support dynamic dispatch.
type IHttp_path_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_path_partContext differentiates from other interfaces.
	IsHttp_path_partContext()
}

type Http_path_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_path_partContext() *Http_path_partContext {
	var p = new(Http_path_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path_part
	return p
}

func (*Http_path_partContext) IsHttp_path_partContext() {}

func NewHttp_path_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_path_partContext {
	var p = new(Http_path_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path_part

	return p
}

func (s *Http_path_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_path_partContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Http_path_partContext) DIGITS() antlr.TerminalNode {
	return s.GetToken(SyslParserDIGITS, 0)
}

func (s *Http_path_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_path_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_path_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path_part(s)
	}
}

func (s *Http_path_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path_part(s)
	}
}

func (p *SyslParser) Http_path_part() (localctx IHttp_path_partContext) {
	localctx = NewHttp_path_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SyslParserRULE_http_path_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(678)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(676)
			p.Name_str()
		}

	case SyslParserDIGITS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(677)
			p.Match(SyslParserDIGITS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IHttp_path_var_with_typeContext is an interface to support dynamic dispatch.
type IHttp_path_var_with_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_path_var_with_typeContext differentiates from other interfaces.
	IsHttp_path_var_with_typeContext()
}

type Http_path_var_with_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_path_var_with_typeContext() *Http_path_var_with_typeContext {
	var p = new(Http_path_var_with_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path_var_with_type
	return p
}

func (*Http_path_var_with_typeContext) IsHttp_path_var_with_typeContext() {}

func NewHttp_path_var_with_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_path_var_with_typeContext {
	var p = new(Http_path_var_with_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path_var_with_type

	return p
}

func (s *Http_path_var_with_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_path_var_with_typeContext) CURLY_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_OPEN, 0)
}

func (s *Http_path_var_with_typeContext) Http_path_part() IHttp_path_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_partContext)
}

func (s *Http_path_var_with_typeContext) LESS_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserLESS_COLON, 0)
}

func (s *Http_path_var_with_typeContext) CURLY_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_CLOSE, 0)
}

func (s *Http_path_var_with_typeContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Http_path_var_with_typeContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Http_path_var_with_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_path_var_with_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_path_var_with_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path_var_with_type(s)
	}
}

func (s *Http_path_var_with_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path_var_with_type(s)
	}
}

func (p *SyslParser) Http_path_var_with_type() (localctx IHttp_path_var_with_typeContext) {
	localctx = NewHttp_path_var_with_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SyslParserRULE_http_path_var_with_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(680)
		p.Match(SyslParserCURLY_OPEN)
	}
	{
		p.SetState(681)
		p.Http_path_part()
	}
	{
		p.SetState(682)
		p.Match(SyslParserLESS_COLON)
	}
	p.SetState(685)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserNativeDataTypes:
		{
			p.SetState(683)
			p.Match(SyslParserNativeDataTypes)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(684)
			p.Name_str()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(687)
		p.Match(SyslParserCURLY_CLOSE)
	}

	return localctx
}

// IHttp_path_staticContext is an interface to support dynamic dispatch.
type IHttp_path_staticContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_path_staticContext differentiates from other interfaces.
	IsHttp_path_staticContext()
}

type Http_path_staticContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_path_staticContext() *Http_path_staticContext {
	var p = new(Http_path_staticContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path_static
	return p
}

func (*Http_path_staticContext) IsHttp_path_staticContext() {}

func NewHttp_path_staticContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_path_staticContext {
	var p = new(Http_path_staticContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path_static

	return p
}

func (s *Http_path_staticContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_path_staticContext) Http_path_part() IHttp_path_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_partContext)
}

func (s *Http_path_staticContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_path_staticContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_path_staticContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path_static(s)
	}
}

func (s *Http_path_staticContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path_static(s)
	}
}

func (p *SyslParser) Http_path_static() (localctx IHttp_path_staticContext) {
	localctx = NewHttp_path_staticContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SyslParserRULE_http_path_static)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(689)
		p.Http_path_part()
	}

	return localctx
}

// IHttp_path_suffixContext is an interface to support dynamic dispatch.
type IHttp_path_suffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_path_suffixContext differentiates from other interfaces.
	IsHttp_path_suffixContext()
}

type Http_path_suffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_path_suffixContext() *Http_path_suffixContext {
	var p = new(Http_path_suffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path_suffix
	return p
}

func (*Http_path_suffixContext) IsHttp_path_suffixContext() {}

func NewHttp_path_suffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_path_suffixContext {
	var p = new(Http_path_suffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path_suffix

	return p
}

func (s *Http_path_suffixContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_path_suffixContext) FORWARD_SLASH() antlr.TerminalNode {
	return s.GetToken(SyslParserFORWARD_SLASH, 0)
}

func (s *Http_path_suffixContext) Http_path_static() IHttp_path_staticContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_staticContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_staticContext)
}

func (s *Http_path_suffixContext) Http_path_var_with_type() IHttp_path_var_with_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_var_with_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_var_with_typeContext)
}

func (s *Http_path_suffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_path_suffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_path_suffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path_suffix(s)
	}
}

func (s *Http_path_suffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path_suffix(s)
	}
}

func (p *SyslParser) Http_path_suffix() (localctx IHttp_path_suffixContext) {
	localctx = NewHttp_path_suffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SyslParserRULE_http_path_suffix)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(691)
		p.Match(SyslParserFORWARD_SLASH)
	}
	p.SetState(694)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserDIGITS, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(692)
			p.Http_path_static()
		}

	case SyslParserCURLY_OPEN:
		{
			p.SetState(693)
			p.Http_path_var_with_type()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IHttp_pathContext is an interface to support dynamic dispatch.
type IHttp_pathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_pathContext differentiates from other interfaces.
	IsHttp_pathContext()
}

type Http_pathContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_pathContext() *Http_pathContext {
	var p = new(Http_pathContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path
	return p
}

func (*Http_pathContext) IsHttp_pathContext() {}

func NewHttp_pathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_pathContext {
	var p = new(Http_pathContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path

	return p
}

func (s *Http_pathContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_pathContext) FORWARD_SLASH() antlr.TerminalNode {
	return s.GetToken(SyslParserFORWARD_SLASH, 0)
}

func (s *Http_pathContext) Query_param() IQuery_paramContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuery_paramContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuery_paramContext)
}

func (s *Http_pathContext) AllHttp_path_suffix() []IHttp_path_suffixContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHttp_path_suffixContext)(nil)).Elem())
	var tst = make([]IHttp_path_suffixContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHttp_path_suffixContext)
		}
	}

	return tst
}

func (s *Http_pathContext) Http_path_suffix(i int) IHttp_path_suffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_suffixContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_suffixContext)
}

func (s *Http_pathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_pathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_pathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path(s)
	}
}

func (s *Http_pathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path(s)
	}
}

func (p *SyslParser) Http_path() (localctx IHttp_pathContext) {
	localctx = NewHttp_pathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SyslParserRULE_http_path)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(702)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(696)
			p.Match(SyslParserFORWARD_SLASH)
		}

	case 2:
		p.SetState(698)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SyslParserFORWARD_SLASH {
			{
				p.SetState(697)
				p.Http_path_suffix()
			}

			p.SetState(700)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(705)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQN {
		{
			p.SetState(704)
			p.Query_param()
		}

	}

	return localctx
}

// IEndpoint_nameContext is an interface to support dynamic dispatch.
type IEndpoint_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEndpoint_nameContext differentiates from other interfaces.
	IsEndpoint_nameContext()
}

type Endpoint_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndpoint_nameContext() *Endpoint_nameContext {
	var p = new(Endpoint_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_endpoint_name
	return p
}

func (*Endpoint_nameContext) IsEndpoint_nameContext() {}

func NewEndpoint_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Endpoint_nameContext {
	var p = new(Endpoint_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_endpoint_name

	return p
}

func (s *Endpoint_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Endpoint_nameContext) AllName_str() []IName_strContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IName_strContext)(nil)).Elem())
	var tst = make([]IName_strContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IName_strContext)
		}
	}

	return tst
}

func (s *Endpoint_nameContext) Name_str(i int) IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Endpoint_nameContext) AllFORWARD_SLASH() []antlr.TerminalNode {
	return s.GetTokens(SyslParserFORWARD_SLASH)
}

func (s *Endpoint_nameContext) FORWARD_SLASH(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserFORWARD_SLASH, i)
}

func (s *Endpoint_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Endpoint_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Endpoint_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterEndpoint_name(s)
	}
}

func (s *Endpoint_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitEndpoint_name(s)
	}
}

func (p *SyslParser) Endpoint_name() (localctx IEndpoint_nameContext) {
	localctx = NewEndpoint_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SyslParserRULE_endpoint_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(707)
		p.Name_str()
	}
	p.SetState(712)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserFORWARD_SLASH {
		{
			p.SetState(708)
			p.Match(SyslParserFORWARD_SLASH)
		}
		{
			p.SetState(709)
			p.Name_str()
		}

		p.SetState(714)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IRet_stmtContext is an interface to support dynamic dispatch.
type IRet_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRet_stmtContext differentiates from other interfaces.
	IsRet_stmtContext()
}

type Ret_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRet_stmtContext() *Ret_stmtContext {
	var p = new(Ret_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_ret_stmt
	return p
}

func (*Ret_stmtContext) IsRet_stmtContext() {}

func NewRet_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ret_stmtContext {
	var p = new(Ret_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_ret_stmt

	return p
}

func (s *Ret_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Ret_stmtContext) RETURN() antlr.TerminalNode {
	return s.GetToken(SyslParserRETURN, 0)
}

func (s *Ret_stmtContext) TEXT() antlr.TerminalNode {
	return s.GetToken(SyslParserTEXT, 0)
}

func (s *Ret_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ret_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ret_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRet_stmt(s)
	}
}

func (s *Ret_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRet_stmt(s)
	}
}

func (p *SyslParser) Ret_stmt() (localctx IRet_stmtContext) {
	localctx = NewRet_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SyslParserRULE_ret_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(715)
		p.Match(SyslParserRETURN)
	}
	{
		p.SetState(716)
		p.Match(SyslParserTEXT)
	}

	return localctx
}

// ITargetContext is an interface to support dynamic dispatch.
type ITargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTargetContext differentiates from other interfaces.
	IsTargetContext()
}

type TargetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetContext() *TargetContext {
	var p = new(TargetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_target
	return p
}

func (*TargetContext) IsTargetContext() {}

func NewTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetContext {
	var p = new(TargetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_target

	return p
}

func (s *TargetContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *TargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTarget(s)
	}
}

func (s *TargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTarget(s)
	}
}

func (p *SyslParser) Target() (localctx ITargetContext) {
	localctx = NewTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SyslParserRULE_target)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(718)
		p.App_name()
	}

	return localctx
}

// ITarget_endpointContext is an interface to support dynamic dispatch.
type ITarget_endpointContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTarget_endpointContext differentiates from other interfaces.
	IsTarget_endpointContext()
}

type Target_endpointContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTarget_endpointContext() *Target_endpointContext {
	var p = new(Target_endpointContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_target_endpoint
	return p
}

func (*Target_endpointContext) IsTarget_endpointContext() {}

func NewTarget_endpointContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Target_endpointContext {
	var p = new(Target_endpointContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_target_endpoint

	return p
}

func (s *Target_endpointContext) GetParser() antlr.Parser { return s.parser }

func (s *Target_endpointContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Target_endpointContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Target_endpointContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Target_endpointContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTarget_endpoint(s)
	}
}

func (s *Target_endpointContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTarget_endpoint(s)
	}
}

func (p *SyslParser) Target_endpoint() (localctx ITarget_endpointContext) {
	localctx = NewTarget_endpointContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SyslParserRULE_target_endpoint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(720)
		p.Name_str()
	}

	return localctx
}

// ICall_argContext is an interface to support dynamic dispatch.
type ICall_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCall_argContext differentiates from other interfaces.
	IsCall_argContext()
}

type Call_argContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCall_argContext() *Call_argContext {
	var p = new(Call_argContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_call_arg
	return p
}

func (*Call_argContext) IsCall_argContext() {}

func NewCall_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Call_argContext {
	var p = new(Call_argContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_call_arg

	return p
}

func (s *Call_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Call_argContext) AllQSTRING() []antlr.TerminalNode {
	return s.GetTokens(SyslParserQSTRING)
}

func (s *Call_argContext) QSTRING(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, i)
}

func (s *Call_argContext) AllName_str() []IName_strContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IName_strContext)(nil)).Elem())
	var tst = make([]IName_strContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IName_strContext)
		}
	}

	return tst
}

func (s *Call_argContext) Name_str(i int) IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Call_argContext) LESS_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserLESS_COLON, 0)
}

func (s *Call_argContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Call_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Call_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Call_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCall_arg(s)
	}
}

func (s *Call_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCall_arg(s)
	}
}

func (p *SyslParser) Call_arg() (localctx ICall_argContext) {
	localctx = NewCall_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SyslParserRULE_call_arg)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(734)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(724)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la-55)&-(0x1f+1)) == 0 && ((1<<uint((_la-55)))&((1<<(SyslParserQSTRING-55))|(1<<(SyslParserTEXT_LINE-55))|(1<<(SyslParserName-55)))) != 0) || _la == SyslParserE_Name {
			p.SetState(724)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case SyslParserQSTRING:
				{
					p.SetState(722)
					p.Match(SyslParserQSTRING)
				}

			case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
				{
					p.SetState(723)
					p.Name_str()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(726)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(728)
			p.Name_str()
		}
		{
			p.SetState(729)
			p.Match(SyslParserLESS_COLON)
		}
		p.SetState(732)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
			{
				p.SetState(730)
				p.Name_str()
			}

		case SyslParserNativeDataTypes:
			{
				p.SetState(731)
				p.Match(SyslParserNativeDataTypes)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// ICall_argsContext is an interface to support dynamic dispatch.
type ICall_argsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCall_argsContext differentiates from other interfaces.
	IsCall_argsContext()
}

type Call_argsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCall_argsContext() *Call_argsContext {
	var p = new(Call_argsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_call_args
	return p
}

func (*Call_argsContext) IsCall_argsContext() {}

func NewCall_argsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Call_argsContext {
	var p = new(Call_argsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_call_args

	return p
}

func (s *Call_argsContext) GetParser() antlr.Parser { return s.parser }

func (s *Call_argsContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *Call_argsContext) AllCall_arg() []ICall_argContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICall_argContext)(nil)).Elem())
	var tst = make([]ICall_argContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICall_argContext)
		}
	}

	return tst
}

func (s *Call_argsContext) Call_arg(i int) ICall_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_argContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICall_argContext)
}

func (s *Call_argsContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *Call_argsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Call_argsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Call_argsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Call_argsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Call_argsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCall_args(s)
	}
}

func (s *Call_argsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCall_args(s)
	}
}

func (p *SyslParser) Call_args() (localctx ICall_argsContext) {
	localctx = NewCall_argsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SyslParserRULE_call_args)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(736)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(737)
		p.Call_arg()
	}
	p.SetState(742)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(738)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(739)
			p.Call_arg()
		}

		p.SetState(744)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(745)
		p.Match(SyslParserCLOSE_PAREN)
	}

	return localctx
}

// ICall_stmtContext is an interface to support dynamic dispatch.
type ICall_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCall_stmtContext differentiates from other interfaces.
	IsCall_stmtContext()
}

type Call_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCall_stmtContext() *Call_stmtContext {
	var p = new(Call_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_call_stmt
	return p
}

func (*Call_stmtContext) IsCall_stmtContext() {}

func NewCall_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Call_stmtContext {
	var p = new(Call_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_call_stmt

	return p
}

func (s *Call_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Call_stmtContext) Target_endpoint() ITarget_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITarget_endpointContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITarget_endpointContext)
}

func (s *Call_stmtContext) DOT_ARROW() antlr.TerminalNode {
	return s.GetToken(SyslParserDOT_ARROW, 0)
}

func (s *Call_stmtContext) Target() ITargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITargetContext)
}

func (s *Call_stmtContext) ARROW_LEFT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_LEFT, 0)
}

func (s *Call_stmtContext) Call_args() ICall_argsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_argsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICall_argsContext)
}

func (s *Call_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Call_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Call_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCall_stmt(s)
	}
}

func (s *Call_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCall_stmt(s)
	}
}

func (p *SyslParser) Call_stmt() (localctx ICall_stmtContext) {
	localctx = NewCall_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SyslParserRULE_call_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(751)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserDOT_ARROW:
		{
			p.SetState(747)
			p.Match(SyslParserDOT_ARROW)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(748)
			p.Target()
		}
		{
			p.SetState(749)
			p.Match(SyslParserARROW_LEFT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(753)
		p.Target_endpoint()
	}
	p.SetState(755)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserOPEN_PAREN {
		{
			p.SetState(754)
			p.Call_args()
		}

	}

	return localctx
}

// IIf_stmtContext is an interface to support dynamic dispatch.
type IIf_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_stmtContext differentiates from other interfaces.
	IsIf_stmtContext()
}

type If_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_stmtContext() *If_stmtContext {
	var p = new(If_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_stmt
	return p
}

func (*If_stmtContext) IsIf_stmtContext() {}

func NewIf_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_stmtContext {
	var p = new(If_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_stmt

	return p
}

func (s *If_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(SyslParserIF, 0)
}

func (s *If_stmtContext) PREDICATE_VALUE() antlr.TerminalNode {
	return s.GetToken(SyslParserPREDICATE_VALUE, 0)
}

func (s *If_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *If_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *If_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *If_stmtContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *If_stmtContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *If_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_stmt(s)
	}
}

func (s *If_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_stmt(s)
	}
}

func (p *SyslParser) If_stmt() (localctx IIf_stmtContext) {
	localctx = NewIf_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, SyslParserRULE_if_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(757)
		p.Match(SyslParserIF)
	}
	{
		p.SetState(758)
		p.Match(SyslParserPREDICATE_VALUE)
	}
	{
		p.SetState(759)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(760)
		p.Match(SyslParserINDENT)
	}
	p.SetState(764)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(SyslParserAT-41))|(1<<(SyslParserPIPE-41))|(1<<(SyslParserQSTRING-41))|(1<<(SyslParserSYSL_COMMENT-41))|(1<<(SyslParserTEXT_LINE-41))|(1<<(SyslParserName-41)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(761)
			p.Statements()
		}

		p.SetState(766)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(767)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IElse_stmtContext is an interface to support dynamic dispatch.
type IElse_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElse_stmtContext differentiates from other interfaces.
	IsElse_stmtContext()
}

type Else_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElse_stmtContext() *Else_stmtContext {
	var p = new(Else_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_else_stmt
	return p
}

func (*Else_stmtContext) IsElse_stmtContext() {}

func NewElse_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Else_stmtContext {
	var p = new(Else_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_else_stmt

	return p
}

func (s *Else_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Else_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SyslParserELSE, 0)
}

func (s *Else_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Else_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Else_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Else_stmtContext) PREDICATE_VALUE() antlr.TerminalNode {
	return s.GetToken(SyslParserPREDICATE_VALUE, 0)
}

func (s *Else_stmtContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *Else_stmtContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *Else_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Else_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Else_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterElse_stmt(s)
	}
}

func (s *Else_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitElse_stmt(s)
	}
}

func (p *SyslParser) Else_stmt() (localctx IElse_stmtContext) {
	localctx = NewElse_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SyslParserRULE_else_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(769)
		p.Match(SyslParserELSE)
	}
	p.SetState(771)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserPREDICATE_VALUE {
		{
			p.SetState(770)
			p.Match(SyslParserPREDICATE_VALUE)
		}

	}
	{
		p.SetState(773)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(774)
		p.Match(SyslParserINDENT)
	}
	p.SetState(778)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(SyslParserAT-41))|(1<<(SyslParserPIPE-41))|(1<<(SyslParserQSTRING-41))|(1<<(SyslParserSYSL_COMMENT-41))|(1<<(SyslParserTEXT_LINE-41))|(1<<(SyslParserName-41)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(775)
			p.Statements()
		}

		p.SetState(780)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(781)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IIf_elseContext is an interface to support dynamic dispatch.
type IIf_elseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_elseContext differentiates from other interfaces.
	IsIf_elseContext()
}

type If_elseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_elseContext() *If_elseContext {
	var p = new(If_elseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_else
	return p
}

func (*If_elseContext) IsIf_elseContext() {}

func NewIf_elseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_elseContext {
	var p = new(If_elseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_else

	return p
}

func (s *If_elseContext) GetParser() antlr.Parser { return s.parser }

func (s *If_elseContext) If_stmt() IIf_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_stmtContext)
}

func (s *If_elseContext) AllElse_stmt() []IElse_stmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElse_stmtContext)(nil)).Elem())
	var tst = make([]IElse_stmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElse_stmtContext)
		}
	}

	return tst
}

func (s *If_elseContext) Else_stmt(i int) IElse_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElse_stmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElse_stmtContext)
}

func (s *If_elseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_elseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_elseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_else(s)
	}
}

func (s *If_elseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_else(s)
	}
}

func (p *SyslParser) If_else() (localctx IIf_elseContext) {
	localctx = NewIf_elseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, SyslParserRULE_if_else)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(783)
		p.If_stmt()
	}
	p.SetState(787)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserELSE {
		{
			p.SetState(784)
			p.Else_stmt()
		}

		p.SetState(789)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFor_stmtContext is an interface to support dynamic dispatch.
type IFor_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_stmtContext differentiates from other interfaces.
	IsFor_stmtContext()
}

type For_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_stmtContext() *For_stmtContext {
	var p = new(For_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_for_stmt
	return p
}

func (*For_stmtContext) IsFor_stmtContext() {}

func NewFor_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_stmtContext {
	var p = new(For_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_for_stmt

	return p
}

func (s *For_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *For_stmtContext) PREDICATE_VALUE() antlr.TerminalNode {
	return s.GetToken(SyslParserPREDICATE_VALUE, 0)
}

func (s *For_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *For_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *For_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *For_stmtContext) ALT() antlr.TerminalNode {
	return s.GetToken(SyslParserALT, 0)
}

func (s *For_stmtContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(SyslParserUNTIL, 0)
}

func (s *For_stmtContext) FOR_EACH() antlr.TerminalNode {
	return s.GetToken(SyslParserFOR_EACH, 0)
}

func (s *For_stmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(SyslParserFOR, 0)
}

func (s *For_stmtContext) LOOP() antlr.TerminalNode {
	return s.GetToken(SyslParserLOOP, 0)
}

func (s *For_stmtContext) WHILE() antlr.TerminalNode {
	return s.GetToken(SyslParserWHILE, 0)
}

func (s *For_stmtContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *For_stmtContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *For_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFor_stmt(s)
	}
}

func (s *For_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFor_stmt(s)
	}
}

func (p *SyslParser) For_stmt() (localctx IFor_stmtContext) {
	localctx = NewFor_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, SyslParserRULE_for_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(790)
	_la = p.GetTokenStream().LA(1)

	if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(791)
		p.Match(SyslParserPREDICATE_VALUE)
	}
	{
		p.SetState(792)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(793)
		p.Match(SyslParserINDENT)
	}
	p.SetState(797)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(SyslParserAT-41))|(1<<(SyslParserPIPE-41))|(1<<(SyslParserQSTRING-41))|(1<<(SyslParserSYSL_COMMENT-41))|(1<<(SyslParserTEXT_LINE-41))|(1<<(SyslParserName-41)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(794)
			p.Statements()
		}

		p.SetState(799)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(800)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IHttp_method_commentContext is an interface to support dynamic dispatch.
type IHttp_method_commentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_method_commentContext differentiates from other interfaces.
	IsHttp_method_commentContext()
}

type Http_method_commentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_method_commentContext() *Http_method_commentContext {
	var p = new(Http_method_commentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_method_comment
	return p
}

func (*Http_method_commentContext) IsHttp_method_commentContext() {}

func NewHttp_method_commentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_method_commentContext {
	var p = new(Http_method_commentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_method_comment

	return p
}

func (s *Http_method_commentContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_method_commentContext) SYSL_COMMENT() antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, 0)
}

func (s *Http_method_commentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_method_commentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_method_commentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_method_comment(s)
	}
}

func (s *Http_method_commentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_method_comment(s)
	}
}

func (p *SyslParser) Http_method_comment() (localctx IHttp_method_commentContext) {
	localctx = NewHttp_method_commentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, SyslParserRULE_http_method_comment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(802)
		p.Match(SyslParserSYSL_COMMENT)
	}

	return localctx
}

// IGroup_stmtContext is an interface to support dynamic dispatch.
type IGroup_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroup_stmtContext differentiates from other interfaces.
	IsGroup_stmtContext()
}

type Group_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_stmtContext() *Group_stmtContext {
	var p = new(Group_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_group_stmt
	return p
}

func (*Group_stmtContext) IsGroup_stmtContext() {}

func NewGroup_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_stmtContext {
	var p = new(Group_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_group_stmt

	return p
}

func (s *Group_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_stmtContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Group_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Group_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Group_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Group_stmtContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *Group_stmtContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *Group_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Group_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterGroup_stmt(s)
	}
}

func (s *Group_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitGroup_stmt(s)
	}
}

func (p *SyslParser) Group_stmt() (localctx IGroup_stmtContext) {
	localctx = NewGroup_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SyslParserRULE_group_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(804)
		p.Name_str()
	}
	{
		p.SetState(805)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(806)
		p.Match(SyslParserINDENT)
	}
	p.SetState(808)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(SyslParserAT-41))|(1<<(SyslParserPIPE-41))|(1<<(SyslParserQSTRING-41))|(1<<(SyslParserSYSL_COMMENT-41))|(1<<(SyslParserTEXT_LINE-41))|(1<<(SyslParserName-41)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(807)
			p.Statements()
		}

		p.SetState(810)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(812)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IOne_of_case_labelContext is an interface to support dynamic dispatch.
type IOne_of_case_labelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOne_of_case_labelContext differentiates from other interfaces.
	IsOne_of_case_labelContext()
}

type One_of_case_labelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOne_of_case_labelContext() *One_of_case_labelContext {
	var p = new(One_of_case_labelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_one_of_case_label
	return p
}

func (*One_of_case_labelContext) IsOne_of_case_labelContext() {}

func NewOne_of_case_labelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *One_of_case_labelContext {
	var p = new(One_of_case_labelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_one_of_case_label

	return p
}

func (s *One_of_case_labelContext) GetParser() antlr.Parser { return s.parser }

func (s *One_of_case_labelContext) AllName() []antlr.TerminalNode {
	return s.GetTokens(SyslParserName)
}

func (s *One_of_case_labelContext) Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserName, i)
}

func (s *One_of_case_labelContext) AllTEXT_LINE() []antlr.TerminalNode {
	return s.GetTokens(SyslParserTEXT_LINE)
}

func (s *One_of_case_labelContext) TEXT_LINE(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserTEXT_LINE, i)
}

func (s *One_of_case_labelContext) AllQSTRING() []antlr.TerminalNode {
	return s.GetTokens(SyslParserQSTRING)
}

func (s *One_of_case_labelContext) QSTRING(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, i)
}

func (s *One_of_case_labelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *One_of_case_labelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *One_of_case_labelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterOne_of_case_label(s)
	}
}

func (s *One_of_case_labelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitOne_of_case_label(s)
	}
}

func (p *SyslParser) One_of_case_label() (localctx IOne_of_case_labelContext) {
	localctx = NewOne_of_case_labelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SyslParserRULE_one_of_case_label)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(815)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-55)&-(0x1f+1)) == 0 && ((1<<uint((_la-55)))&((1<<(SyslParserQSTRING-55))|(1<<(SyslParserTEXT_LINE-55))|(1<<(SyslParserName-55)))) != 0) {
		p.SetState(814)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-55)&-(0x1f+1)) == 0 && ((1<<uint((_la-55)))&((1<<(SyslParserQSTRING-55))|(1<<(SyslParserTEXT_LINE-55))|(1<<(SyslParserName-55)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

		p.SetState(817)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOne_of_casesContext is an interface to support dynamic dispatch.
type IOne_of_casesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOne_of_casesContext differentiates from other interfaces.
	IsOne_of_casesContext()
}

type One_of_casesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOne_of_casesContext() *One_of_casesContext {
	var p = new(One_of_casesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_one_of_cases
	return p
}

func (*One_of_casesContext) IsOne_of_casesContext() {}

func NewOne_of_casesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *One_of_casesContext {
	var p = new(One_of_casesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_one_of_cases

	return p
}

func (s *One_of_casesContext) GetParser() antlr.Parser { return s.parser }

func (s *One_of_casesContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *One_of_casesContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *One_of_casesContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *One_of_casesContext) One_of_case_label() IOne_of_case_labelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOne_of_case_labelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOne_of_case_labelContext)
}

func (s *One_of_casesContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *One_of_casesContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *One_of_casesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *One_of_casesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *One_of_casesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterOne_of_cases(s)
	}
}

func (s *One_of_casesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitOne_of_cases(s)
	}
}

func (p *SyslParser) One_of_cases() (localctx IOne_of_casesContext) {
	localctx = NewOne_of_casesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SyslParserRULE_one_of_cases)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(820)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-55)&-(0x1f+1)) == 0 && ((1<<uint((_la-55)))&((1<<(SyslParserQSTRING-55))|(1<<(SyslParserTEXT_LINE-55))|(1<<(SyslParserName-55)))) != 0 {
		{
			p.SetState(819)
			p.One_of_case_label()
		}

	}
	{
		p.SetState(822)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(823)
		p.Match(SyslParserINDENT)
	}
	p.SetState(825)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(SyslParserAT-41))|(1<<(SyslParserPIPE-41))|(1<<(SyslParserQSTRING-41))|(1<<(SyslParserSYSL_COMMENT-41))|(1<<(SyslParserTEXT_LINE-41))|(1<<(SyslParserName-41)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(824)
			p.Statements()
		}

		p.SetState(827)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(829)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IOne_of_stmtContext is an interface to support dynamic dispatch.
type IOne_of_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOne_of_stmtContext differentiates from other interfaces.
	IsOne_of_stmtContext()
}

type One_of_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOne_of_stmtContext() *One_of_stmtContext {
	var p = new(One_of_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_one_of_stmt
	return p
}

func (*One_of_stmtContext) IsOne_of_stmtContext() {}

func NewOne_of_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *One_of_stmtContext {
	var p = new(One_of_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_one_of_stmt

	return p
}

func (s *One_of_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *One_of_stmtContext) ONE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserONE_OF, 0)
}

func (s *One_of_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *One_of_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *One_of_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *One_of_stmtContext) AllOne_of_cases() []IOne_of_casesContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOne_of_casesContext)(nil)).Elem())
	var tst = make([]IOne_of_casesContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOne_of_casesContext)
		}
	}

	return tst
}

func (s *One_of_stmtContext) One_of_cases(i int) IOne_of_casesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOne_of_casesContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOne_of_casesContext)
}

func (s *One_of_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *One_of_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *One_of_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterOne_of_stmt(s)
	}
}

func (s *One_of_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitOne_of_stmt(s)
	}
}

func (p *SyslParser) One_of_stmt() (localctx IOne_of_stmtContext) {
	localctx = NewOne_of_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, SyslParserRULE_one_of_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(831)
		p.Match(SyslParserONE_OF)
	}
	{
		p.SetState(832)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(833)
		p.Match(SyslParserINDENT)
	}
	p.SetState(835)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(SyslParserCOLON-38))|(1<<(SyslParserQSTRING-38))|(1<<(SyslParserTEXT_LINE-38))|(1<<(SyslParserName-38)))) != 0) {
		{
			p.SetState(834)
			p.One_of_cases()
		}

		p.SetState(837)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(839)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IText_stmtContext is an interface to support dynamic dispatch.
type IText_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_stmtContext differentiates from other interfaces.
	IsText_stmtContext()
}

type Text_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_stmtContext() *Text_stmtContext {
	var p = new(Text_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_text_stmt
	return p
}

func (*Text_stmtContext) IsText_stmtContext() {}

func NewText_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_stmtContext {
	var p = new(Text_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_text_stmt

	return p
}

func (s *Text_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_stmtContext) Doc_string() IDoc_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDoc_stringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDoc_stringContext)
}

func (s *Text_stmtContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Text_stmtContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *Text_stmtContext) ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_RIGHT, 0)
}

func (s *Text_stmtContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Text_stmtContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *Text_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterText_stmt(s)
	}
}

func (s *Text_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitText_stmt(s)
	}
}

func (p *SyslParser) Text_stmt() (localctx IText_stmtContext) {
	localctx = NewText_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, SyslParserRULE_text_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(849)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserPIPE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(841)
			p.Doc_string()
		}

	case SyslParserQSTRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(842)
			p.Match(SyslParserQSTRING)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(843)
			p.App_name()
		}
		p.SetState(846)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserARROW_RIGHT {
			{
				p.SetState(844)
				p.Match(SyslParserARROW_RIGHT)
			}
			{
				p.SetState(845)
				p.Name_str()
			}

		}

	case SyslParserWHATEVER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(848)
			p.Match(SyslParserWHATEVER)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMixinContext is an interface to support dynamic dispatch.
type IMixinContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMixinContext differentiates from other interfaces.
	IsMixinContext()
}

type MixinContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMixinContext() *MixinContext {
	var p = new(MixinContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_mixin
	return p
}

func (*MixinContext) IsMixinContext() {}

func NewMixinContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MixinContext {
	var p = new(MixinContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_mixin

	return p
}

func (s *MixinContext) GetParser() antlr.Parser { return s.parser }

func (s *MixinContext) MIXIN() antlr.TerminalNode {
	return s.GetToken(SyslParserMIXIN, 0)
}

func (s *MixinContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *MixinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MixinContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MixinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterMixin(s)
	}
}

func (s *MixinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitMixin(s)
	}
}

func (p *SyslParser) Mixin() (localctx IMixinContext) {
	localctx = NewMixinContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, SyslParserRULE_mixin)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(851)
		p.Match(SyslParserMIXIN)
	}
	{
		p.SetState(852)
		p.App_name()
	}

	return localctx
}

// IParamContext is an interface to support dynamic dispatch.
type IParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamContext differentiates from other interfaces.
	IsParamContext()
}

type ParamContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamContext() *ParamContext {
	var p = new(ParamContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_param
	return p
}

func (*ParamContext) IsParamContext() {}

func NewParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamContext {
	var p = new(ParamContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_param

	return p
}

func (s *ParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamContext) Reference() IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *ParamContext) Field() IFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldContext)
}

func (s *ParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterParam(s)
	}
}

func (s *ParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitParam(s)
	}
}

func (p *SyslParser) Param() (localctx IParamContext) {
	localctx = NewParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, SyslParserRULE_param)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(856)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(854)
			p.Reference()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(855)
			p.Field()
		}

	}

	return localctx
}

// IParam_listContext is an interface to support dynamic dispatch.
type IParam_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParam_listContext differentiates from other interfaces.
	IsParam_listContext()
}

type Param_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParam_listContext() *Param_listContext {
	var p = new(Param_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_param_list
	return p
}

func (*Param_listContext) IsParam_listContext() {}

func NewParam_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Param_listContext {
	var p = new(Param_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_param_list

	return p
}

func (s *Param_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Param_listContext) AllParam() []IParamContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParamContext)(nil)).Elem())
	var tst = make([]IParamContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParamContext)
		}
	}

	return tst
}

func (s *Param_listContext) Param(i int) IParamContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *Param_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Param_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Param_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Param_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Param_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterParam_list(s)
	}
}

func (s *Param_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitParam_list(s)
	}
}

func (p *SyslParser) Param_list() (localctx IParam_listContext) {
	localctx = NewParam_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, SyslParserRULE_param_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(858)
		p.Param()
	}
	p.SetState(863)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(859)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(860)
			p.Param()
		}

		p.SetState(865)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IParamsContext is an interface to support dynamic dispatch.
type IParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamsContext differentiates from other interfaces.
	IsParamsContext()
}

type ParamsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamsContext() *ParamsContext {
	var p = new(ParamsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_params
	return p
}

func (*ParamsContext) IsParamsContext() {}

func NewParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamsContext {
	var p = new(ParamsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_params

	return p
}

func (s *ParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamsContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *ParamsContext) Param_list() IParam_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParam_listContext)
}

func (s *ParamsContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *ParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterParams(s)
	}
}

func (s *ParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitParams(s)
	}
}

func (p *SyslParser) Params() (localctx IParamsContext) {
	localctx = NewParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, SyslParserRULE_params)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(866)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(867)
		p.Param_list()
	}
	{
		p.SetState(868)
		p.Match(SyslParserCLOSE_PAREN)
	}

	return localctx
}

// IStatementsContext is an interface to support dynamic dispatch.
type IStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementsContext differentiates from other interfaces.
	IsStatementsContext()
}

type StatementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsContext() *StatementsContext {
	var p = new(StatementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_statements
	return p
}

func (*StatementsContext) IsStatementsContext() {}

func NewStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsContext {
	var p = new(StatementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_statements

	return p
}

func (s *StatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsContext) If_else() IIf_elseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_elseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_elseContext)
}

func (s *StatementsContext) For_stmt() IFor_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_stmtContext)
}

func (s *StatementsContext) Ret_stmt() IRet_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRet_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRet_stmtContext)
}

func (s *StatementsContext) Call_stmt() ICall_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICall_stmtContext)
}

func (s *StatementsContext) One_of_stmt() IOne_of_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOne_of_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOne_of_stmtContext)
}

func (s *StatementsContext) Http_method_comment() IHttp_method_commentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_method_commentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_method_commentContext)
}

func (s *StatementsContext) Group_stmt() IGroup_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_stmtContext)
}

func (s *StatementsContext) Text_stmt() IText_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_stmtContext)
}

func (s *StatementsContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *StatementsContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *StatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterStatements(s)
	}
}

func (s *StatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitStatements(s)
	}
}

func (p *SyslParser) Statements() (localctx IStatementsContext) {
	localctx = NewStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, SyslParserRULE_statements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(879)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(870)
			p.If_else()
		}

	case 2:
		{
			p.SetState(871)
			p.For_stmt()
		}

	case 3:
		{
			p.SetState(872)
			p.Ret_stmt()
		}

	case 4:
		{
			p.SetState(873)
			p.Call_stmt()
		}

	case 5:
		{
			p.SetState(874)
			p.One_of_stmt()
		}

	case 6:
		{
			p.SetState(875)
			p.Http_method_comment()
		}

	case 7:
		{
			p.SetState(876)
			p.Group_stmt()
		}

	case 8:
		{
			p.SetState(877)
			p.Text_stmt()
		}

	case 9:
		{
			p.SetState(878)
			p.Annotation()
		}

	}
	p.SetState(882)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(881)
			p.Attribs_or_modifiers()
		}

	}

	return localctx
}

// IMethod_defContext is an interface to support dynamic dispatch.
type IMethod_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethod_defContext differentiates from other interfaces.
	IsMethod_defContext()
}

type Method_defContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethod_defContext() *Method_defContext {
	var p = new(Method_defContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_method_def
	return p
}

func (*Method_defContext) IsMethod_defContext() {}

func NewMethod_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Method_defContext {
	var p = new(Method_defContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_method_def

	return p
}

func (s *Method_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Method_defContext) HTTP_VERBS() antlr.TerminalNode {
	return s.GetToken(SyslParserHTTP_VERBS, 0)
}

func (s *Method_defContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Method_defContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Method_defContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Method_defContext) Query_param() IQuery_paramContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuery_paramContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuery_paramContext)
}

func (s *Method_defContext) Params() IParamsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamsContext)
}

func (s *Method_defContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Method_defContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *Method_defContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *Method_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Method_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Method_defContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterMethod_def(s)
	}
}

func (s *Method_defContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitMethod_def(s)
	}
}

func (p *SyslParser) Method_def() (localctx IMethod_defContext) {
	localctx = NewMethod_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, SyslParserRULE_method_def)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(884)
		p.Match(SyslParserHTTP_VERBS)
	}
	p.SetState(886)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQN {
		{
			p.SetState(885)
			p.Query_param()
		}

	}
	p.SetState(889)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserOPEN_PAREN {
		{
			p.SetState(888)
			p.Params()
		}

	}
	p.SetState(892)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(891)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(894)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(895)
		p.Match(SyslParserINDENT)
	}
	p.SetState(897)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(SyslParserAT-41))|(1<<(SyslParserPIPE-41))|(1<<(SyslParserQSTRING-41))|(1<<(SyslParserSYSL_COMMENT-41))|(1<<(SyslParserTEXT_LINE-41))|(1<<(SyslParserName-41)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(896)
			p.Statements()
		}

		p.SetState(899)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(901)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IShortcutContext is an interface to support dynamic dispatch.
type IShortcutContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShortcutContext differentiates from other interfaces.
	IsShortcutContext()
}

type ShortcutContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShortcutContext() *ShortcutContext {
	var p = new(ShortcutContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_shortcut
	return p
}

func (*ShortcutContext) IsShortcutContext() {}

func NewShortcutContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShortcutContext {
	var p = new(ShortcutContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_shortcut

	return p
}

func (s *ShortcutContext) GetParser() antlr.Parser { return s.parser }

func (s *ShortcutContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *ShortcutContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShortcutContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShortcutContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterShortcut(s)
	}
}

func (s *ShortcutContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitShortcut(s)
	}
}

func (p *SyslParser) Shortcut() (localctx IShortcutContext) {
	localctx = NewShortcutContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, SyslParserRULE_shortcut)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(903)
		p.Match(SyslParserWHATEVER)
	}

	return localctx
}

// ISimple_endpointContext is an interface to support dynamic dispatch.
type ISimple_endpointContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_endpointContext differentiates from other interfaces.
	IsSimple_endpointContext()
}

type Simple_endpointContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_endpointContext() *Simple_endpointContext {
	var p = new(Simple_endpointContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_simple_endpoint
	return p
}

func (*Simple_endpointContext) IsSimple_endpointContext() {}

func NewSimple_endpointContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_endpointContext {
	var p = new(Simple_endpointContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_simple_endpoint

	return p
}

func (s *Simple_endpointContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_endpointContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *Simple_endpointContext) Endpoint_name() IEndpoint_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndpoint_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndpoint_nameContext)
}

func (s *Simple_endpointContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Simple_endpointContext) Shortcut() IShortcutContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShortcutContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShortcutContext)
}

func (s *Simple_endpointContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Simple_endpointContext) Params() IParamsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamsContext)
}

func (s *Simple_endpointContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Simple_endpointContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Simple_endpointContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Simple_endpointContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *Simple_endpointContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *Simple_endpointContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_endpointContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_endpointContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSimple_endpoint(s)
	}
}

func (s *Simple_endpointContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSimple_endpoint(s)
	}
}

func (p *SyslParser) Simple_endpoint() (localctx ISimple_endpointContext) {
	localctx = NewSimple_endpointContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, SyslParserRULE_simple_endpoint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(928)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(905)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(906)
			p.Endpoint_name()
		}
		p.SetState(908)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserQSTRING {
			{
				p.SetState(907)
				p.Match(SyslParserQSTRING)
			}

		}
		p.SetState(911)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserOPEN_PAREN {
			{
				p.SetState(910)
				p.Params()
			}

		}
		p.SetState(914)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserSQ_OPEN {
			{
				p.SetState(913)
				p.Attribs_or_modifiers()
			}

		}
		{
			p.SetState(916)
			p.Match(SyslParserCOLON)
		}
		p.SetState(926)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserWHATEVER:
			{
				p.SetState(917)
				p.Shortcut()
			}

		case SyslParserINDENT:
			{
				p.SetState(918)
				p.Match(SyslParserINDENT)
			}
			p.SetState(920)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(SyslParserAT-41))|(1<<(SyslParserPIPE-41))|(1<<(SyslParserQSTRING-41))|(1<<(SyslParserSYSL_COMMENT-41))|(1<<(SyslParserTEXT_LINE-41))|(1<<(SyslParserName-41)))) != 0) || _la == SyslParserE_Name {
				{
					p.SetState(919)
					p.Statements()
				}

				p.SetState(922)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(924)
				p.Match(SyslParserDEDENT)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRest_endpointContext is an interface to support dynamic dispatch.
type IRest_endpointContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRest_endpointContext differentiates from other interfaces.
	IsRest_endpointContext()
}

type Rest_endpointContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRest_endpointContext() *Rest_endpointContext {
	var p = new(Rest_endpointContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_rest_endpoint
	return p
}

func (*Rest_endpointContext) IsRest_endpointContext() {}

func NewRest_endpointContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rest_endpointContext {
	var p = new(Rest_endpointContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_rest_endpoint

	return p
}

func (s *Rest_endpointContext) GetParser() antlr.Parser { return s.parser }

func (s *Rest_endpointContext) Http_path() IHttp_pathContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_pathContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_pathContext)
}

func (s *Rest_endpointContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Rest_endpointContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Rest_endpointContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Rest_endpointContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Rest_endpointContext) AllMethod_def() []IMethod_defContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMethod_defContext)(nil)).Elem())
	var tst = make([]IMethod_defContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMethod_defContext)
		}
	}

	return tst
}

func (s *Rest_endpointContext) Method_def(i int) IMethod_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_defContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMethod_defContext)
}

func (s *Rest_endpointContext) AllRest_endpoint() []IRest_endpointContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRest_endpointContext)(nil)).Elem())
	var tst = make([]IRest_endpointContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRest_endpointContext)
		}
	}

	return tst
}

func (s *Rest_endpointContext) Rest_endpoint(i int) IRest_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRest_endpointContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRest_endpointContext)
}

func (s *Rest_endpointContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rest_endpointContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rest_endpointContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRest_endpoint(s)
	}
}

func (s *Rest_endpointContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRest_endpoint(s)
	}
}

func (p *SyslParser) Rest_endpoint() (localctx IRest_endpointContext) {
	localctx = NewRest_endpointContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, SyslParserRULE_rest_endpoint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(930)
		p.Http_path()
	}
	p.SetState(932)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(931)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(934)
		p.Match(SyslParserCOLON)
	}

	{
		p.SetState(935)
		p.Match(SyslParserINDENT)
	}
	p.SetState(938)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserHTTP_VERBS || _la == SyslParserFORWARD_SLASH {
		p.SetState(938)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserHTTP_VERBS:
			{
				p.SetState(936)
				p.Method_def()
			}

		case SyslParserFORWARD_SLASH:
			{
				p.SetState(937)
				p.Rest_endpoint()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(940)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(942)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// ICollector_query_varContext is an interface to support dynamic dispatch.
type ICollector_query_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_query_varContext differentiates from other interfaces.
	IsCollector_query_varContext()
}

type Collector_query_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_query_varContext() *Collector_query_varContext {
	var p = new(Collector_query_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_query_var
	return p
}

func (*Collector_query_varContext) IsCollector_query_varContext() {}

func NewCollector_query_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_query_varContext {
	var p = new(Collector_query_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_query_var

	return p
}

func (s *Collector_query_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_query_varContext) AllName_str() []IName_strContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IName_strContext)(nil)).Elem())
	var tst = make([]IName_strContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IName_strContext)
		}
	}

	return tst
}

func (s *Collector_query_varContext) Name_str(i int) IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Collector_query_varContext) EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserEQ, 0)
}

func (s *Collector_query_varContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Collector_query_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_query_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_query_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_query_var(s)
	}
}

func (s *Collector_query_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_query_var(s)
	}
}

func (p *SyslParser) Collector_query_var() (localctx ICollector_query_varContext) {
	localctx = NewCollector_query_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, SyslParserRULE_collector_query_var)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(944)
		p.Name_str()
	}
	{
		p.SetState(945)
		p.Match(SyslParserEQ)
	}
	p.SetState(948)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserNativeDataTypes:
		{
			p.SetState(946)
			p.Match(SyslParserNativeDataTypes)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(947)
			p.Name_str()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICollector_query_paramContext is an interface to support dynamic dispatch.
type ICollector_query_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_query_paramContext differentiates from other interfaces.
	IsCollector_query_paramContext()
}

type Collector_query_paramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_query_paramContext() *Collector_query_paramContext {
	var p = new(Collector_query_paramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_query_param
	return p
}

func (*Collector_query_paramContext) IsCollector_query_paramContext() {}

func NewCollector_query_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_query_paramContext {
	var p = new(Collector_query_paramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_query_param

	return p
}

func (s *Collector_query_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_query_paramContext) QN() antlr.TerminalNode {
	return s.GetToken(SyslParserQN, 0)
}

func (s *Collector_query_paramContext) AllCollector_query_var() []ICollector_query_varContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICollector_query_varContext)(nil)).Elem())
	var tst = make([]ICollector_query_varContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICollector_query_varContext)
		}
	}

	return tst
}

func (s *Collector_query_paramContext) Collector_query_var(i int) ICollector_query_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_query_varContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICollector_query_varContext)
}

func (s *Collector_query_paramContext) AllAMP() []antlr.TerminalNode {
	return s.GetTokens(SyslParserAMP)
}

func (s *Collector_query_paramContext) AMP(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserAMP, i)
}

func (s *Collector_query_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_query_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_query_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_query_param(s)
	}
}

func (s *Collector_query_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_query_param(s)
	}
}

func (p *SyslParser) Collector_query_param() (localctx ICollector_query_paramContext) {
	localctx = NewCollector_query_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, SyslParserRULE_collector_query_param)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(950)
		p.Match(SyslParserQN)
	}
	{
		p.SetState(951)
		p.Collector_query_var()
	}
	p.SetState(956)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserAMP {
		{
			p.SetState(952)
			p.Match(SyslParserAMP)
		}
		{
			p.SetState(953)
			p.Collector_query_var()
		}

		p.SetState(958)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICollector_call_stmtContext is an interface to support dynamic dispatch.
type ICollector_call_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_call_stmtContext differentiates from other interfaces.
	IsCollector_call_stmtContext()
}

type Collector_call_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_call_stmtContext() *Collector_call_stmtContext {
	var p = new(Collector_call_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_call_stmt
	return p
}

func (*Collector_call_stmtContext) IsCollector_call_stmtContext() {}

func NewCollector_call_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_call_stmtContext {
	var p = new(Collector_call_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_call_stmt

	return p
}

func (s *Collector_call_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_call_stmtContext) Target() ITargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITargetContext)
}

func (s *Collector_call_stmtContext) ARROW_LEFT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_LEFT, 0)
}

func (s *Collector_call_stmtContext) Target_endpoint() ITarget_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITarget_endpointContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITarget_endpointContext)
}

func (s *Collector_call_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_call_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_call_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_call_stmt(s)
	}
}

func (s *Collector_call_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_call_stmt(s)
	}
}

func (p *SyslParser) Collector_call_stmt() (localctx ICollector_call_stmtContext) {
	localctx = NewCollector_call_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, SyslParserRULE_collector_call_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(959)
		p.Target()
	}
	{
		p.SetState(960)
		p.Match(SyslParserARROW_LEFT)
	}
	{
		p.SetState(961)
		p.Target_endpoint()
	}

	return localctx
}

// ICollector_http_stmt_partContext is an interface to support dynamic dispatch.
type ICollector_http_stmt_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_http_stmt_partContext differentiates from other interfaces.
	IsCollector_http_stmt_partContext()
}

type Collector_http_stmt_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_http_stmt_partContext() *Collector_http_stmt_partContext {
	var p = new(Collector_http_stmt_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_http_stmt_part
	return p
}

func (*Collector_http_stmt_partContext) IsCollector_http_stmt_partContext() {}

func NewCollector_http_stmt_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_http_stmt_partContext {
	var p = new(Collector_http_stmt_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_http_stmt_part

	return p
}

func (s *Collector_http_stmt_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_http_stmt_partContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Collector_http_stmt_partContext) CURLY_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_OPEN, 0)
}

func (s *Collector_http_stmt_partContext) CURLY_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_CLOSE, 0)
}

func (s *Collector_http_stmt_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_http_stmt_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_http_stmt_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_http_stmt_part(s)
	}
}

func (s *Collector_http_stmt_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_http_stmt_part(s)
	}
}

func (p *SyslParser) Collector_http_stmt_part() (localctx ICollector_http_stmt_partContext) {
	localctx = NewCollector_http_stmt_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, SyslParserRULE_collector_http_stmt_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(968)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(963)
			p.Name_str()
		}

	case SyslParserCURLY_OPEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(964)
			p.Match(SyslParserCURLY_OPEN)
		}
		{
			p.SetState(965)
			p.Name_str()
		}
		{
			p.SetState(966)
			p.Match(SyslParserCURLY_CLOSE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICollector_http_stmt_suffixContext is an interface to support dynamic dispatch.
type ICollector_http_stmt_suffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_http_stmt_suffixContext differentiates from other interfaces.
	IsCollector_http_stmt_suffixContext()
}

type Collector_http_stmt_suffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_http_stmt_suffixContext() *Collector_http_stmt_suffixContext {
	var p = new(Collector_http_stmt_suffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_http_stmt_suffix
	return p
}

func (*Collector_http_stmt_suffixContext) IsCollector_http_stmt_suffixContext() {}

func NewCollector_http_stmt_suffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_http_stmt_suffixContext {
	var p = new(Collector_http_stmt_suffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_http_stmt_suffix

	return p
}

func (s *Collector_http_stmt_suffixContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_http_stmt_suffixContext) AllFORWARD_SLASH() []antlr.TerminalNode {
	return s.GetTokens(SyslParserFORWARD_SLASH)
}

func (s *Collector_http_stmt_suffixContext) FORWARD_SLASH(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserFORWARD_SLASH, i)
}

func (s *Collector_http_stmt_suffixContext) AllCollector_http_stmt_part() []ICollector_http_stmt_partContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICollector_http_stmt_partContext)(nil)).Elem())
	var tst = make([]ICollector_http_stmt_partContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICollector_http_stmt_partContext)
		}
	}

	return tst
}

func (s *Collector_http_stmt_suffixContext) Collector_http_stmt_part(i int) ICollector_http_stmt_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_http_stmt_partContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICollector_http_stmt_partContext)
}

func (s *Collector_http_stmt_suffixContext) Collector_query_param() ICollector_query_paramContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_query_paramContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_query_paramContext)
}

func (s *Collector_http_stmt_suffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_http_stmt_suffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_http_stmt_suffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_http_stmt_suffix(s)
	}
}

func (s *Collector_http_stmt_suffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_http_stmt_suffix(s)
	}
}

func (p *SyslParser) Collector_http_stmt_suffix() (localctx ICollector_http_stmt_suffixContext) {
	localctx = NewCollector_http_stmt_suffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, SyslParserRULE_collector_http_stmt_suffix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(972)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserFORWARD_SLASH {
		{
			p.SetState(970)
			p.Match(SyslParserFORWARD_SLASH)
		}
		{
			p.SetState(971)
			p.Collector_http_stmt_part()
		}

		p.SetState(974)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(977)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQN {
		{
			p.SetState(976)
			p.Collector_query_param()
		}

	}

	return localctx
}

// ICollector_http_stmtContext is an interface to support dynamic dispatch.
type ICollector_http_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_http_stmtContext differentiates from other interfaces.
	IsCollector_http_stmtContext()
}

type Collector_http_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_http_stmtContext() *Collector_http_stmtContext {
	var p = new(Collector_http_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_http_stmt
	return p
}

func (*Collector_http_stmtContext) IsCollector_http_stmtContext() {}

func NewCollector_http_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_http_stmtContext {
	var p = new(Collector_http_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_http_stmt

	return p
}

func (s *Collector_http_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_http_stmtContext) HTTP_VERBS() antlr.TerminalNode {
	return s.GetToken(SyslParserHTTP_VERBS, 0)
}

func (s *Collector_http_stmtContext) Collector_http_stmt_suffix() ICollector_http_stmt_suffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_http_stmt_suffixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_http_stmt_suffixContext)
}

func (s *Collector_http_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_http_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_http_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_http_stmt(s)
	}
}

func (s *Collector_http_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_http_stmt(s)
	}
}

func (p *SyslParser) Collector_http_stmt() (localctx ICollector_http_stmtContext) {
	localctx = NewCollector_http_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, SyslParserRULE_collector_http_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(979)
		p.Match(SyslParserHTTP_VERBS)
	}
	{
		p.SetState(980)
		p.Collector_http_stmt_suffix()
	}

	return localctx
}

// IPublisherContext is an interface to support dynamic dispatch.
type IPublisherContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPublisherContext differentiates from other interfaces.
	IsPublisherContext()
}

type PublisherContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPublisherContext() *PublisherContext {
	var p = new(PublisherContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_publisher
	return p
}

func (*PublisherContext) IsPublisherContext() {}

func NewPublisherContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PublisherContext {
	var p = new(PublisherContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_publisher

	return p
}

func (s *PublisherContext) GetParser() antlr.Parser { return s.parser }

func (s *PublisherContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *PublisherContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PublisherContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PublisherContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterPublisher(s)
	}
}

func (s *PublisherContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitPublisher(s)
	}
}

func (p *SyslParser) Publisher() (localctx IPublisherContext) {
	localctx = NewPublisherContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, SyslParserRULE_publisher)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(982)
		p.App_name()
	}

	return localctx
}

// ISubscriberContext is an interface to support dynamic dispatch.
type ISubscriberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscriberContext differentiates from other interfaces.
	IsSubscriberContext()
}

type SubscriberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscriberContext() *SubscriberContext {
	var p = new(SubscriberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_subscriber
	return p
}

func (*SubscriberContext) IsSubscriberContext() {}

func NewSubscriberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscriberContext {
	var p = new(SubscriberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_subscriber

	return p
}

func (s *SubscriberContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscriberContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *SubscriberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubscriberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSubscriber(s)
	}
}

func (s *SubscriberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSubscriber(s)
	}
}

func (p *SyslParser) Subscriber() (localctx ISubscriberContext) {
	localctx = NewSubscriberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, SyslParserRULE_subscriber)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(984)
		p.App_name()
	}

	return localctx
}

// ICollector_pubsub_callContext is an interface to support dynamic dispatch.
type ICollector_pubsub_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_pubsub_callContext differentiates from other interfaces.
	IsCollector_pubsub_callContext()
}

type Collector_pubsub_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_pubsub_callContext() *Collector_pubsub_callContext {
	var p = new(Collector_pubsub_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_pubsub_call
	return p
}

func (*Collector_pubsub_callContext) IsCollector_pubsub_callContext() {}

func NewCollector_pubsub_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_pubsub_callContext {
	var p = new(Collector_pubsub_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_pubsub_call

	return p
}

func (s *Collector_pubsub_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_pubsub_callContext) Subscriber() ISubscriberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubscriberContext)
}

func (s *Collector_pubsub_callContext) ARROW_LEFT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_LEFT, 0)
}

func (s *Collector_pubsub_callContext) Publisher() IPublisherContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPublisherContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPublisherContext)
}

func (s *Collector_pubsub_callContext) ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_RIGHT, 0)
}

func (s *Collector_pubsub_callContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Collector_pubsub_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_pubsub_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_pubsub_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_pubsub_call(s)
	}
}

func (s *Collector_pubsub_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_pubsub_call(s)
	}
}

func (p *SyslParser) Collector_pubsub_call() (localctx ICollector_pubsub_callContext) {
	localctx = NewCollector_pubsub_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, SyslParserRULE_collector_pubsub_call)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(986)
		p.Subscriber()
	}
	{
		p.SetState(987)
		p.Match(SyslParserARROW_LEFT)
	}
	{
		p.SetState(988)
		p.Publisher()
	}
	{
		p.SetState(989)
		p.Match(SyslParserARROW_RIGHT)
	}
	{
		p.SetState(990)
		p.Name_str()
	}

	return localctx
}

// ICollector_action_stmtContext is an interface to support dynamic dispatch.
type ICollector_action_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_action_stmtContext differentiates from other interfaces.
	IsCollector_action_stmtContext()
}

type Collector_action_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_action_stmtContext() *Collector_action_stmtContext {
	var p = new(Collector_action_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_action_stmt
	return p
}

func (*Collector_action_stmtContext) IsCollector_action_stmtContext() {}

func NewCollector_action_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_action_stmtContext {
	var p = new(Collector_action_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_action_stmt

	return p
}

func (s *Collector_action_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_action_stmtContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Collector_action_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_action_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_action_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_action_stmt(s)
	}
}

func (s *Collector_action_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_action_stmt(s)
	}
}

func (p *SyslParser) Collector_action_stmt() (localctx ICollector_action_stmtContext) {
	localctx = NewCollector_action_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, SyslParserRULE_collector_action_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(992)
		p.Name_str()
	}

	return localctx
}

// ICollector_stmtsContext is an interface to support dynamic dispatch.
type ICollector_stmtsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_stmtsContext differentiates from other interfaces.
	IsCollector_stmtsContext()
}

type Collector_stmtsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_stmtsContext() *Collector_stmtsContext {
	var p = new(Collector_stmtsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_stmts
	return p
}

func (*Collector_stmtsContext) IsCollector_stmtsContext() {}

func NewCollector_stmtsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_stmtsContext {
	var p = new(Collector_stmtsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_stmts

	return p
}

func (s *Collector_stmtsContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_stmtsContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Collector_stmtsContext) Collector_action_stmt() ICollector_action_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_action_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_action_stmtContext)
}

func (s *Collector_stmtsContext) Collector_call_stmt() ICollector_call_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_call_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_call_stmtContext)
}

func (s *Collector_stmtsContext) Collector_http_stmt() ICollector_http_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_http_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_http_stmtContext)
}

func (s *Collector_stmtsContext) Collector_pubsub_call() ICollector_pubsub_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_pubsub_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_pubsub_callContext)
}

func (s *Collector_stmtsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_stmtsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_stmtsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_stmts(s)
	}
}

func (s *Collector_stmtsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_stmts(s)
	}
}

func (p *SyslParser) Collector_stmts() (localctx ICollector_stmtsContext) {
	localctx = NewCollector_stmtsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, SyslParserRULE_collector_stmts)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(998)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(994)
			p.Collector_action_stmt()
		}

	case 2:
		{
			p.SetState(995)
			p.Collector_call_stmt()
		}

	case 3:
		{
			p.SetState(996)
			p.Collector_http_stmt()
		}

	case 4:
		{
			p.SetState(997)
			p.Collector_pubsub_call()
		}

	}
	{
		p.SetState(1000)
		p.Attribs_or_modifiers()
	}

	return localctx
}

// ICollectorContext is an interface to support dynamic dispatch.
type ICollectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollectorContext differentiates from other interfaces.
	IsCollectorContext()
}

type CollectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollectorContext() *CollectorContext {
	var p = new(CollectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector
	return p
}

func (*CollectorContext) IsCollectorContext() {}

func NewCollectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollectorContext {
	var p = new(CollectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector

	return p
}

func (s *CollectorContext) GetParser() antlr.Parser { return s.parser }

func (s *CollectorContext) COLLECTOR() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLLECTOR, 0)
}

func (s *CollectorContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *CollectorContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *CollectorContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *CollectorContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *CollectorContext) AllCollector_stmts() []ICollector_stmtsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICollector_stmtsContext)(nil)).Elem())
	var tst = make([]ICollector_stmtsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICollector_stmtsContext)
		}
	}

	return tst
}

func (s *CollectorContext) Collector_stmts(i int) ICollector_stmtsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_stmtsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICollector_stmtsContext)
}

func (s *CollectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector(s)
	}
}

func (s *CollectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector(s)
	}
}

func (p *SyslParser) Collector() (localctx ICollectorContext) {
	localctx = NewCollectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, SyslParserRULE_collector)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1002)
		p.Match(SyslParserCOLLECTOR)
	}
	{
		p.SetState(1003)
		p.Match(SyslParserCOLON)
	}
	p.SetState(1013)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(1004)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(1005)
			p.Match(SyslParserINDENT)
		}
		p.SetState(1007)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SyslParserHTTP_VERBS || _la == SyslParserTEXT_LINE || _la == SyslParserName || _la == SyslParserE_Name {
			{
				p.SetState(1006)
				p.Collector_stmts()
			}

			p.SetState(1009)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1011)
			p.Match(SyslParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEventContext is an interface to support dynamic dispatch.
type IEventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEventContext differentiates from other interfaces.
	IsEventContext()
}

type EventContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEventContext() *EventContext {
	var p = new(EventContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_event
	return p
}

func (*EventContext) IsEventContext() {}

func NewEventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventContext {
	var p = new(EventContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_event

	return p
}

func (s *EventContext) GetParser() antlr.Parser { return s.parser }

func (s *EventContext) DISTANCE() antlr.TerminalNode {
	return s.GetToken(SyslParserDISTANCE, 0)
}

func (s *EventContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *EventContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *EventContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *EventContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *EventContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *EventContext) Params() IParamsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamsContext)
}

func (s *EventContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *EventContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *EventContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *EventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterEvent(s)
	}
}

func (s *EventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitEvent(s)
	}
}

func (p *SyslParser) Event() (localctx IEventContext) {
	localctx = NewEventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, SyslParserRULE_event)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1015)
		p.Match(SyslParserDISTANCE)
	}
	{
		p.SetState(1016)
		p.Name_str()
	}
	p.SetState(1018)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserOPEN_PAREN {
		{
			p.SetState(1017)
			p.Params()
		}

	}
	p.SetState(1021)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(1020)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(1023)
		p.Match(SyslParserCOLON)
	}
	p.SetState(1033)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(1024)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(1025)
			p.Match(SyslParserINDENT)
		}
		p.SetState(1027)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(SyslParserAT-41))|(1<<(SyslParserPIPE-41))|(1<<(SyslParserQSTRING-41))|(1<<(SyslParserSYSL_COMMENT-41))|(1<<(SyslParserTEXT_LINE-41))|(1<<(SyslParserName-41)))) != 0) || _la == SyslParserE_Name {
			{
				p.SetState(1026)
				p.Statements()
			}

			p.SetState(1029)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1031)
			p.Match(SyslParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISubscribeContext is an interface to support dynamic dispatch.
type ISubscribeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscribeContext differentiates from other interfaces.
	IsSubscribeContext()
}

type SubscribeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscribeContext() *SubscribeContext {
	var p = new(SubscribeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_subscribe
	return p
}

func (*SubscribeContext) IsSubscribeContext() {}

func NewSubscribeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscribeContext {
	var p = new(SubscribeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_subscribe

	return p
}

func (s *SubscribeContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscribeContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *SubscribeContext) ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_RIGHT, 0)
}

func (s *SubscribeContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *SubscribeContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *SubscribeContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *SubscribeContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *SubscribeContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *SubscribeContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *SubscribeContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *SubscribeContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *SubscribeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscribeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubscribeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSubscribe(s)
	}
}

func (s *SubscribeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSubscribe(s)
	}
}

func (p *SyslParser) Subscribe() (localctx ISubscribeContext) {
	localctx = NewSubscribeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, SyslParserRULE_subscribe)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1035)
		p.App_name()
	}
	{
		p.SetState(1036)
		p.Match(SyslParserARROW_RIGHT)
	}
	{
		p.SetState(1037)
		p.Name_str()
	}
	p.SetState(1039)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(1038)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(1041)
		p.Match(SyslParserCOLON)
	}
	p.SetState(1051)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(1042)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(1043)
			p.Match(SyslParserINDENT)
		}
		p.SetState(1045)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(SyslParserAT-41))|(1<<(SyslParserPIPE-41))|(1<<(SyslParserQSTRING-41))|(1<<(SyslParserSYSL_COMMENT-41))|(1<<(SyslParserTEXT_LINE-41))|(1<<(SyslParserName-41)))) != 0) || _la == SyslParserE_Name {
			{
				p.SetState(1044)
				p.Statements()
			}

			p.SetState(1047)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1049)
			p.Match(SyslParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IView_type_specContext is an interface to support dynamic dispatch.
type IView_type_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsView_type_specContext differentiates from other interfaces.
	IsView_type_specContext()
}

type View_type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyView_type_specContext() *View_type_specContext {
	var p = new(View_type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view_type_spec
	return p
}

func (*View_type_specContext) IsView_type_specContext() {}

func NewView_type_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *View_type_specContext {
	var p = new(View_type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view_type_spec

	return p
}

func (s *View_type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *View_type_specContext) Collection_type() ICollection_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollection_typeContext)
}

func (s *View_type_specContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *View_type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *View_type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *View_type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView_type_spec(s)
	}
}

func (s *View_type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView_type_spec(s)
	}
}

func (p *SyslParser) View_type_spec() (localctx IView_type_specContext) {
	localctx = NewView_type_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, SyslParserRULE_view_type_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1055)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserSET_OF, SyslParserE_SET_OF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1053)
			p.Collection_type()
		}

	case SyslParserNativeDataTypes, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1054)
			p.Types()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) E_DIGITS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DIGITS, 0)
}

func (s *LiteralContext) E_DECIMAL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DECIMAL, 0)
}

func (s *LiteralContext) E_STRING() antlr.TerminalNode {
	return s.GetToken(SyslParserE_STRING, 0)
}

func (s *LiteralContext) E_NULL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NULL, 0)
}

func (s *LiteralContext) E_TRUE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TRUE, 0)
}

func (s *LiteralContext) E_FALSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_FALSE, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *SyslParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, SyslParserRULE_literal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1057)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(SyslParserE_TRUE-113))|(1<<(SyslParserE_FALSE-113))|(1<<(SyslParserE_NULL-113))|(1<<(SyslParserE_STRING-113))|(1<<(SyslParserE_DECIMAL-113))|(1<<(SyslParserE_DIGITS-113)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IExpr_table_of_opContext is an interface to support dynamic dispatch.
type IExpr_table_of_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_table_of_opContext differentiates from other interfaces.
	IsExpr_table_of_opContext()
}

type Expr_table_of_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_table_of_opContext() *Expr_table_of_opContext {
	var p = new(Expr_table_of_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_table_of_op
	return p
}

func (*Expr_table_of_opContext) IsExpr_table_of_opContext() {}

func NewExpr_table_of_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_table_of_opContext {
	var p = new(Expr_table_of_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_table_of_op

	return p
}

func (s *Expr_table_of_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_table_of_opContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_table_of_opContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *Expr_table_of_opContext) E_NULLSAFE_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NULLSAFE_DOT, 0)
}

func (s *Expr_table_of_opContext) E_TABLE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TABLE_OF, 0)
}

func (s *Expr_table_of_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_table_of_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_table_of_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_table_of_op(s)
	}
}

func (s *Expr_table_of_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_table_of_op(s)
	}
}

func (p *SyslParser) Expr_table_of_op() (localctx IExpr_table_of_opContext) {
	localctx = NewExpr_table_of_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, SyslParserRULE_expr_table_of_op)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1059)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserE_NULLSAFE_DOT || _la == SyslParserE_DOT) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(1061)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_TABLE_OF {
		{
			p.SetState(1060)
			p.Match(SyslParserE_TABLE_OF)
		}

	}
	{
		p.SetState(1063)
		p.Match(SyslParserE_Name)
	}

	return localctx
}

// IFunc_argContext is an interface to support dynamic dispatch.
type IFunc_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunc_argContext differentiates from other interfaces.
	IsFunc_argContext()
}

type Func_argContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_argContext() *Func_argContext {
	var p = new(Func_argContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_func_arg
	return p
}

func (*Func_argContext) IsFunc_argContext() {}

func NewFunc_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_argContext {
	var p = new(Func_argContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_func_arg

	return p
}

func (s *Func_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Func_argContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Func_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFunc_arg(s)
	}
}

func (s *Func_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFunc_arg(s)
	}
}

func (p *SyslParser) Func_arg() (localctx IFunc_argContext) {
	localctx = NewFunc_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, SyslParserRULE_func_arg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1065)
		p.Expr()
	}

	return localctx
}

// IFunc_argsContext is an interface to support dynamic dispatch.
type IFunc_argsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunc_argsContext differentiates from other interfaces.
	IsFunc_argsContext()
}

type Func_argsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_argsContext() *Func_argsContext {
	var p = new(Func_argsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_func_args
	return p
}

func (*Func_argsContext) IsFunc_argsContext() {}

func NewFunc_argsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_argsContext {
	var p = new(Func_argsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_func_args

	return p
}

func (s *Func_argsContext) GetParser() antlr.Parser { return s.parser }

func (s *Func_argsContext) AllFunc_arg() []IFunc_argContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunc_argContext)(nil)).Elem())
	var tst = make([]IFunc_argContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunc_argContext)
		}
	}

	return tst
}

func (s *Func_argsContext) Func_arg(i int) IFunc_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunc_argContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunc_argContext)
}

func (s *Func_argsContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *Func_argsContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *Func_argsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_argsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_argsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFunc_args(s)
	}
}

func (s *Func_argsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFunc_args(s)
	}
}

func (p *SyslParser) Func_args() (localctx IFunc_argsContext) {
	localctx = NewFunc_argsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, SyslParserRULE_func_args)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1067)
		p.Func_arg()
	}
	p.SetState(1072)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1068)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1069)
			p.Func_arg()
		}

		p.SetState(1074)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpr_funcContext is an interface to support dynamic dispatch.
type IExpr_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_funcContext differentiates from other interfaces.
	IsExpr_funcContext()
}

type Expr_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_funcContext() *Expr_funcContext {
	var p = new(Expr_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_func
	return p
}

func (*Expr_funcContext) IsExpr_funcContext() {}

func NewExpr_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_funcContext {
	var p = new(Expr_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_func

	return p
}

func (s *Expr_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_funcContext) E_FUNC() antlr.TerminalNode {
	return s.GetToken(SyslParserE_FUNC, 0)
}

func (s *Expr_funcContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_funcContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Expr_funcContext) Func_args() IFunc_argsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunc_argsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunc_argsContext)
}

func (s *Expr_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_func(s)
	}
}

func (s *Expr_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_func(s)
	}
}

func (p *SyslParser) Expr_func() (localctx IExpr_funcContext) {
	localctx = NewExpr_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, SyslParserRULE_expr_func)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1075)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserNativeDataTypes || _la == SyslParserE_FUNC || _la == SyslParserE_Name) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(1076)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1078)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserNativeDataTypes || (((_la-71)&-(0x1f+1)) == 0 && ((1<<uint((_la-71)))&((1<<(SyslParserE_WHATEVER-71))|(1<<(SyslParserE_ARROW_RIGHT-71))|(1<<(SyslParserE_SQ_OPEN-71))|(1<<(SyslParserE_EMPTY_TUPLE-71))|(1<<(SyslParserE_CURLY_OPEN-71))|(1<<(SyslParserE_NULLSAFE_DOT-71))|(1<<(SyslParserE_OPEN_PAREN-71))|(1<<(SyslParserE_PLUS-71))|(1<<(SyslParserE_MINUS-71))|(1<<(SyslParserE_QN-71))|(1<<(SyslParserE_TILDE-71))|(1<<(SyslParserE_NOT-71)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SyslParserE_IF-109))|(1<<(SyslParserE_TRUE-109))|(1<<(SyslParserE_FALSE-109))|(1<<(SyslParserE_NULL-109))|(1<<(SyslParserE_FUNC-109))|(1<<(SyslParserE_STRING-109))|(1<<(SyslParserE_DECIMAL-109))|(1<<(SyslParserE_DIGITS-109))|(1<<(SyslParserE_Name-109))|(1<<(SyslParserE_DOT-109)))) != 0) {
		{
			p.SetState(1077)
			p.Func_args()
		}

	}
	{
		p.SetState(1080)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IRank_exprContext is an interface to support dynamic dispatch.
type IRank_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRank_exprContext differentiates from other interfaces.
	IsRank_exprContext()
}

type Rank_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRank_exprContext() *Rank_exprContext {
	var p = new(Rank_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_rank_expr
	return p
}

func (*Rank_exprContext) IsRank_exprContext() {}

func NewRank_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rank_exprContext {
	var p = new(Rank_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_rank_expr

	return p
}

func (s *Rank_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Rank_exprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Rank_exprContext) E_ASC() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ASC, 0)
}

func (s *Rank_exprContext) E_DESC() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DESC, 0)
}

func (s *Rank_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rank_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rank_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRank_expr(s)
	}
}

func (s *Rank_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRank_expr(s)
	}
}

func (p *SyslParser) Rank_expr() (localctx IRank_exprContext) {
	localctx = NewRank_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, SyslParserRULE_rank_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1082)
		p.Expr()
	}
	p.SetState(1084)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_ASC || _la == SyslParserE_DESC {
		p.SetState(1083)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SyslParserE_ASC || _la == SyslParserE_DESC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}

	return localctx
}

// IRank_expr_listContext is an interface to support dynamic dispatch.
type IRank_expr_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRank_expr_listContext differentiates from other interfaces.
	IsRank_expr_listContext()
}

type Rank_expr_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRank_expr_listContext() *Rank_expr_listContext {
	var p = new(Rank_expr_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_rank_expr_list
	return p
}

func (*Rank_expr_listContext) IsRank_expr_listContext() {}

func NewRank_expr_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rank_expr_listContext {
	var p = new(Rank_expr_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_rank_expr_list

	return p
}

func (s *Rank_expr_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Rank_expr_listContext) AllRank_expr() []IRank_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRank_exprContext)(nil)).Elem())
	var tst = make([]IRank_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRank_exprContext)
		}
	}

	return tst
}

func (s *Rank_expr_listContext) Rank_expr(i int) IRank_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRank_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRank_exprContext)
}

func (s *Rank_expr_listContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *Rank_expr_listContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *Rank_expr_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rank_expr_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rank_expr_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRank_expr_list(s)
	}
}

func (s *Rank_expr_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRank_expr_list(s)
	}
}

func (p *SyslParser) Rank_expr_list() (localctx IRank_expr_listContext) {
	localctx = NewRank_expr_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, SyslParserRULE_rank_expr_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1086)
		p.Rank_expr()
	}
	p.SetState(1091)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1087)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1088)
			p.Rank_expr()
		}

		p.SetState(1093)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpr_rank_funcContext is an interface to support dynamic dispatch.
type IExpr_rank_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_rank_funcContext differentiates from other interfaces.
	IsExpr_rank_funcContext()
}

type Expr_rank_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_rank_funcContext() *Expr_rank_funcContext {
	var p = new(Expr_rank_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_rank_func
	return p
}

func (*Expr_rank_funcContext) IsExpr_rank_funcContext() {}

func NewExpr_rank_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_rank_funcContext {
	var p = new(Expr_rank_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_rank_func

	return p
}

func (s *Expr_rank_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_rank_funcContext) E_RELOPS_RANK() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_RANK, 0)
}

func (s *Expr_rank_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_rank_funcContext) Rank_expr_list() IRank_expr_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRank_expr_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRank_expr_listContext)
}

func (s *Expr_rank_funcContext) E_AS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_AS, 0)
}

func (s *Expr_rank_funcContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_rank_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_rank_funcContext) E_ANGLE_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_OPEN, 0)
}

func (s *Expr_rank_funcContext) View_type_spec() IView_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_type_specContext)
}

func (s *Expr_rank_funcContext) E_ANGLE_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_CLOSE, 0)
}

func (s *Expr_rank_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_rank_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_rank_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_rank_func(s)
	}
}

func (s *Expr_rank_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_rank_func(s)
	}
}

func (p *SyslParser) Expr_rank_func() (localctx IExpr_rank_funcContext) {
	localctx = NewExpr_rank_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, SyslParserRULE_expr_rank_func)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1094)
		p.Match(SyslParserE_RELOPS_RANK)
	}
	p.SetState(1099)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_ANGLE_OPEN {
		{
			p.SetState(1095)
			p.Match(SyslParserE_ANGLE_OPEN)
		}
		{
			p.SetState(1096)
			p.View_type_spec()
		}
		{
			p.SetState(1097)
			p.Match(SyslParserE_ANGLE_CLOSE)
		}

	}
	{
		p.SetState(1101)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	{
		p.SetState(1102)
		p.Rank_expr_list()
	}
	{
		p.SetState(1103)
		p.Match(SyslParserE_AS)
	}
	{
		p.SetState(1104)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1105)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IExpr_agg_funcContext is an interface to support dynamic dispatch.
type IExpr_agg_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_agg_funcContext differentiates from other interfaces.
	IsExpr_agg_funcContext()
}

type Expr_agg_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_agg_funcContext() *Expr_agg_funcContext {
	var p = new(Expr_agg_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_agg_func
	return p
}

func (*Expr_agg_funcContext) IsExpr_agg_funcContext() {}

func NewExpr_agg_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_agg_funcContext {
	var p = new(Expr_agg_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_agg_func

	return p
}

func (s *Expr_agg_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_agg_funcContext) E_RELOPS_AGG() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_AGG, 0)
}

func (s *Expr_agg_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_agg_funcContext) Func_args() IFunc_argsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunc_argsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunc_argsContext)
}

func (s *Expr_agg_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_agg_funcContext) E_scope_var() IE_scope_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_scope_varContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IE_scope_varContext)
}

func (s *Expr_agg_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_agg_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_agg_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_agg_func(s)
	}
}

func (s *Expr_agg_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_agg_func(s)
	}
}

func (p *SyslParser) Expr_agg_func() (localctx IExpr_agg_funcContext) {
	localctx = NewExpr_agg_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, SyslParserRULE_expr_agg_func)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1107)
		p.Match(SyslParserE_RELOPS_AGG)
	}
	{
		p.SetState(1108)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1110)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1109)
			p.E_scope_var()
		}

	}
	{
		p.SetState(1112)
		p.Func_args()
	}
	{
		p.SetState(1113)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IE_scope_varContext is an interface to support dynamic dispatch.
type IE_scope_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsE_scope_varContext differentiates from other interfaces.
	IsE_scope_varContext()
}

type E_scope_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyE_scope_varContext() *E_scope_varContext {
	var p = new(E_scope_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_e_scope_var
	return p
}

func (*E_scope_varContext) IsE_scope_varContext() {}

func NewE_scope_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *E_scope_varContext {
	var p = new(E_scope_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_e_scope_var

	return p
}

func (s *E_scope_varContext) GetParser() antlr.Parser { return s.parser }

func (s *E_scope_varContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *E_scope_varContext) E_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserE_COLON, 0)
}

func (s *E_scope_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *E_scope_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *E_scope_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterE_scope_var(s)
	}
}

func (s *E_scope_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitE_scope_var(s)
	}
}

func (p *SyslParser) E_scope_var() (localctx IE_scope_varContext) {
	localctx = NewE_scope_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, SyslParserRULE_e_scope_var)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1115)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1116)
		p.Match(SyslParserE_COLON)
	}

	return localctx
}

// IFirst_func_targetContext is an interface to support dynamic dispatch.
type IFirst_func_targetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFirst_func_targetContext differentiates from other interfaces.
	IsFirst_func_targetContext()
}

type First_func_targetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFirst_func_targetContext() *First_func_targetContext {
	var p = new(First_func_targetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_first_func_target
	return p
}

func (*First_func_targetContext) IsFirst_func_targetContext() {}

func NewFirst_func_targetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *First_func_targetContext {
	var p = new(First_func_targetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_first_func_target

	return p
}

func (s *First_func_targetContext) GetParser() antlr.Parser { return s.parser }

func (s *First_func_targetContext) E_NULL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NULL, 0)
}

func (s *First_func_targetContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *First_func_targetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *First_func_targetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *First_func_targetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFirst_func_target(s)
	}
}

func (s *First_func_targetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFirst_func_target(s)
	}
}

func (p *SyslParser) First_func_target() (localctx IFirst_func_targetContext) {
	localctx = NewFirst_func_targetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, SyslParserRULE_first_func_target)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1120)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1118)
			p.Match(SyslParserE_NULL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1119)
			p.Expr()
		}

	}

	return localctx
}

// IExpr_first_funcContext is an interface to support dynamic dispatch.
type IExpr_first_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_first_funcContext differentiates from other interfaces.
	IsExpr_first_funcContext()
}

type Expr_first_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_first_funcContext() *Expr_first_funcContext {
	var p = new(Expr_first_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_first_func
	return p
}

func (*Expr_first_funcContext) IsExpr_first_funcContext() {}

func NewExpr_first_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_first_funcContext {
	var p = new(Expr_first_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_first_func

	return p
}

func (s *Expr_first_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_first_funcContext) E_RELOPS_FIRST() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_FIRST, 0)
}

func (s *Expr_first_funcContext) First_func_target() IFirst_func_targetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFirst_func_targetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFirst_func_targetContext)
}

func (s *Expr_first_funcContext) E_BY() antlr.TerminalNode {
	return s.GetToken(SyslParserE_BY, 0)
}

func (s *Expr_first_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_first_funcContext) Rank_expr_list() IRank_expr_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRank_expr_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRank_expr_listContext)
}

func (s *Expr_first_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_first_funcContext) E_scope_var() IE_scope_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_scope_varContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IE_scope_varContext)
}

func (s *Expr_first_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_first_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_first_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_first_func(s)
	}
}

func (s *Expr_first_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_first_func(s)
	}
}

func (p *SyslParser) Expr_first_func() (localctx IExpr_first_funcContext) {
	localctx = NewExpr_first_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, SyslParserRULE_expr_first_func)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1122)
		p.Match(SyslParserE_RELOPS_FIRST)
	}
	{
		p.SetState(1123)
		p.First_func_target()
	}
	{
		p.SetState(1124)
		p.Match(SyslParserE_BY)
	}
	{
		p.SetState(1125)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1127)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1126)
			p.E_scope_var()
		}

	}
	{
		p.SetState(1129)
		p.Rank_expr_list()
	}
	{
		p.SetState(1130)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IE_single_arg_funcContext is an interface to support dynamic dispatch.
type IE_single_arg_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsE_single_arg_funcContext differentiates from other interfaces.
	IsE_single_arg_funcContext()
}

type E_single_arg_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyE_single_arg_funcContext() *E_single_arg_funcContext {
	var p = new(E_single_arg_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_e_single_arg_func
	return p
}

func (*E_single_arg_funcContext) IsE_single_arg_funcContext() {}

func NewE_single_arg_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *E_single_arg_funcContext {
	var p = new(E_single_arg_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_e_single_arg_func

	return p
}

func (s *E_single_arg_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *E_single_arg_funcContext) E_RELOPS_WHERE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_WHERE, 0)
}

func (s *E_single_arg_funcContext) E_RELOPS_FLATTEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_FLATTEN, 0)
}

func (s *E_single_arg_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *E_single_arg_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *E_single_arg_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterE_single_arg_func(s)
	}
}

func (s *E_single_arg_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitE_single_arg_func(s)
	}
}

func (p *SyslParser) E_single_arg_func() (localctx IE_single_arg_funcContext) {
	localctx = NewE_single_arg_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, SyslParserRULE_e_single_arg_func)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1132)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserE_RELOPS_WHERE || _la == SyslParserE_RELOPS_FLATTEN) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IExpr_single_arg_funcContext is an interface to support dynamic dispatch.
type IExpr_single_arg_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_single_arg_funcContext differentiates from other interfaces.
	IsExpr_single_arg_funcContext()
}

type Expr_single_arg_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_single_arg_funcContext() *Expr_single_arg_funcContext {
	var p = new(Expr_single_arg_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_single_arg_func
	return p
}

func (*Expr_single_arg_funcContext) IsExpr_single_arg_funcContext() {}

func NewExpr_single_arg_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_single_arg_funcContext {
	var p = new(Expr_single_arg_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_single_arg_func

	return p
}

func (s *Expr_single_arg_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_single_arg_funcContext) E_single_arg_func() IE_single_arg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_single_arg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IE_single_arg_funcContext)
}

func (s *Expr_single_arg_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_single_arg_funcContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_single_arg_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_single_arg_funcContext) E_scope_var() IE_scope_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_scope_varContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IE_scope_varContext)
}

func (s *Expr_single_arg_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_single_arg_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_single_arg_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_single_arg_func(s)
	}
}

func (s *Expr_single_arg_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_single_arg_func(s)
	}
}

func (p *SyslParser) Expr_single_arg_func() (localctx IExpr_single_arg_funcContext) {
	localctx = NewExpr_single_arg_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, SyslParserRULE_expr_single_arg_func)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1134)
		p.E_single_arg_func()
	}
	{
		p.SetState(1135)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1137)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1136)
			p.E_scope_var()
		}

	}
	{
		p.SetState(1139)
		p.Expr()
	}
	{
		p.SetState(1140)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IExpr_any_funcContext is an interface to support dynamic dispatch.
type IExpr_any_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_any_funcContext differentiates from other interfaces.
	IsExpr_any_funcContext()
}

type Expr_any_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_any_funcContext() *Expr_any_funcContext {
	var p = new(Expr_any_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_any_func
	return p
}

func (*Expr_any_funcContext) IsExpr_any_funcContext() {}

func NewExpr_any_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_any_funcContext {
	var p = new(Expr_any_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_any_func

	return p
}

func (s *Expr_any_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_any_funcContext) E_RELOPS_ANY() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_ANY, 0)
}

func (s *Expr_any_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_any_funcContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_any_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_any_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_any_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_any_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_any_func(s)
	}
}

func (s *Expr_any_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_any_func(s)
	}
}

func (p *SyslParser) Expr_any_func() (localctx IExpr_any_funcContext) {
	localctx = NewExpr_any_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, SyslParserRULE_expr_any_func)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1142)
		p.Match(SyslParserE_RELOPS_ANY)
	}
	{
		p.SetState(1143)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	{
		p.SetState(1144)
		p.Expr()
	}
	{
		p.SetState(1145)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IExpr_single_or_nullContext is an interface to support dynamic dispatch.
type IExpr_single_or_nullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_single_or_nullContext differentiates from other interfaces.
	IsExpr_single_or_nullContext()
}

type Expr_single_or_nullContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_single_or_nullContext() *Expr_single_or_nullContext {
	var p = new(Expr_single_or_nullContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_single_or_null
	return p
}

func (*Expr_single_or_nullContext) IsExpr_single_or_nullContext() {}

func NewExpr_single_or_nullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_single_or_nullContext {
	var p = new(Expr_single_or_nullContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_single_or_null

	return p
}

func (s *Expr_single_or_nullContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_single_or_nullContext) E_RELOPS_SINGLE_NULL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_SINGLE_NULL, 0)
}

func (s *Expr_single_or_nullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_single_or_nullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_single_or_nullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_single_or_null(s)
	}
}

func (s *Expr_single_or_nullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_single_or_null(s)
	}
}

func (p *SyslParser) Expr_single_or_null() (localctx IExpr_single_or_nullContext) {
	localctx = NewExpr_single_or_nullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, SyslParserRULE_expr_single_or_null)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1147)
		p.Match(SyslParserE_RELOPS_SINGLE_NULL)
	}

	return localctx
}

// IExpr_snapshotContext is an interface to support dynamic dispatch.
type IExpr_snapshotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_snapshotContext differentiates from other interfaces.
	IsExpr_snapshotContext()
}

type Expr_snapshotContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_snapshotContext() *Expr_snapshotContext {
	var p = new(Expr_snapshotContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_snapshot
	return p
}

func (*Expr_snapshotContext) IsExpr_snapshotContext() {}

func NewExpr_snapshotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_snapshotContext {
	var p = new(Expr_snapshotContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_snapshot

	return p
}

func (s *Expr_snapshotContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_snapshotContext) E_RELOPS_SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_SNAPSHOT, 0)
}

func (s *Expr_snapshotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_snapshotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_snapshotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_snapshot(s)
	}
}

func (s *Expr_snapshotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_snapshot(s)
	}
}

func (p *SyslParser) Expr_snapshot() (localctx IExpr_snapshotContext) {
	localctx = NewExpr_snapshotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, SyslParserRULE_expr_snapshot)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1149)
		p.Match(SyslParserE_RELOPS_SNAPSHOT)
	}

	return localctx
}

// IExpr_countContext is an interface to support dynamic dispatch.
type IExpr_countContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_countContext differentiates from other interfaces.
	IsExpr_countContext()
}

type Expr_countContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_countContext() *Expr_countContext {
	var p = new(Expr_countContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_count
	return p
}

func (*Expr_countContext) IsExpr_countContext() {}

func NewExpr_countContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_countContext {
	var p = new(Expr_countContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_count

	return p
}

func (s *Expr_countContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_countContext) E_RELOPS_COUNT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_COUNT, 0)
}

func (s *Expr_countContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_countContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_countContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_count(s)
	}
}

func (s *Expr_countContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_count(s)
	}
}

func (p *SyslParser) Expr_count() (localctx IExpr_countContext) {
	localctx = NewExpr_countContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, SyslParserRULE_expr_count)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1151)
		p.Match(SyslParserE_RELOPS_COUNT)
	}

	return localctx
}

// IExpr_navigate_attrContext is an interface to support dynamic dispatch.
type IExpr_navigate_attrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_navigate_attrContext differentiates from other interfaces.
	IsExpr_navigate_attrContext()
}

type Expr_navigate_attrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_navigate_attrContext() *Expr_navigate_attrContext {
	var p = new(Expr_navigate_attrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_navigate_attr
	return p
}

func (*Expr_navigate_attrContext) IsExpr_navigate_attrContext() {}

func NewExpr_navigate_attrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_navigate_attrContext {
	var p = new(Expr_navigate_attrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_navigate_attr

	return p
}

func (s *Expr_navigate_attrContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_navigate_attrContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_navigate_attrContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *Expr_navigate_attrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_navigate_attrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_navigate_attrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_navigate_attr(s)
	}
}

func (s *Expr_navigate_attrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_navigate_attr(s)
	}
}

func (p *SyslParser) Expr_navigate_attr() (localctx IExpr_navigate_attrContext) {
	localctx = NewExpr_navigate_attrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, SyslParserRULE_expr_navigate_attr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1154)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_DOT {
		{
			p.SetState(1153)
			p.Match(SyslParserE_DOT)
		}

	}
	{
		p.SetState(1156)
		p.Match(SyslParserE_Name)
	}

	return localctx
}

// IExpr_navigateContext is an interface to support dynamic dispatch.
type IExpr_navigateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_navigateContext differentiates from other interfaces.
	IsExpr_navigateContext()
}

type Expr_navigateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_navigateContext() *Expr_navigateContext {
	var p = new(Expr_navigateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_navigate
	return p
}

func (*Expr_navigateContext) IsExpr_navigateContext() {}

func NewExpr_navigateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_navigateContext {
	var p = new(Expr_navigateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_navigate

	return p
}

func (s *Expr_navigateContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_navigateContext) E_ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ARROW_RIGHT, 0)
}

func (s *Expr_navigateContext) Expr_navigate_attr() IExpr_navigate_attrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigate_attrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigate_attrContext)
}

func (s *Expr_navigateContext) E_QN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_QN, 0)
}

func (s *Expr_navigateContext) E_SET_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SET_OF, 0)
}

func (s *Expr_navigateContext) E_VIA() antlr.TerminalNode {
	return s.GetToken(SyslParserE_VIA, 0)
}

func (s *Expr_navigateContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_navigateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_navigateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_navigateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_navigate(s)
	}
}

func (s *Expr_navigateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_navigate(s)
	}
}

func (p *SyslParser) Expr_navigate() (localctx IExpr_navigateContext) {
	localctx = NewExpr_navigateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, SyslParserRULE_expr_navigate)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1159)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_QN {
		{
			p.SetState(1158)
			p.Match(SyslParserE_QN)
		}

	}
	{
		p.SetState(1161)
		p.Match(SyslParserE_ARROW_RIGHT)
	}
	p.SetState(1163)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_SET_OF {
		{
			p.SetState(1162)
			p.Match(SyslParserE_SET_OF)
		}

	}
	{
		p.SetState(1165)
		p.Expr_navigate_attr()
	}
	p.SetState(1168)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1166)
			p.Match(SyslParserE_VIA)
		}
		{
			p.SetState(1167)
			p.Match(SyslParserE_Name)
		}

	}

	return localctx
}

// IMatching_rhsContext is an interface to support dynamic dispatch.
type IMatching_rhsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMatching_rhsContext differentiates from other interfaces.
	IsMatching_rhsContext()
}

type Matching_rhsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatching_rhsContext() *Matching_rhsContext {
	var p = new(Matching_rhsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_matching_rhs
	return p
}

func (*Matching_rhsContext) IsMatching_rhsContext() {}

func NewMatching_rhsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Matching_rhsContext {
	var p = new(Matching_rhsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_matching_rhs

	return p
}

func (s *Matching_rhsContext) GetParser() antlr.Parser { return s.parser }

func (s *Matching_rhsContext) Expr_table_of_op() IExpr_table_of_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_table_of_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_table_of_opContext)
}

func (s *Matching_rhsContext) Expr_navigate() IExpr_navigateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigateContext)
}

func (s *Matching_rhsContext) AtomT_paren() IAtomT_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomT_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomT_parenContext)
}

func (s *Matching_rhsContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Matching_rhsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Matching_rhsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Matching_rhsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterMatching_rhs(s)
	}
}

func (s *Matching_rhsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitMatching_rhs(s)
	}
}

func (p *SyslParser) Matching_rhs() (localctx IMatching_rhsContext) {
	localctx = NewMatching_rhsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, SyslParserRULE_matching_rhs)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1174)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_NULLSAFE_DOT, SyslParserE_DOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1170)
			p.Expr_table_of_op()
		}

	case SyslParserE_ARROW_RIGHT, SyslParserE_QN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1171)
			p.Expr_navigate()
		}

	case SyslParserE_OPEN_PAREN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1172)
			p.AtomT_paren()
		}

	case SyslParserE_Name:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1173)
			p.Match(SyslParserE_Name)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISquiggly_argsContext is an interface to support dynamic dispatch.
type ISquiggly_argsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSquiggly_argsContext differentiates from other interfaces.
	IsSquiggly_argsContext()
}

type Squiggly_argsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySquiggly_argsContext() *Squiggly_argsContext {
	var p = new(Squiggly_argsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_squiggly_args
	return p
}

func (*Squiggly_argsContext) IsSquiggly_argsContext() {}

func NewSquiggly_argsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Squiggly_argsContext {
	var p = new(Squiggly_argsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_squiggly_args

	return p
}

func (s *Squiggly_argsContext) GetParser() antlr.Parser { return s.parser }

func (s *Squiggly_argsContext) E_SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SQ_OPEN, 0)
}

func (s *Squiggly_argsContext) AllE_Name() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_Name)
}

func (s *Squiggly_argsContext) E_Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, i)
}

func (s *Squiggly_argsContext) E_SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SQ_CLOSE, 0)
}

func (s *Squiggly_argsContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *Squiggly_argsContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *Squiggly_argsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Squiggly_argsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Squiggly_argsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSquiggly_args(s)
	}
}

func (s *Squiggly_argsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSquiggly_args(s)
	}
}

func (p *SyslParser) Squiggly_args() (localctx ISquiggly_argsContext) {
	localctx = NewSquiggly_argsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, SyslParserRULE_squiggly_args)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1176)
		p.Match(SyslParserE_SQ_OPEN)
	}
	{
		p.SetState(1177)
		p.Match(SyslParserE_Name)
	}
	p.SetState(1182)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1178)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1179)
			p.Match(SyslParserE_Name)
		}

		p.SetState(1184)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1185)
		p.Match(SyslParserE_SQ_CLOSE)
	}

	return localctx
}

// IExpr_matchingContext is an interface to support dynamic dispatch.
type IExpr_matchingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_matchingContext differentiates from other interfaces.
	IsExpr_matchingContext()
}

type Expr_matchingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_matchingContext() *Expr_matchingContext {
	var p = new(Expr_matchingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_matching
	return p
}

func (*Expr_matchingContext) IsExpr_matchingContext() {}

func NewExpr_matchingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_matchingContext {
	var p = new(Expr_matchingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_matching

	return p
}

func (s *Expr_matchingContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_matchingContext) E_TILDE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TILDE, 0)
}

func (s *Expr_matchingContext) E_ANGLE_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_CLOSE, 0)
}

func (s *Expr_matchingContext) Matching_rhs() IMatching_rhsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMatching_rhsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMatching_rhsContext)
}

func (s *Expr_matchingContext) E_NOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NOT, 0)
}

func (s *Expr_matchingContext) Squiggly_args() ISquiggly_argsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISquiggly_argsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISquiggly_argsContext)
}

func (s *Expr_matchingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_matchingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_matchingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_matching(s)
	}
}

func (s *Expr_matchingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_matching(s)
	}
}

func (p *SyslParser) Expr_matching() (localctx IExpr_matchingContext) {
	localctx = NewExpr_matchingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, SyslParserRULE_expr_matching)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1188)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_NOT {
		{
			p.SetState(1187)
			p.Match(SyslParserE_NOT)
		}

	}
	{
		p.SetState(1190)
		p.Match(SyslParserE_TILDE)
	}
	p.SetState(1192)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_SQ_OPEN {
		{
			p.SetState(1191)
			p.Squiggly_args()
		}

	}
	{
		p.SetState(1194)
		p.Match(SyslParserE_ANGLE_CLOSE)
	}
	{
		p.SetState(1195)
		p.Matching_rhs()
	}

	return localctx
}

// IRelopContext is an interface to support dynamic dispatch.
type IRelopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelopContext differentiates from other interfaces.
	IsRelopContext()
}

type RelopContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelopContext() *RelopContext {
	var p = new(RelopContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_relop
	return p
}

func (*RelopContext) IsRelopContext() {}

func NewRelopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelopContext {
	var p = new(RelopContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_relop

	return p
}

func (s *RelopContext) GetParser() antlr.Parser { return s.parser }

func (s *RelopContext) Expr_table_of_op() IExpr_table_of_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_table_of_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_table_of_opContext)
}

func (s *RelopContext) Expr_rank_func() IExpr_rank_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_rank_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_rank_funcContext)
}

func (s *RelopContext) Expr_agg_func() IExpr_agg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_agg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_agg_funcContext)
}

func (s *RelopContext) Expr_single_arg_func() IExpr_single_arg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_single_arg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_single_arg_funcContext)
}

func (s *RelopContext) Expr_any_func() IExpr_any_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_any_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_any_funcContext)
}

func (s *RelopContext) Expr_count() IExpr_countContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_countContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_countContext)
}

func (s *RelopContext) Expr_single_or_null() IExpr_single_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_single_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_single_or_nullContext)
}

func (s *RelopContext) Expr_snapshot() IExpr_snapshotContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_snapshotContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_snapshotContext)
}

func (s *RelopContext) Expr_first_func() IExpr_first_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_first_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_first_funcContext)
}

func (s *RelopContext) Expr_navigate() IExpr_navigateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigateContext)
}

func (s *RelopContext) Expr_matching() IExpr_matchingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_matchingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_matchingContext)
}

func (s *RelopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRelop(s)
	}
}

func (s *RelopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRelop(s)
	}
}

func (p *SyslParser) Relop() (localctx IRelopContext) {
	localctx = NewRelopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, SyslParserRULE_relop)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1208)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_NULLSAFE_DOT, SyslParserE_DOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1197)
			p.Expr_table_of_op()
		}

	case SyslParserE_RELOPS_RANK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1198)
			p.Expr_rank_func()
		}

	case SyslParserE_RELOPS_AGG:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1199)
			p.Expr_agg_func()
		}

	case SyslParserE_RELOPS_WHERE, SyslParserE_RELOPS_FLATTEN:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1200)
			p.Expr_single_arg_func()
		}

	case SyslParserE_RELOPS_ANY:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1201)
			p.Expr_any_func()
		}

	case SyslParserE_RELOPS_COUNT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1202)
			p.Expr_count()
		}

	case SyslParserE_RELOPS_SINGLE_NULL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1203)
			p.Expr_single_or_null()
		}

	case SyslParserE_RELOPS_SNAPSHOT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1204)
			p.Expr_snapshot()
		}

	case SyslParserE_RELOPS_FIRST:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1205)
			p.Expr_first_func()
		}

	case SyslParserE_ARROW_RIGHT, SyslParserE_QN:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1206)
			p.Expr_navigate()
		}

	case SyslParserE_TILDE, SyslParserE_NOT:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1207)
			p.Expr_matching()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IList_itemContext is an interface to support dynamic dispatch.
type IList_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_itemContext differentiates from other interfaces.
	IsList_itemContext()
}

type List_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_itemContext() *List_itemContext {
	var p = new(List_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_list_item
	return p
}

func (*List_itemContext) IsList_itemContext() {}

func NewList_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_itemContext {
	var p = new(List_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_list_item

	return p
}

func (s *List_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *List_itemContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *List_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterList_item(s)
	}
}

func (s *List_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitList_item(s)
	}
}

func (p *SyslParser) List_item() (localctx IList_itemContext) {
	localctx = NewList_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, SyslParserRULE_list_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1210)
		p.Expr()
	}

	return localctx
}

// IExpr_listContext is an interface to support dynamic dispatch.
type IExpr_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_listContext differentiates from other interfaces.
	IsExpr_listContext()
}

type Expr_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_listContext() *Expr_listContext {
	var p = new(Expr_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_list
	return p
}

func (*Expr_listContext) IsExpr_listContext() {}

func NewExpr_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_listContext {
	var p = new(Expr_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_list

	return p
}

func (s *Expr_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_listContext) AllList_item() []IList_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IList_itemContext)(nil)).Elem())
	var tst = make([]IList_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IList_itemContext)
		}
	}

	return tst
}

func (s *Expr_listContext) List_item(i int) IList_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IList_itemContext)
}

func (s *Expr_listContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *Expr_listContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *Expr_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_list(s)
	}
}

func (s *Expr_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_list(s)
	}
}

func (p *SyslParser) Expr_list() (localctx IExpr_listContext) {
	localctx = NewExpr_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, SyslParserRULE_expr_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1212)
		p.List_item()
	}
	p.SetState(1217)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1213)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1214)
			p.List_item()
		}

		p.SetState(1219)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpr_setContext is an interface to support dynamic dispatch.
type IExpr_setContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_setContext differentiates from other interfaces.
	IsExpr_setContext()
}

type Expr_setContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_setContext() *Expr_setContext {
	var p = new(Expr_setContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_set
	return p
}

func (*Expr_setContext) IsExpr_setContext() {}

func NewExpr_setContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_setContext {
	var p = new(Expr_setContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_set

	return p
}

func (s *Expr_setContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_setContext) E_CURLY_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CURLY_OPEN, 0)
}

func (s *Expr_setContext) Expr_list() IExpr_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *Expr_setContext) E_CURLY_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CURLY_CLOSE, 0)
}

func (s *Expr_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_setContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_set(s)
	}
}

func (s *Expr_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_set(s)
	}
}

func (p *SyslParser) Expr_set() (localctx IExpr_setContext) {
	localctx = NewExpr_setContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, SyslParserRULE_expr_set)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1220)
		p.Match(SyslParserE_CURLY_OPEN)
	}
	{
		p.SetState(1221)
		p.Expr_list()
	}
	{
		p.SetState(1222)
		p.Match(SyslParserE_CURLY_CLOSE)
	}

	return localctx
}

// IEmpty_tupleContext is an interface to support dynamic dispatch.
type IEmpty_tupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmpty_tupleContext differentiates from other interfaces.
	IsEmpty_tupleContext()
}

type Empty_tupleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmpty_tupleContext() *Empty_tupleContext {
	var p = new(Empty_tupleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_empty_tuple
	return p
}

func (*Empty_tupleContext) IsEmpty_tupleContext() {}

func NewEmpty_tupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Empty_tupleContext {
	var p = new(Empty_tupleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_empty_tuple

	return p
}

func (s *Empty_tupleContext) GetParser() antlr.Parser { return s.parser }

func (s *Empty_tupleContext) E_EMPTY_TUPLE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_EMPTY_TUPLE, 0)
}

func (s *Empty_tupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Empty_tupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Empty_tupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterEmpty_tuple(s)
	}
}

func (s *Empty_tupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitEmpty_tuple(s)
	}
}

func (p *SyslParser) Empty_tuple() (localctx IEmpty_tupleContext) {
	localctx = NewEmpty_tupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, SyslParserRULE_empty_tuple)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1224)
		p.Match(SyslParserE_EMPTY_TUPLE)
	}

	return localctx
}

// IAtom_dot_relopContext is an interface to support dynamic dispatch.
type IAtom_dot_relopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtom_dot_relopContext differentiates from other interfaces.
	IsAtom_dot_relopContext()
}

type Atom_dot_relopContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtom_dot_relopContext() *Atom_dot_relopContext {
	var p = new(Atom_dot_relopContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atom_dot_relop
	return p
}

func (*Atom_dot_relopContext) IsAtom_dot_relopContext() {}

func NewAtom_dot_relopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Atom_dot_relopContext {
	var p = new(Atom_dot_relopContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atom_dot_relop

	return p
}

func (s *Atom_dot_relopContext) GetParser() antlr.Parser { return s.parser }

func (s *Atom_dot_relopContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *Atom_dot_relopContext) Expr_rank_func() IExpr_rank_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_rank_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_rank_funcContext)
}

func (s *Atom_dot_relopContext) Expr_agg_func() IExpr_agg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_agg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_agg_funcContext)
}

func (s *Atom_dot_relopContext) Expr_single_arg_func() IExpr_single_arg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_single_arg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_single_arg_funcContext)
}

func (s *Atom_dot_relopContext) Expr_any_func() IExpr_any_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_any_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_any_funcContext)
}

func (s *Atom_dot_relopContext) Expr_count() IExpr_countContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_countContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_countContext)
}

func (s *Atom_dot_relopContext) Expr_single_or_null() IExpr_single_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_single_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_single_or_nullContext)
}

func (s *Atom_dot_relopContext) Expr_snapshot() IExpr_snapshotContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_snapshotContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_snapshotContext)
}

func (s *Atom_dot_relopContext) Expr_first_func() IExpr_first_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_first_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_first_funcContext)
}

func (s *Atom_dot_relopContext) Expr_navigate() IExpr_navigateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigateContext)
}

func (s *Atom_dot_relopContext) Expr_matching() IExpr_matchingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_matchingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_matchingContext)
}

func (s *Atom_dot_relopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Atom_dot_relopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Atom_dot_relopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtom_dot_relop(s)
	}
}

func (s *Atom_dot_relopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtom_dot_relop(s)
	}
}

func (p *SyslParser) Atom_dot_relop() (localctx IAtom_dot_relopContext) {
	localctx = NewAtom_dot_relopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, SyslParserRULE_atom_dot_relop)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1226)
		p.Match(SyslParserE_DOT)
	}
	p.SetState(1237)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_RELOPS_RANK:
		{
			p.SetState(1227)
			p.Expr_rank_func()
		}

	case SyslParserE_RELOPS_AGG:
		{
			p.SetState(1228)
			p.Expr_agg_func()
		}

	case SyslParserE_RELOPS_WHERE, SyslParserE_RELOPS_FLATTEN:
		{
			p.SetState(1229)
			p.Expr_single_arg_func()
		}

	case SyslParserE_RELOPS_ANY:
		{
			p.SetState(1230)
			p.Expr_any_func()
		}

	case SyslParserE_RELOPS_COUNT:
		{
			p.SetState(1231)
			p.Expr_count()
		}

	case SyslParserE_RELOPS_SINGLE_NULL:
		{
			p.SetState(1232)
			p.Expr_single_or_null()
		}

	case SyslParserE_RELOPS_SNAPSHOT:
		{
			p.SetState(1233)
			p.Expr_snapshot()
		}

	case SyslParserE_RELOPS_FIRST:
		{
			p.SetState(1234)
			p.Expr_first_func()
		}

	case SyslParserE_ARROW_RIGHT, SyslParserE_QN:
		{
			p.SetState(1235)
			p.Expr_navigate()
		}

	case SyslParserE_TILDE, SyslParserE_NOT:
		{
			p.SetState(1236)
			p.Expr_matching()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAtomT_implied_dotContext is an interface to support dynamic dispatch.
type IAtomT_implied_dotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomT_implied_dotContext differentiates from other interfaces.
	IsAtomT_implied_dotContext()
}

type AtomT_implied_dotContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomT_implied_dotContext() *AtomT_implied_dotContext {
	var p = new(AtomT_implied_dotContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atomT_implied_dot
	return p
}

func (*AtomT_implied_dotContext) IsAtomT_implied_dotContext() {}

func NewAtomT_implied_dotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomT_implied_dotContext {
	var p = new(AtomT_implied_dotContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atomT_implied_dot

	return p
}

func (s *AtomT_implied_dotContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomT_implied_dotContext) Atom_dot_relop() IAtom_dot_relopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtom_dot_relopContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtom_dot_relopContext)
}

func (s *AtomT_implied_dotContext) Expr_navigate() IExpr_navigateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigateContext)
}

func (s *AtomT_implied_dotContext) Expr_matching() IExpr_matchingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_matchingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_matchingContext)
}

func (s *AtomT_implied_dotContext) Expr_table_of_op() IExpr_table_of_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_table_of_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_table_of_opContext)
}

func (s *AtomT_implied_dotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomT_implied_dotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomT_implied_dotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtomT_implied_dot(s)
	}
}

func (s *AtomT_implied_dotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtomT_implied_dot(s)
	}
}

func (p *SyslParser) AtomT_implied_dot() (localctx IAtomT_implied_dotContext) {
	localctx = NewAtomT_implied_dotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, SyslParserRULE_atomT_implied_dot)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1243)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1239)
			p.Atom_dot_relop()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1240)
			p.Expr_navigate()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1241)
			p.Expr_matching()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1242)
			p.Expr_table_of_op()
		}

	}

	return localctx
}

// IAtomT_nameContext is an interface to support dynamic dispatch.
type IAtomT_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomT_nameContext differentiates from other interfaces.
	IsAtomT_nameContext()
}

type AtomT_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomT_nameContext() *AtomT_nameContext {
	var p = new(AtomT_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atomT_name
	return p
}

func (*AtomT_nameContext) IsAtomT_nameContext() {}

func NewAtomT_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomT_nameContext {
	var p = new(AtomT_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atomT_name

	return p
}

func (s *AtomT_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomT_nameContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *AtomT_nameContext) E_WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserE_WHATEVER, 0)
}

func (s *AtomT_nameContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *AtomT_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomT_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomT_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtomT_name(s)
	}
}

func (s *AtomT_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtomT_name(s)
	}
}

func (p *SyslParser) AtomT_name() (localctx IAtomT_nameContext) {
	localctx = NewAtomT_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, SyslParserRULE_atomT_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1245)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserE_WHATEVER || _la == SyslParserE_Name || _la == SyslParserE_DOT) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IAtomT_parenContext is an interface to support dynamic dispatch.
type IAtomT_parenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomT_parenContext differentiates from other interfaces.
	IsAtomT_parenContext()
}

type AtomT_parenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomT_parenContext() *AtomT_parenContext {
	var p = new(AtomT_parenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atomT_paren
	return p
}

func (*AtomT_parenContext) IsAtomT_parenContext() {}

func NewAtomT_parenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomT_parenContext {
	var p = new(AtomT_parenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atomT_paren

	return p
}

func (s *AtomT_parenContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomT_parenContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *AtomT_parenContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AtomT_parenContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *AtomT_parenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomT_parenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomT_parenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtomT_paren(s)
	}
}

func (s *AtomT_parenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtomT_paren(s)
	}
}

func (p *SyslParser) AtomT_paren() (localctx IAtomT_parenContext) {
	localctx = NewAtomT_parenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, SyslParserRULE_atomT_paren)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1247)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	{
		p.SetState(1248)
		p.Expr()
	}
	{
		p.SetState(1249)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IExpr_atom_listContext is an interface to support dynamic dispatch.
type IExpr_atom_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_atom_listContext differentiates from other interfaces.
	IsExpr_atom_listContext()
}

type Expr_atom_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_atom_listContext() *Expr_atom_listContext {
	var p = new(Expr_atom_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_atom_list
	return p
}

func (*Expr_atom_listContext) IsExpr_atom_listContext() {}

func NewExpr_atom_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_atom_listContext {
	var p = new(Expr_atom_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_atom_list

	return p
}

func (s *Expr_atom_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_atom_listContext) E_SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SQ_OPEN, 0)
}

func (s *Expr_atom_listContext) Expr_list() IExpr_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *Expr_atom_listContext) E_SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SQ_CLOSE, 0)
}

func (s *Expr_atom_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_atom_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_atom_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_atom_list(s)
	}
}

func (s *Expr_atom_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_atom_list(s)
	}
}

func (p *SyslParser) Expr_atom_list() (localctx IExpr_atom_listContext) {
	localctx = NewExpr_atom_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, SyslParserRULE_expr_atom_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1251)
		p.Match(SyslParserE_SQ_OPEN)
	}
	{
		p.SetState(1252)
		p.Expr_list()
	}
	{
		p.SetState(1253)
		p.Match(SyslParserE_SQ_CLOSE)
	}

	return localctx
}

// IAtomTContext is an interface to support dynamic dispatch.
type IAtomTContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomTContext differentiates from other interfaces.
	IsAtomTContext()
}

type AtomTContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomTContext() *AtomTContext {
	var p = new(AtomTContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atomT
	return p
}

func (*AtomTContext) IsAtomTContext() {}

func NewAtomTContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomTContext {
	var p = new(AtomTContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atomT

	return p
}

func (s *AtomTContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomTContext) Expr_func() IExpr_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *AtomTContext) Expr_set() IExpr_setContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_setContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_setContext)
}

func (s *AtomTContext) Expr_atom_list() IExpr_atom_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_atom_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_atom_listContext)
}

func (s *AtomTContext) Empty_tuple() IEmpty_tupleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmpty_tupleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmpty_tupleContext)
}

func (s *AtomTContext) AtomT_paren() IAtomT_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomT_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomT_parenContext)
}

func (s *AtomTContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AtomTContext) AtomT_implied_dot() IAtomT_implied_dotContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomT_implied_dotContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomT_implied_dotContext)
}

func (s *AtomTContext) AtomT_name() IAtomT_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomT_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomT_nameContext)
}

func (s *AtomTContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomTContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomTContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtomT(s)
	}
}

func (s *AtomTContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtomT(s)
	}
}

func (p *SyslParser) AtomT() (localctx IAtomTContext) {
	localctx = NewAtomTContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, SyslParserRULE_atomT)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1263)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1255)
			p.Expr_func()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1256)
			p.Expr_set()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1257)
			p.Expr_atom_list()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1258)
			p.Empty_tuple()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1259)
			p.AtomT_paren()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1260)
			p.Literal()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1261)
			p.AtomT_implied_dot()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1262)
			p.AtomT_name()
		}

	}

	return localctx
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atom
	return p
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) AtomT() IAtomTContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomTContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomTContext)
}

func (s *AtomContext) AllRelop() []IRelopContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelopContext)(nil)).Elem())
	var tst = make([]IRelopContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelopContext)
		}
	}

	return tst
}

func (s *AtomContext) Relop(i int) IRelopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelopContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelopContext)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtom(s)
	}
}

func (p *SyslParser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, SyslParserRULE_atom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1265)
		p.AtomT()
	}
	p.SetState(1269)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1266)
				p.Relop()
			}

		}
		p.SetState(1271)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext())
	}

	return localctx
}

// IPowerTContext is an interface to support dynamic dispatch.
type IPowerTContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPowerTContext differentiates from other interfaces.
	IsPowerTContext()
}

type PowerTContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowerTContext() *PowerTContext {
	var p = new(PowerTContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_powerT
	return p
}

func (*PowerTContext) IsPowerTContext() {}

func NewPowerTContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowerTContext {
	var p = new(PowerTContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_powerT

	return p
}

func (s *PowerTContext) GetParser() antlr.Parser { return s.parser }

func (s *PowerTContext) E_POW() antlr.TerminalNode {
	return s.GetToken(SyslParserE_POW, 0)
}

func (s *PowerTContext) UnaryTerm() IUnaryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryTermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryTermContext)
}

func (s *PowerTContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerTContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowerTContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterPowerT(s)
	}
}

func (s *PowerTContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitPowerT(s)
	}
}

func (p *SyslParser) PowerT() (localctx IPowerTContext) {
	localctx = NewPowerTContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, SyslParserRULE_powerT)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1272)
		p.Match(SyslParserE_POW)
	}
	{
		p.SetState(1273)
		p.UnaryTerm()
	}

	return localctx
}

// IPowerContext is an interface to support dynamic dispatch.
type IPowerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPowerContext differentiates from other interfaces.
	IsPowerContext()
}

type PowerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowerContext() *PowerContext {
	var p = new(PowerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_power
	return p
}

func (*PowerContext) IsPowerContext() {}

func NewPowerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowerContext {
	var p = new(PowerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_power

	return p
}

func (s *PowerContext) GetParser() antlr.Parser { return s.parser }

func (s *PowerContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *PowerContext) PowerT() IPowerTContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPowerTContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPowerTContext)
}

func (s *PowerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterPower(s)
	}
}

func (s *PowerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitPower(s)
	}
}

func (p *SyslParser) Power() (localctx IPowerContext) {
	localctx = NewPowerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, SyslParserRULE_power)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1275)
		p.Atom()
	}
	p.SetState(1277)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1276)
			p.PowerT()
		}

	}

	return localctx
}

// IUnaryTermContext is an interface to support dynamic dispatch.
type IUnaryTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnaryTermContext differentiates from other interfaces.
	IsUnaryTermContext()
}

type UnaryTermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryTermContext() *UnaryTermContext {
	var p = new(UnaryTermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_unaryTerm
	return p
}

func (*UnaryTermContext) IsUnaryTermContext() {}

func NewUnaryTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryTermContext {
	var p = new(UnaryTermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_unaryTerm

	return p
}

func (s *UnaryTermContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryTermContext) Power() IPowerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPowerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPowerContext)
}

func (s *UnaryTermContext) E_PLUS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_PLUS, 0)
}

func (s *UnaryTermContext) E_MINUS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_MINUS, 0)
}

func (s *UnaryTermContext) E_NOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NOT, 0)
}

func (s *UnaryTermContext) E_TILDE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TILDE, 0)
}

func (s *UnaryTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterUnaryTerm(s)
	}
}

func (s *UnaryTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitUnaryTerm(s)
	}
}

func (p *SyslParser) UnaryTerm() (localctx IUnaryTermContext) {
	localctx = NewUnaryTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, SyslParserRULE_unaryTerm)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1280)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext()) == 1 {
		p.SetState(1279)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-92)&-(0x1f+1)) == 0 && ((1<<uint((_la-92)))&((1<<(SyslParserE_PLUS-92))|(1<<(SyslParserE_MINUS-92))|(1<<(SyslParserE_TILDE-92))|(1<<(SyslParserE_NOT-92)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	{
		p.SetState(1282)
		p.Power()
	}

	return localctx
}

// ITermTContext is an interface to support dynamic dispatch.
type ITermTContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTermTContext differentiates from other interfaces.
	IsTermTContext()
}

type TermTContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermTContext() *TermTContext {
	var p = new(TermTContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_termT
	return p
}

func (*TermTContext) IsTermTContext() {}

func NewTermTContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermTContext {
	var p = new(TermTContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_termT

	return p
}

func (s *TermTContext) GetParser() antlr.Parser { return s.parser }

func (s *TermTContext) UnaryTerm() IUnaryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryTermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryTermContext)
}

func (s *TermTContext) E_STAR() antlr.TerminalNode {
	return s.GetToken(SyslParserE_STAR, 0)
}

func (s *TermTContext) E_DIVIDE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DIVIDE, 0)
}

func (s *TermTContext) E_MOD() antlr.TerminalNode {
	return s.GetToken(SyslParserE_MOD, 0)
}

func (s *TermTContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermTContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermTContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTermT(s)
	}
}

func (s *TermTContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTermT(s)
	}
}

func (p *SyslParser) TermT() (localctx ITermTContext) {
	localctx = NewTermTContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, SyslParserRULE_termT)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1284)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-93)&-(0x1f+1)) == 0 && ((1<<uint((_la-93)))&((1<<(SyslParserE_DIVIDE-93))|(1<<(SyslParserE_MOD-93))|(1<<(SyslParserE_STAR-93)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(1285)
		p.UnaryTerm()
	}

	return localctx
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_term
	return p
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) UnaryTerm() IUnaryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryTermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryTermContext)
}

func (s *TermContext) AllTermT() []ITermTContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermTContext)(nil)).Elem())
	var tst = make([]ITermTContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermTContext)
		}
	}

	return tst
}

func (s *TermContext) TermT(i int) ITermTContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermTContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermTContext)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTerm(s)
	}
}

func (p *SyslParser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, SyslParserRULE_term)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1287)
		p.UnaryTerm()
	}
	p.SetState(1291)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 133, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1288)
				p.TermT()
			}

		}
		p.SetState(1293)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 133, p.GetParserRuleContext())
	}

	return localctx
}

// IBinexprTContext is an interface to support dynamic dispatch.
type IBinexprTContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinexprTContext differentiates from other interfaces.
	IsBinexprTContext()
}

type BinexprTContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinexprTContext() *BinexprTContext {
	var p = new(BinexprTContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_binexprT
	return p
}

func (*BinexprTContext) IsBinexprTContext() {}

func NewBinexprTContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinexprTContext {
	var p = new(BinexprTContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_binexprT

	return p
}

func (s *BinexprTContext) GetParser() antlr.Parser { return s.parser }

func (s *BinexprTContext) Term() ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *BinexprTContext) E_PLUS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_PLUS, 0)
}

func (s *BinexprTContext) E_MINUS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_MINUS, 0)
}

func (s *BinexprTContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinexprTContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinexprTContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterBinexprT(s)
	}
}

func (s *BinexprTContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitBinexprT(s)
	}
}

func (p *SyslParser) BinexprT() (localctx IBinexprTContext) {
	localctx = NewBinexprTContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, SyslParserRULE_binexprT)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1294)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserE_PLUS || _la == SyslParserE_MINUS) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(1295)
		p.Term()
	}

	return localctx
}

// IBinexprContext is an interface to support dynamic dispatch.
type IBinexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinexprContext differentiates from other interfaces.
	IsBinexprContext()
}

type BinexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinexprContext() *BinexprContext {
	var p = new(BinexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_binexpr
	return p
}

func (*BinexprContext) IsBinexprContext() {}

func NewBinexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinexprContext {
	var p = new(BinexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_binexpr

	return p
}

func (s *BinexprContext) GetParser() antlr.Parser { return s.parser }

func (s *BinexprContext) Term() ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *BinexprContext) AllBinexprT() []IBinexprTContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBinexprTContext)(nil)).Elem())
	var tst = make([]IBinexprTContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBinexprTContext)
		}
	}

	return tst
}

func (s *BinexprContext) BinexprT(i int) IBinexprTContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinexprTContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBinexprTContext)
}

func (s *BinexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterBinexpr(s)
	}
}

func (s *BinexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitBinexpr(s)
	}
}

func (p *SyslParser) Binexpr() (localctx IBinexprContext) {
	localctx = NewBinexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, SyslParserRULE_binexpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1297)
		p.Term()
	}
	p.SetState(1301)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1298)
				p.BinexprT()
			}

		}
		p.SetState(1303)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext())
	}

	return localctx
}

// IE_compare_opsContext is an interface to support dynamic dispatch.
type IE_compare_opsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsE_compare_opsContext differentiates from other interfaces.
	IsE_compare_opsContext()
}

type E_compare_opsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyE_compare_opsContext() *E_compare_opsContext {
	var p = new(E_compare_opsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_e_compare_ops
	return p
}

func (*E_compare_opsContext) IsE_compare_opsContext() {}

func NewE_compare_opsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *E_compare_opsContext {
	var p = new(E_compare_opsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_e_compare_ops

	return p
}

func (s *E_compare_opsContext) GetParser() antlr.Parser { return s.parser }

func (s *E_compare_opsContext) E_REL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_REL, 0)
}

func (s *E_compare_opsContext) E_ANGLE_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_OPEN, 0)
}

func (s *E_compare_opsContext) E_ANGLE_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_CLOSE, 0)
}

func (s *E_compare_opsContext) E_DOUBLE_EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOUBLE_EQ, 0)
}

func (s *E_compare_opsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *E_compare_opsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *E_compare_opsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterE_compare_ops(s)
	}
}

func (s *E_compare_opsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitE_compare_ops(s)
	}
}

func (p *SyslParser) E_compare_ops() (localctx IE_compare_opsContext) {
	localctx = NewE_compare_opsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, SyslParserRULE_e_compare_ops)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1304)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-74)&-(0x1f+1)) == 0 && ((1<<uint((_la-74)))&((1<<(SyslParserE_DOUBLE_EQ-74))|(1<<(SyslParserE_REL-74))|(1<<(SyslParserE_ANGLE_OPEN-74))|(1<<(SyslParserE_ANGLE_CLOSE-74)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IExpr_relContext is an interface to support dynamic dispatch.
type IExpr_relContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_relContext differentiates from other interfaces.
	IsExpr_relContext()
}

type Expr_relContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_relContext() *Expr_relContext {
	var p = new(Expr_relContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_rel
	return p
}

func (*Expr_relContext) IsExpr_relContext() {}

func NewExpr_relContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_relContext {
	var p = new(Expr_relContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_rel

	return p
}

func (s *Expr_relContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_relContext) AllBinexpr() []IBinexprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBinexprContext)(nil)).Elem())
	var tst = make([]IBinexprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBinexprContext)
		}
	}

	return tst
}

func (s *Expr_relContext) Binexpr(i int) IBinexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinexprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBinexprContext)
}

func (s *Expr_relContext) AllE_compare_ops() []IE_compare_opsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IE_compare_opsContext)(nil)).Elem())
	var tst = make([]IE_compare_opsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IE_compare_opsContext)
		}
	}

	return tst
}

func (s *Expr_relContext) E_compare_ops(i int) IE_compare_opsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_compare_opsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IE_compare_opsContext)
}

func (s *Expr_relContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_relContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_relContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_rel(s)
	}
}

func (s *Expr_relContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_rel(s)
	}
}

func (p *SyslParser) Expr_rel() (localctx IExpr_relContext) {
	localctx = NewExpr_relContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, SyslParserRULE_expr_rel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1306)
		p.Binexpr()
	}
	p.SetState(1312)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1307)
				p.E_compare_ops()
			}
			{
				p.SetState(1308)
				p.Binexpr()
			}

		}
		p.SetState(1314)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_bitandContext is an interface to support dynamic dispatch.
type IExpr_bitandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_bitandContext differentiates from other interfaces.
	IsExpr_bitandContext()
}

type Expr_bitandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_bitandContext() *Expr_bitandContext {
	var p = new(Expr_bitandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_bitand
	return p
}

func (*Expr_bitandContext) IsExpr_bitandContext() {}

func NewExpr_bitandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_bitandContext {
	var p = new(Expr_bitandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_bitand

	return p
}

func (s *Expr_bitandContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_bitandContext) AllExpr_rel() []IExpr_relContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_relContext)(nil)).Elem())
	var tst = make([]IExpr_relContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_relContext)
		}
	}

	return tst
}

func (s *Expr_bitandContext) Expr_rel(i int) IExpr_relContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_relContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_relContext)
}

func (s *Expr_bitandContext) AllE_AMP() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_AMP)
}

func (s *Expr_bitandContext) E_AMP(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_AMP, i)
}

func (s *Expr_bitandContext) AllE_AND() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_AND)
}

func (s *Expr_bitandContext) E_AND(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_AND, i)
}

func (s *Expr_bitandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_bitandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_bitandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_bitand(s)
	}
}

func (s *Expr_bitandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_bitand(s)
	}
}

func (p *SyslParser) Expr_bitand() (localctx IExpr_bitandContext) {
	localctx = NewExpr_bitandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, SyslParserRULE_expr_bitand)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1315)
		p.Expr_rel()
	}
	p.SetState(1320)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1316)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SyslParserE_AMP || _la == SyslParserE_AND) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
			{
				p.SetState(1317)
				p.Expr_rel()
			}

		}
		p.SetState(1322)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_bitxorContext is an interface to support dynamic dispatch.
type IExpr_bitxorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_bitxorContext differentiates from other interfaces.
	IsExpr_bitxorContext()
}

type Expr_bitxorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_bitxorContext() *Expr_bitxorContext {
	var p = new(Expr_bitxorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_bitxor
	return p
}

func (*Expr_bitxorContext) IsExpr_bitxorContext() {}

func NewExpr_bitxorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_bitxorContext {
	var p = new(Expr_bitxorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_bitxor

	return p
}

func (s *Expr_bitxorContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_bitxorContext) AllExpr_bitand() []IExpr_bitandContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_bitandContext)(nil)).Elem())
	var tst = make([]IExpr_bitandContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_bitandContext)
		}
	}

	return tst
}

func (s *Expr_bitxorContext) Expr_bitand(i int) IExpr_bitandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_bitandContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_bitandContext)
}

func (s *Expr_bitxorContext) AllE_XOR() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_XOR)
}

func (s *Expr_bitxorContext) E_XOR(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_XOR, i)
}

func (s *Expr_bitxorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_bitxorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_bitxorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_bitxor(s)
	}
}

func (s *Expr_bitxorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_bitxor(s)
	}
}

func (p *SyslParser) Expr_bitxor() (localctx IExpr_bitxorContext) {
	localctx = NewExpr_bitxorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, SyslParserRULE_expr_bitxor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1323)
		p.Expr_bitand()
	}
	p.SetState(1328)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1324)
				p.Match(SyslParserE_XOR)
			}
			{
				p.SetState(1325)
				p.Expr_bitand()
			}

		}
		p.SetState(1330)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_bitorContext is an interface to support dynamic dispatch.
type IExpr_bitorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_bitorContext differentiates from other interfaces.
	IsExpr_bitorContext()
}

type Expr_bitorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_bitorContext() *Expr_bitorContext {
	var p = new(Expr_bitorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_bitor
	return p
}

func (*Expr_bitorContext) IsExpr_bitorContext() {}

func NewExpr_bitorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_bitorContext {
	var p = new(Expr_bitorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_bitor

	return p
}

func (s *Expr_bitorContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_bitorContext) AllExpr_bitxor() []IExpr_bitxorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_bitxorContext)(nil)).Elem())
	var tst = make([]IExpr_bitxorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_bitxorContext)
		}
	}

	return tst
}

func (s *Expr_bitorContext) Expr_bitxor(i int) IExpr_bitxorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_bitxorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_bitxorContext)
}

func (s *Expr_bitorContext) AllE_BITOR() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_BITOR)
}

func (s *Expr_bitorContext) E_BITOR(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_BITOR, i)
}

func (s *Expr_bitorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_bitorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_bitorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_bitor(s)
	}
}

func (s *Expr_bitorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_bitor(s)
	}
}

func (p *SyslParser) Expr_bitor() (localctx IExpr_bitorContext) {
	localctx = NewExpr_bitorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, SyslParserRULE_expr_bitor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1331)
		p.Expr_bitxor()
	}
	p.SetState(1336)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1332)
				p.Match(SyslParserE_BITOR)
			}
			{
				p.SetState(1333)
				p.Expr_bitxor()
			}

		}
		p.SetState(1338)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_andContext is an interface to support dynamic dispatch.
type IExpr_andContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_andContext differentiates from other interfaces.
	IsExpr_andContext()
}

type Expr_andContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_andContext() *Expr_andContext {
	var p = new(Expr_andContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_and
	return p
}

func (*Expr_andContext) IsExpr_andContext() {}

func NewExpr_andContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_andContext {
	var p = new(Expr_andContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_and

	return p
}

func (s *Expr_andContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_andContext) AllExpr_bitor() []IExpr_bitorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_bitorContext)(nil)).Elem())
	var tst = make([]IExpr_bitorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_bitorContext)
		}
	}

	return tst
}

func (s *Expr_andContext) Expr_bitor(i int) IExpr_bitorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_bitorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_bitorContext)
}

func (s *Expr_andContext) AllE_DOUBLE_AMP() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_DOUBLE_AMP)
}

func (s *Expr_andContext) E_DOUBLE_AMP(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOUBLE_AMP, i)
}

func (s *Expr_andContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_andContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_andContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_and(s)
	}
}

func (s *Expr_andContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_and(s)
	}
}

func (p *SyslParser) Expr_and() (localctx IExpr_andContext) {
	localctx = NewExpr_andContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, SyslParserRULE_expr_and)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1339)
		p.Expr_bitor()
	}
	p.SetState(1344)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1340)
				p.Match(SyslParserE_DOUBLE_AMP)
			}
			{
				p.SetState(1341)
				p.Expr_bitor()
			}

		}
		p.SetState(1346)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_orContext is an interface to support dynamic dispatch.
type IExpr_orContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_orContext differentiates from other interfaces.
	IsExpr_orContext()
}

type Expr_orContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_orContext() *Expr_orContext {
	var p = new(Expr_orContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_or
	return p
}

func (*Expr_orContext) IsExpr_orContext() {}

func NewExpr_orContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_orContext {
	var p = new(Expr_orContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_or

	return p
}

func (s *Expr_orContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_orContext) AllExpr_and() []IExpr_andContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_andContext)(nil)).Elem())
	var tst = make([]IExpr_andContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_andContext)
		}
	}

	return tst
}

func (s *Expr_orContext) Expr_and(i int) IExpr_andContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_andContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_andContext)
}

func (s *Expr_orContext) AllE_LOGIC_OR() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_LOGIC_OR)
}

func (s *Expr_orContext) E_LOGIC_OR(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_LOGIC_OR, i)
}

func (s *Expr_orContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_orContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_orContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_or(s)
	}
}

func (s *Expr_orContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_or(s)
	}
}

func (p *SyslParser) Expr_or() (localctx IExpr_orContext) {
	localctx = NewExpr_orContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, SyslParserRULE_expr_or)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1347)
		p.Expr_and()
	}
	p.SetState(1352)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1348)
				p.Match(SyslParserE_LOGIC_OR)
			}
			{
				p.SetState(1349)
				p.Expr_and()
			}

		}
		p.SetState(1354)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_but_notContext is an interface to support dynamic dispatch.
type IExpr_but_notContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_but_notContext differentiates from other interfaces.
	IsExpr_but_notContext()
}

type Expr_but_notContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_but_notContext() *Expr_but_notContext {
	var p = new(Expr_but_notContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_but_not
	return p
}

func (*Expr_but_notContext) IsExpr_but_notContext() {}

func NewExpr_but_notContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_but_notContext {
	var p = new(Expr_but_notContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_but_not

	return p
}

func (s *Expr_but_notContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_but_notContext) AllExpr_or() []IExpr_orContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_orContext)(nil)).Elem())
	var tst = make([]IExpr_orContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_orContext)
		}
	}

	return tst
}

func (s *Expr_but_notContext) Expr_or(i int) IExpr_orContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_orContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_orContext)
}

func (s *Expr_but_notContext) AllE_BUTNOT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_BUTNOT)
}

func (s *Expr_but_notContext) E_BUTNOT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_BUTNOT, i)
}

func (s *Expr_but_notContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_but_notContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_but_notContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_but_not(s)
	}
}

func (s *Expr_but_notContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_but_not(s)
	}
}

func (p *SyslParser) Expr_but_not() (localctx IExpr_but_notContext) {
	localctx = NewExpr_but_notContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, SyslParserRULE_expr_but_not)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1355)
		p.Expr_or()
	}
	p.SetState(1360)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1356)
				p.Match(SyslParserE_BUTNOT)
			}
			{
				p.SetState(1357)
				p.Expr_or()
			}

		}
		p.SetState(1362)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_coalesceContext is an interface to support dynamic dispatch.
type IExpr_coalesceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_coalesceContext differentiates from other interfaces.
	IsExpr_coalesceContext()
}

type Expr_coalesceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_coalesceContext() *Expr_coalesceContext {
	var p = new(Expr_coalesceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_coalesce
	return p
}

func (*Expr_coalesceContext) IsExpr_coalesceContext() {}

func NewExpr_coalesceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_coalesceContext {
	var p = new(Expr_coalesceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_coalesce

	return p
}

func (s *Expr_coalesceContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_coalesceContext) AllExpr_but_not() []IExpr_but_notContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_but_notContext)(nil)).Elem())
	var tst = make([]IExpr_but_notContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_but_notContext)
		}
	}

	return tst
}

func (s *Expr_coalesceContext) Expr_but_not(i int) IExpr_but_notContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_but_notContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_but_notContext)
}

func (s *Expr_coalesceContext) AllE_COALESCE() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COALESCE)
}

func (s *Expr_coalesceContext) E_COALESCE(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COALESCE, i)
}

func (s *Expr_coalesceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_coalesceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_coalesceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_coalesce(s)
	}
}

func (s *Expr_coalesceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_coalesce(s)
	}
}

func (p *SyslParser) Expr_coalesce() (localctx IExpr_coalesceContext) {
	localctx = NewExpr_coalesceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, SyslParserRULE_expr_coalesce)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1363)
		p.Expr_but_not()
	}
	p.SetState(1368)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1364)
				p.Match(SyslParserE_COALESCE)
			}
			{
				p.SetState(1365)
				p.Expr_but_not()
			}

		}
		p.SetState(1370)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext())
	}

	return localctx
}

// IIf_one_linerContext is an interface to support dynamic dispatch.
type IIf_one_linerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_one_linerContext differentiates from other interfaces.
	IsIf_one_linerContext()
}

type If_one_linerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_one_linerContext() *If_one_linerContext {
	var p = new(If_one_linerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_one_liner
	return p
}

func (*If_one_linerContext) IsIf_one_linerContext() {}

func NewIf_one_linerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_one_linerContext {
	var p = new(If_one_linerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_one_liner

	return p
}

func (s *If_one_linerContext) GetParser() antlr.Parser { return s.parser }

func (s *If_one_linerContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *If_one_linerContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *If_one_linerContext) E_THEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_THEN, 0)
}

func (s *If_one_linerContext) E_ELSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ELSE, 0)
}

func (s *If_one_linerContext) E_QN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_QN, 0)
}

func (s *If_one_linerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_one_linerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_one_linerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_one_liner(s)
	}
}

func (s *If_one_linerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_one_liner(s)
	}
}

func (p *SyslParser) If_one_liner() (localctx IIf_one_linerContext) {
	localctx = NewIf_one_linerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, SyslParserRULE_if_one_liner)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1371)
		p.Expr()
	}
	p.SetState(1373)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_QN {
		{
			p.SetState(1372)
			p.Match(SyslParserE_QN)
		}

	}
	{
		p.SetState(1375)
		p.Match(SyslParserE_THEN)
	}
	{
		p.SetState(1376)
		p.Expr()
	}
	{
		p.SetState(1377)
		p.Match(SyslParserE_ELSE)
	}
	{
		p.SetState(1378)
		p.Expr()
	}

	return localctx
}

// IElse_block_stmtContext is an interface to support dynamic dispatch.
type IElse_block_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsElse_block_stmtContext differentiates from other interfaces.
	IsElse_block_stmtContext()
}

type Else_block_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	nested bool
	_expr  IExprContext
}

func NewEmptyElse_block_stmtContext() *Else_block_stmtContext {
	var p = new(Else_block_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_else_block_stmt
	return p
}

func (*Else_block_stmtContext) IsElse_block_stmtContext() {}

func NewElse_block_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Else_block_stmtContext {
	var p = new(Else_block_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_else_block_stmt

	return p
}

func (s *Else_block_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Else_block_stmtContext) Get_expr() IExprContext { return s._expr }

func (s *Else_block_stmtContext) Set_expr(v IExprContext) { s._expr = v }

func (s *Else_block_stmtContext) GetNested() bool { return s.nested }

func (s *Else_block_stmtContext) SetNested(v bool) { s.nested = v }

func (s *Else_block_stmtContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Else_block_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Else_block_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Else_block_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterElse_block_stmt(s)
	}
}

func (s *Else_block_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitElse_block_stmt(s)
	}
}

func (p *SyslParser) Else_block_stmt() (localctx IElse_block_stmtContext) {
	localctx = NewElse_block_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, SyslParserRULE_else_block_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1380)

		var _x = p.Expr()

		localctx.(*Else_block_stmtContext)._expr = _x
	}
	localctx.(*Else_block_stmtContext).SetNested(localctx.(*Else_block_stmtContext).Get_expr().GetNested())

	return localctx
}

// IControl_itemContext is an interface to support dynamic dispatch.
type IControl_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsControl_itemContext differentiates from other interfaces.
	IsControl_itemContext()
}

type Control_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyControl_itemContext() *Control_itemContext {
	var p = new(Control_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_control_item
	return p
}

func (*Control_itemContext) IsControl_itemContext() {}

func NewControl_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Control_itemContext {
	var p = new(Control_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_control_item

	return p
}

func (s *Control_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Control_itemContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Control_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Control_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Control_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterControl_item(s)
	}
}

func (s *Control_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitControl_item(s)
	}
}

func (p *SyslParser) Control_item() (localctx IControl_itemContext) {
	localctx = NewControl_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, SyslParserRULE_control_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1383)
		p.Expr()
	}

	return localctx
}

// IIf_controlsContext is an interface to support dynamic dispatch.
type IIf_controlsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_controlsContext differentiates from other interfaces.
	IsIf_controlsContext()
}

type If_controlsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_controlsContext() *If_controlsContext {
	var p = new(If_controlsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_controls
	return p
}

func (*If_controlsContext) IsIf_controlsContext() {}

func NewIf_controlsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_controlsContext {
	var p = new(If_controlsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_controls

	return p
}

func (s *If_controlsContext) GetParser() antlr.Parser { return s.parser }

func (s *If_controlsContext) AllControl_item() []IControl_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IControl_itemContext)(nil)).Elem())
	var tst = make([]IControl_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IControl_itemContext)
		}
	}

	return tst
}

func (s *If_controlsContext) Control_item(i int) IControl_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IControl_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IControl_itemContext)
}

func (s *If_controlsContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *If_controlsContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *If_controlsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_controlsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_controlsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_controls(s)
	}
}

func (s *If_controlsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_controls(s)
	}
}

func (p *SyslParser) If_controls() (localctx IIf_controlsContext) {
	localctx = NewIf_controlsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, SyslParserRULE_if_controls)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1385)
		p.Control_item()
	}
	p.SetState(1390)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1386)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1387)
			p.Control_item()
		}

		p.SetState(1392)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICond_blockContext is an interface to support dynamic dispatch.
type ICond_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_else_block_stmt returns the _else_block_stmt rule contexts.
	Get_else_block_stmt() IElse_block_stmtContext

	// Set_else_block_stmt sets the _else_block_stmt rule contexts.
	Set_else_block_stmt(IElse_block_stmtContext)

	// IsCond_blockContext differentiates from other interfaces.
	IsCond_blockContext()
}

type Cond_blockContext struct {
	*antlr.BaseParserRuleContext
	parser           antlr.Parser
	_else_block_stmt IElse_block_stmtContext
}

func NewEmptyCond_blockContext() *Cond_blockContext {
	var p = new(Cond_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_cond_block
	return p
}

func (*Cond_blockContext) IsCond_blockContext() {}

func NewCond_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cond_blockContext {
	var p = new(Cond_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_cond_block

	return p
}

func (s *Cond_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Cond_blockContext) Get_else_block_stmt() IElse_block_stmtContext { return s._else_block_stmt }

func (s *Cond_blockContext) Set_else_block_stmt(v IElse_block_stmtContext) { s._else_block_stmt = v }

func (s *Cond_blockContext) If_controls() IIf_controlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_controlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_controlsContext)
}

func (s *Cond_blockContext) E_EQ_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_EQ_RIGHT, 0)
}

func (s *Cond_blockContext) Else_block_stmt() IElse_block_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElse_block_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElse_block_stmtContext)
}

func (s *Cond_blockContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *Cond_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cond_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cond_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCond_block(s)
	}
}

func (s *Cond_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCond_block(s)
	}
}

func (p *SyslParser) Cond_block() (localctx ICond_blockContext) {
	localctx = NewCond_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, SyslParserRULE_cond_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1393)
		p.If_controls()
	}
	{
		p.SetState(1394)
		p.Match(SyslParserE_EQ_RIGHT)
	}
	{
		p.SetState(1395)

		var _x = p.Else_block_stmt()

		localctx.(*Cond_blockContext)._else_block_stmt = _x
	}
	p.SetState(1398)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 145, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1396)

		if !(localctx.(*Cond_blockContext).Get_else_block_stmt().GetNested() == true) {
			panic(antlr.NewFailedPredicateException(p, "$else_block_stmt.nested == true", ""))
		}

	case 2:
		{
			p.SetState(1397)
			p.Match(SyslParserE_NL)
		}

	}

	return localctx
}

// IFinal_elseContext is an interface to support dynamic dispatch.
type IFinal_elseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// IsFinal_elseContext differentiates from other interfaces.
	IsFinal_elseContext()
}

type Final_elseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	_expr  IExprContext
}

func NewEmptyFinal_elseContext() *Final_elseContext {
	var p = new(Final_elseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_final_else
	return p
}

func (*Final_elseContext) IsFinal_elseContext() {}

func NewFinal_elseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Final_elseContext {
	var p = new(Final_elseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_final_else

	return p
}

func (s *Final_elseContext) GetParser() antlr.Parser { return s.parser }

func (s *Final_elseContext) Get_expr() IExprContext { return s._expr }

func (s *Final_elseContext) Set_expr(v IExprContext) { s._expr = v }

func (s *Final_elseContext) E_ELSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ELSE, 0)
}

func (s *Final_elseContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Final_elseContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *Final_elseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Final_elseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Final_elseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFinal_else(s)
	}
}

func (s *Final_elseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFinal_else(s)
	}
}

func (p *SyslParser) Final_else() (localctx IFinal_elseContext) {
	localctx = NewFinal_elseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, SyslParserRULE_final_else)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1400)
		p.Match(SyslParserE_ELSE)
	}
	{
		p.SetState(1401)

		var _x = p.Expr()

		localctx.(*Final_elseContext)._expr = _x
	}
	p.SetState(1404)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1402)

		if !(localctx.(*Final_elseContext).Get_expr().GetNested() == true) {
			panic(antlr.NewFailedPredicateException(p, "$expr.nested == true", ""))
		}

	case 2:
		{
			p.SetState(1403)
			p.Match(SyslParserE_NL)
		}

	}

	return localctx
}

// IIfvarContext is an interface to support dynamic dispatch.
type IIfvarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfvarContext differentiates from other interfaces.
	IsIfvarContext()
}

type IfvarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfvarContext() *IfvarContext {
	var p = new(IfvarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_ifvar
	return p
}

func (*IfvarContext) IsIfvarContext() {}

func NewIfvarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfvarContext {
	var p = new(IfvarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_ifvar

	return p
}

func (s *IfvarContext) GetParser() antlr.Parser { return s.parser }

func (s *IfvarContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *IfvarContext) E_DOUBLE_EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOUBLE_EQ, 0)
}

func (s *IfvarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfvarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfvarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIfvar(s)
	}
}

func (s *IfvarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIfvar(s)
	}
}

func (p *SyslParser) Ifvar() (localctx IIfvarContext) {
	localctx = NewIfvarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, SyslParserRULE_ifvar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1406)
		p.Expr()
	}
	{
		p.SetState(1407)
		p.Match(SyslParserE_DOUBLE_EQ)
	}

	return localctx
}

// IIf_multiple_linesContext is an interface to support dynamic dispatch.
type IIf_multiple_linesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_multiple_linesContext differentiates from other interfaces.
	IsIf_multiple_linesContext()
}

type If_multiple_linesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_multiple_linesContext() *If_multiple_linesContext {
	var p = new(If_multiple_linesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_multiple_lines
	return p
}

func (*If_multiple_linesContext) IsIf_multiple_linesContext() {}

func NewIf_multiple_linesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_multiple_linesContext {
	var p = new(If_multiple_linesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_multiple_lines

	return p
}

func (s *If_multiple_linesContext) GetParser() antlr.Parser { return s.parser }

func (s *If_multiple_linesContext) E_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserE_COLON, 0)
}

func (s *If_multiple_linesContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *If_multiple_linesContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *If_multiple_linesContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *If_multiple_linesContext) Ifvar() IIfvarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfvarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfvarContext)
}

func (s *If_multiple_linesContext) AllCond_block() []ICond_blockContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICond_blockContext)(nil)).Elem())
	var tst = make([]ICond_blockContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICond_blockContext)
		}
	}

	return tst
}

func (s *If_multiple_linesContext) Cond_block(i int) ICond_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICond_blockContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICond_blockContext)
}

func (s *If_multiple_linesContext) Final_else() IFinal_elseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinal_elseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinal_elseContext)
}

func (s *If_multiple_linesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_multiple_linesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_multiple_linesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_multiple_lines(s)
	}
}

func (s *If_multiple_linesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_multiple_lines(s)
	}
}

func (p *SyslParser) If_multiple_lines() (localctx IIf_multiple_linesContext) {
	localctx = NewIf_multiple_linesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, SyslParserRULE_if_multiple_lines)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1410)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserNativeDataTypes || (((_la-71)&-(0x1f+1)) == 0 && ((1<<uint((_la-71)))&((1<<(SyslParserE_WHATEVER-71))|(1<<(SyslParserE_ARROW_RIGHT-71))|(1<<(SyslParserE_SQ_OPEN-71))|(1<<(SyslParserE_EMPTY_TUPLE-71))|(1<<(SyslParserE_CURLY_OPEN-71))|(1<<(SyslParserE_NULLSAFE_DOT-71))|(1<<(SyslParserE_OPEN_PAREN-71))|(1<<(SyslParserE_PLUS-71))|(1<<(SyslParserE_MINUS-71))|(1<<(SyslParserE_QN-71))|(1<<(SyslParserE_TILDE-71))|(1<<(SyslParserE_NOT-71)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SyslParserE_IF-109))|(1<<(SyslParserE_TRUE-109))|(1<<(SyslParserE_FALSE-109))|(1<<(SyslParserE_NULL-109))|(1<<(SyslParserE_FUNC-109))|(1<<(SyslParserE_STRING-109))|(1<<(SyslParserE_DECIMAL-109))|(1<<(SyslParserE_DIGITS-109))|(1<<(SyslParserE_Name-109))|(1<<(SyslParserE_DOT-109)))) != 0) {
		{
			p.SetState(1409)
			p.Ifvar()
		}

	}
	{
		p.SetState(1412)
		p.Match(SyslParserE_COLON)
	}
	{
		p.SetState(1413)
		p.Match(SyslParserE_NL)
	}
	{
		p.SetState(1414)
		p.Match(SyslParserINDENT)
	}
	p.SetState(1416)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserNativeDataTypes || (((_la-71)&-(0x1f+1)) == 0 && ((1<<uint((_la-71)))&((1<<(SyslParserE_WHATEVER-71))|(1<<(SyslParserE_ARROW_RIGHT-71))|(1<<(SyslParserE_SQ_OPEN-71))|(1<<(SyslParserE_EMPTY_TUPLE-71))|(1<<(SyslParserE_CURLY_OPEN-71))|(1<<(SyslParserE_NULLSAFE_DOT-71))|(1<<(SyslParserE_OPEN_PAREN-71))|(1<<(SyslParserE_PLUS-71))|(1<<(SyslParserE_MINUS-71))|(1<<(SyslParserE_QN-71))|(1<<(SyslParserE_TILDE-71))|(1<<(SyslParserE_NOT-71)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SyslParserE_IF-109))|(1<<(SyslParserE_TRUE-109))|(1<<(SyslParserE_FALSE-109))|(1<<(SyslParserE_NULL-109))|(1<<(SyslParserE_FUNC-109))|(1<<(SyslParserE_STRING-109))|(1<<(SyslParserE_DECIMAL-109))|(1<<(SyslParserE_DIGITS-109))|(1<<(SyslParserE_Name-109))|(1<<(SyslParserE_DOT-109)))) != 0) {
		{
			p.SetState(1415)
			p.Cond_block()
		}

		p.SetState(1418)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1421)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_ELSE {
		{
			p.SetState(1420)
			p.Final_else()
		}

	}
	{
		p.SetState(1423)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IExpr_if_elseContext is an interface to support dynamic dispatch.
type IExpr_if_elseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_if_elseContext differentiates from other interfaces.
	IsExpr_if_elseContext()
}

type Expr_if_elseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	nested bool
}

func NewEmptyExpr_if_elseContext() *Expr_if_elseContext {
	var p = new(Expr_if_elseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_if_else
	return p
}

func (*Expr_if_elseContext) IsExpr_if_elseContext() {}

func NewExpr_if_elseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_if_elseContext {
	var p = new(Expr_if_elseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_if_else

	return p
}

func (s *Expr_if_elseContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_if_elseContext) GetNested() bool { return s.nested }

func (s *Expr_if_elseContext) SetNested(v bool) { s.nested = v }

func (s *Expr_if_elseContext) E_IF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_IF, 0)
}

func (s *Expr_if_elseContext) If_one_liner() IIf_one_linerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_one_linerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_one_linerContext)
}

func (s *Expr_if_elseContext) If_multiple_lines() IIf_multiple_linesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_multiple_linesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_multiple_linesContext)
}

func (s *Expr_if_elseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_if_elseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_if_elseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_if_else(s)
	}
}

func (s *Expr_if_elseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_if_else(s)
	}
}

func (p *SyslParser) Expr_if_else() (localctx IExpr_if_elseContext) {
	localctx = NewExpr_if_elseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, SyslParserRULE_expr_if_else)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1425)
		p.Match(SyslParserE_IF)
	}
	p.SetState(1430)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1426)
			p.If_one_liner()
		}

	case 2:
		{
			p.SetState(1427)
			p.If_multiple_lines()
		}
		localctx.(*Expr_if_elseContext).SetNested(true)

	}

	return localctx
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_if_else returns the _expr_if_else rule contexts.
	Get_expr_if_else() IExpr_if_elseContext

	// Set_expr_if_else sets the _expr_if_else rule contexts.
	Set_expr_if_else(IExpr_if_elseContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	*antlr.BaseParserRuleContext
	parser        antlr.Parser
	nested        bool
	_expr_if_else IExpr_if_elseContext
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr
	return p
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) Get_expr_if_else() IExpr_if_elseContext { return s._expr_if_else }

func (s *ExprContext) Set_expr_if_else(v IExpr_if_elseContext) { s._expr_if_else = v }

func (s *ExprContext) GetNested() bool { return s.nested }

func (s *ExprContext) SetNested(v bool) { s.nested = v }

func (s *ExprContext) Expr_if_else() IExpr_if_elseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_if_elseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_if_elseContext)
}

func (s *ExprContext) Expr_coalesce() IExpr_coalesceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_coalesceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_coalesceContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (p *SyslParser) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, SyslParserRULE_expr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1436)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_IF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1432)

			var _x = p.Expr_if_else()

			localctx.(*ExprContext)._expr_if_else = _x
		}
		localctx.(*ExprContext).SetNested(localctx.(*ExprContext).Get_expr_if_else().GetNested())

	case SyslParserNativeDataTypes, SyslParserE_WHATEVER, SyslParserE_ARROW_RIGHT, SyslParserE_SQ_OPEN, SyslParserE_EMPTY_TUPLE, SyslParserE_CURLY_OPEN, SyslParserE_NULLSAFE_DOT, SyslParserE_OPEN_PAREN, SyslParserE_PLUS, SyslParserE_MINUS, SyslParserE_QN, SyslParserE_TILDE, SyslParserE_NOT, SyslParserE_TRUE, SyslParserE_FALSE, SyslParserE_NULL, SyslParserE_FUNC, SyslParserE_STRING, SyslParserE_DECIMAL, SyslParserE_DIGITS, SyslParserE_Name, SyslParserE_DOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1435)
			p.Expr_coalesce()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExpr_assignContext is an interface to support dynamic dispatch.
type IExpr_assignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_assignContext differentiates from other interfaces.
	IsExpr_assignContext()
}

type Expr_assignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	nested bool
	_expr  IExprContext
}

func NewEmptyExpr_assignContext() *Expr_assignContext {
	var p = new(Expr_assignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_assign
	return p
}

func (*Expr_assignContext) IsExpr_assignContext() {}

func NewExpr_assignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_assignContext {
	var p = new(Expr_assignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_assign

	return p
}

func (s *Expr_assignContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_assignContext) Get_expr() IExprContext { return s._expr }

func (s *Expr_assignContext) Set_expr(v IExprContext) { s._expr = v }

func (s *Expr_assignContext) GetNested() bool { return s.nested }

func (s *Expr_assignContext) SetNested(v bool) { s.nested = v }

func (s *Expr_assignContext) E_EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserE_EQ, 0)
}

func (s *Expr_assignContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_assignContext) Transform() ITransformContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransformContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransformContext)
}

func (s *Expr_assignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_assignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_assignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_assign(s)
	}
}

func (s *Expr_assignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_assign(s)
	}
}

func (p *SyslParser) Expr_assign() (localctx IExpr_assignContext) {
	localctx = NewExpr_assignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, SyslParserRULE_expr_assign)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1438)
		p.Match(SyslParserE_EQ)
	}
	p.SetState(1445)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1439)

			var _x = p.Expr()

			localctx.(*Expr_assignContext)._expr = _x
		}
		localctx.(*Expr_assignContext).SetNested(localctx.(*Expr_assignContext).Get_expr().GetNested())

	case 2:
		{
			p.SetState(1442)
			p.Transform()
		}
		localctx.(*Expr_assignContext).SetNested(true)

	}

	return localctx
}

// IExpr_simple_assignContext is an interface to support dynamic dispatch.
type IExpr_simple_assignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_assign returns the _expr_assign rule contexts.
	Get_expr_assign() IExpr_assignContext

	// Set_expr_assign sets the _expr_assign rule contexts.
	Set_expr_assign(IExpr_assignContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_simple_assignContext differentiates from other interfaces.
	IsExpr_simple_assignContext()
}

type Expr_simple_assignContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	nested       bool
	_expr_assign IExpr_assignContext
}

func NewEmptyExpr_simple_assignContext() *Expr_simple_assignContext {
	var p = new(Expr_simple_assignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_simple_assign
	return p
}

func (*Expr_simple_assignContext) IsExpr_simple_assignContext() {}

func NewExpr_simple_assignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_simple_assignContext {
	var p = new(Expr_simple_assignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_simple_assign

	return p
}

func (s *Expr_simple_assignContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_simple_assignContext) Get_expr_assign() IExpr_assignContext { return s._expr_assign }

func (s *Expr_simple_assignContext) Set_expr_assign(v IExpr_assignContext) { s._expr_assign = v }

func (s *Expr_simple_assignContext) GetNested() bool { return s.nested }

func (s *Expr_simple_assignContext) SetNested(v bool) { s.nested = v }

func (s *Expr_simple_assignContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_simple_assignContext) Expr_assign() IExpr_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_assignContext)
}

func (s *Expr_simple_assignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_simple_assignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_simple_assignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_simple_assign(s)
	}
}

func (s *Expr_simple_assignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_simple_assign(s)
	}
}

func (p *SyslParser) Expr_simple_assign() (localctx IExpr_simple_assignContext) {
	localctx = NewExpr_simple_assignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, SyslParserRULE_expr_simple_assign)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1447)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1448)

		var _x = p.Expr_assign()

		localctx.(*Expr_simple_assignContext)._expr_assign = _x
	}
	localctx.(*Expr_simple_assignContext).SetNested(localctx.(*Expr_simple_assignContext).Get_expr_assign().GetNested())

	return localctx
}

// IExpr_let_statementContext is an interface to support dynamic dispatch.
type IExpr_let_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_assign returns the _expr_assign rule contexts.
	Get_expr_assign() IExpr_assignContext

	// Set_expr_assign sets the _expr_assign rule contexts.
	Set_expr_assign(IExpr_assignContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_let_statementContext differentiates from other interfaces.
	IsExpr_let_statementContext()
}

type Expr_let_statementContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	nested       bool
	_expr_assign IExpr_assignContext
}

func NewEmptyExpr_let_statementContext() *Expr_let_statementContext {
	var p = new(Expr_let_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_let_statement
	return p
}

func (*Expr_let_statementContext) IsExpr_let_statementContext() {}

func NewExpr_let_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_let_statementContext {
	var p = new(Expr_let_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_let_statement

	return p
}

func (s *Expr_let_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_let_statementContext) Get_expr_assign() IExpr_assignContext { return s._expr_assign }

func (s *Expr_let_statementContext) Set_expr_assign(v IExpr_assignContext) { s._expr_assign = v }

func (s *Expr_let_statementContext) GetNested() bool { return s.nested }

func (s *Expr_let_statementContext) SetNested(v bool) { s.nested = v }

func (s *Expr_let_statementContext) E_LET() antlr.TerminalNode {
	return s.GetToken(SyslParserE_LET, 0)
}

func (s *Expr_let_statementContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_let_statementContext) Expr_assign() IExpr_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_assignContext)
}

func (s *Expr_let_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_let_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_let_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_let_statement(s)
	}
}

func (s *Expr_let_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_let_statement(s)
	}
}

func (p *SyslParser) Expr_let_statement() (localctx IExpr_let_statementContext) {
	localctx = NewExpr_let_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, SyslParserRULE_expr_let_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1451)
		p.Match(SyslParserE_LET)
	}
	{
		p.SetState(1452)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1453)

		var _x = p.Expr_assign()

		localctx.(*Expr_let_statementContext)._expr_assign = _x
	}
	localctx.(*Expr_let_statementContext).SetNested(localctx.(*Expr_let_statementContext).Get_expr_assign().GetNested())

	return localctx
}

// IExpr_table_of_statementContext is an interface to support dynamic dispatch.
type IExpr_table_of_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_assign returns the _expr_assign rule contexts.
	Get_expr_assign() IExpr_assignContext

	// Set_expr_assign sets the _expr_assign rule contexts.
	Set_expr_assign(IExpr_assignContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_table_of_statementContext differentiates from other interfaces.
	IsExpr_table_of_statementContext()
}

type Expr_table_of_statementContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	nested       bool
	_expr_assign IExpr_assignContext
}

func NewEmptyExpr_table_of_statementContext() *Expr_table_of_statementContext {
	var p = new(Expr_table_of_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_table_of_statement
	return p
}

func (*Expr_table_of_statementContext) IsExpr_table_of_statementContext() {}

func NewExpr_table_of_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_table_of_statementContext {
	var p = new(Expr_table_of_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_table_of_statement

	return p
}

func (s *Expr_table_of_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_table_of_statementContext) Get_expr_assign() IExpr_assignContext { return s._expr_assign }

func (s *Expr_table_of_statementContext) Set_expr_assign(v IExpr_assignContext) { s._expr_assign = v }

func (s *Expr_table_of_statementContext) GetNested() bool { return s.nested }

func (s *Expr_table_of_statementContext) SetNested(v bool) { s.nested = v }

func (s *Expr_table_of_statementContext) E_TABLE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TABLE_OF, 0)
}

func (s *Expr_table_of_statementContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_table_of_statementContext) Expr_assign() IExpr_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_assignContext)
}

func (s *Expr_table_of_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_table_of_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_table_of_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_table_of_statement(s)
	}
}

func (s *Expr_table_of_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_table_of_statement(s)
	}
}

func (p *SyslParser) Expr_table_of_statement() (localctx IExpr_table_of_statementContext) {
	localctx = NewExpr_table_of_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, SyslParserRULE_expr_table_of_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1456)
		p.Match(SyslParserE_TABLE_OF)
	}
	{
		p.SetState(1457)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1458)

		var _x = p.Expr_assign()

		localctx.(*Expr_table_of_statementContext)._expr_assign = _x
	}
	localctx.(*Expr_table_of_statementContext).SetNested(localctx.(*Expr_table_of_statementContext).Get_expr_assign().GetNested())

	return localctx
}

// IExpr_dot_assignContext is an interface to support dynamic dispatch.
type IExpr_dot_assignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_dot_assignContext differentiates from other interfaces.
	IsExpr_dot_assignContext()
}

type Expr_dot_assignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_dot_assignContext() *Expr_dot_assignContext {
	var p = new(Expr_dot_assignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_dot_assign
	return p
}

func (*Expr_dot_assignContext) IsExpr_dot_assignContext() {}

func NewExpr_dot_assignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_dot_assignContext {
	var p = new(Expr_dot_assignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_dot_assign

	return p
}

func (s *Expr_dot_assignContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_dot_assignContext) E_DOT_NAME_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT_NAME_NL, 0)
}

func (s *Expr_dot_assignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_dot_assignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_dot_assignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_dot_assign(s)
	}
}

func (s *Expr_dot_assignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_dot_assign(s)
	}
}

func (p *SyslParser) Expr_dot_assign() (localctx IExpr_dot_assignContext) {
	localctx = NewExpr_dot_assignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, SyslParserRULE_expr_dot_assign)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1461)
		p.Match(SyslParserE_DOT_NAME_NL)
	}

	return localctx
}

// IExpr_statement_no_nlContext is an interface to support dynamic dispatch.
type IExpr_statement_no_nlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_statement_no_nlContext differentiates from other interfaces.
	IsExpr_statement_no_nlContext()
}

type Expr_statement_no_nlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_statement_no_nlContext() *Expr_statement_no_nlContext {
	var p = new(Expr_statement_no_nlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_statement_no_nl
	return p
}

func (*Expr_statement_no_nlContext) IsExpr_statement_no_nlContext() {}

func NewExpr_statement_no_nlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_statement_no_nlContext {
	var p = new(Expr_statement_no_nlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_statement_no_nl

	return p
}

func (s *Expr_statement_no_nlContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_statement_no_nlContext) Expr_dot_assign() IExpr_dot_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_dot_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_dot_assignContext)
}

func (s *Expr_statement_no_nlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_statement_no_nlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_statement_no_nlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_statement_no_nl(s)
	}
}

func (s *Expr_statement_no_nlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_statement_no_nl(s)
	}
}

func (p *SyslParser) Expr_statement_no_nl() (localctx IExpr_statement_no_nlContext) {
	localctx = NewExpr_statement_no_nlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, SyslParserRULE_expr_statement_no_nl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1463)
		p.Expr_dot_assign()
	}

	return localctx
}

// IExpr_statementContext is an interface to support dynamic dispatch.
type IExpr_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_let_statement returns the _expr_let_statement rule contexts.
	Get_expr_let_statement() IExpr_let_statementContext

	// Get_expr_table_of_statement returns the _expr_table_of_statement rule contexts.
	Get_expr_table_of_statement() IExpr_table_of_statementContext

	// Get_expr_simple_assign returns the _expr_simple_assign rule contexts.
	Get_expr_simple_assign() IExpr_simple_assignContext

	// Set_expr_let_statement sets the _expr_let_statement rule contexts.
	Set_expr_let_statement(IExpr_let_statementContext)

	// Set_expr_table_of_statement sets the _expr_table_of_statement rule contexts.
	Set_expr_table_of_statement(IExpr_table_of_statementContext)

	// Set_expr_simple_assign sets the _expr_simple_assign rule contexts.
	Set_expr_simple_assign(IExpr_simple_assignContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_statementContext differentiates from other interfaces.
	IsExpr_statementContext()
}

type Expr_statementContext struct {
	*antlr.BaseParserRuleContext
	parser                   antlr.Parser
	nested                   bool
	_expr_let_statement      IExpr_let_statementContext
	_expr_table_of_statement IExpr_table_of_statementContext
	_expr_simple_assign      IExpr_simple_assignContext
}

func NewEmptyExpr_statementContext() *Expr_statementContext {
	var p = new(Expr_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_statement
	return p
}

func (*Expr_statementContext) IsExpr_statementContext() {}

func NewExpr_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_statementContext {
	var p = new(Expr_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_statement

	return p
}

func (s *Expr_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_statementContext) Get_expr_let_statement() IExpr_let_statementContext {
	return s._expr_let_statement
}

func (s *Expr_statementContext) Get_expr_table_of_statement() IExpr_table_of_statementContext {
	return s._expr_table_of_statement
}

func (s *Expr_statementContext) Get_expr_simple_assign() IExpr_simple_assignContext {
	return s._expr_simple_assign
}

func (s *Expr_statementContext) Set_expr_let_statement(v IExpr_let_statementContext) {
	s._expr_let_statement = v
}

func (s *Expr_statementContext) Set_expr_table_of_statement(v IExpr_table_of_statementContext) {
	s._expr_table_of_statement = v
}

func (s *Expr_statementContext) Set_expr_simple_assign(v IExpr_simple_assignContext) {
	s._expr_simple_assign = v
}

func (s *Expr_statementContext) GetNested() bool { return s.nested }

func (s *Expr_statementContext) SetNested(v bool) { s.nested = v }

func (s *Expr_statementContext) Expr_let_statement() IExpr_let_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_let_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_let_statementContext)
}

func (s *Expr_statementContext) Expr_table_of_statement() IExpr_table_of_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_table_of_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_table_of_statementContext)
}

func (s *Expr_statementContext) Expr_simple_assign() IExpr_simple_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_simple_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_simple_assignContext)
}

func (s *Expr_statementContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *Expr_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_statement(s)
	}
}

func (s *Expr_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_statement(s)
	}
}

func (p *SyslParser) Expr_statement() (localctx IExpr_statementContext) {
	localctx = NewExpr_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, SyslParserRULE_expr_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1474)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_LET:
		{
			p.SetState(1465)

			var _x = p.Expr_let_statement()

			localctx.(*Expr_statementContext)._expr_let_statement = _x
		}
		localctx.(*Expr_statementContext).SetNested(localctx.(*Expr_statementContext).Get_expr_let_statement().GetNested())

	case SyslParserE_TABLE_OF:
		{
			p.SetState(1468)

			var _x = p.Expr_table_of_statement()

			localctx.(*Expr_statementContext)._expr_table_of_statement = _x
		}
		localctx.(*Expr_statementContext).SetNested(localctx.(*Expr_statementContext).Get_expr_table_of_statement().GetNested())

	case SyslParserE_Name:
		{
			p.SetState(1471)

			var _x = p.Expr_simple_assign()

			localctx.(*Expr_statementContext)._expr_simple_assign = _x
		}
		localctx.(*Expr_statementContext).SetNested(localctx.(*Expr_statementContext).Get_expr_simple_assign().GetNested())

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1478)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1476)

		if !(localctx.(*Expr_statementContext).nested == true) {
			panic(antlr.NewFailedPredicateException(p, "$nested == true", ""))
		}

	case 2:
		{
			p.SetState(1477)
			p.Match(SyslParserE_NL)
		}

	}

	return localctx
}

// IExpr_inject_stmtContext is an interface to support dynamic dispatch.
type IExpr_inject_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_inject_stmtContext differentiates from other interfaces.
	IsExpr_inject_stmtContext()
}

type Expr_inject_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_inject_stmtContext() *Expr_inject_stmtContext {
	var p = new(Expr_inject_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_inject_stmt
	return p
}

func (*Expr_inject_stmtContext) IsExpr_inject_stmtContext() {}

func NewExpr_inject_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_inject_stmtContext {
	var p = new(Expr_inject_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_inject_stmt

	return p
}

func (s *Expr_inject_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_inject_stmtContext) Expr_func() IExpr_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *Expr_inject_stmtContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *Expr_inject_stmtContext) E_STAR() antlr.TerminalNode {
	return s.GetToken(SyslParserE_STAR, 0)
}

func (s *Expr_inject_stmtContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *Expr_inject_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_inject_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_inject_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_inject_stmt(s)
	}
}

func (s *Expr_inject_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_inject_stmt(s)
	}
}

func (p *SyslParser) Expr_inject_stmt() (localctx IExpr_inject_stmtContext) {
	localctx = NewExpr_inject_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, SyslParserRULE_expr_inject_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1480)
		p.Expr_func()
	}
	{
		p.SetState(1481)
		p.Match(SyslParserE_DOT)
	}
	{
		p.SetState(1482)
		p.Match(SyslParserE_STAR)
	}
	{
		p.SetState(1483)
		p.Match(SyslParserE_NL)
	}

	return localctx
}

// IExpr_stmtContext is an interface to support dynamic dispatch.
type IExpr_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_stmtContext differentiates from other interfaces.
	IsExpr_stmtContext()
}

type Expr_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_stmtContext() *Expr_stmtContext {
	var p = new(Expr_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_stmt
	return p
}

func (*Expr_stmtContext) IsExpr_stmtContext() {}

func NewExpr_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_stmtContext {
	var p = new(Expr_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_stmt

	return p
}

func (s *Expr_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_stmtContext) Expr_statement_no_nl() IExpr_statement_no_nlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_statement_no_nlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_statement_no_nlContext)
}

func (s *Expr_stmtContext) Expr_statement() IExpr_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_statementContext)
}

func (s *Expr_stmtContext) Expr_inject_stmt() IExpr_inject_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_inject_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_inject_stmtContext)
}

func (s *Expr_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_stmt(s)
	}
}

func (s *Expr_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_stmt(s)
	}
}

func (p *SyslParser) Expr_stmt() (localctx IExpr_stmtContext) {
	localctx = NewExpr_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, SyslParserRULE_expr_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1488)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 155, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1485)
			p.Expr_statement_no_nl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1486)
			p.Expr_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1487)
			p.Expr_inject_stmt()
		}

	}

	return localctx
}

// ITransform_return_typeContext is an interface to support dynamic dispatch.
type ITransform_return_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransform_return_typeContext differentiates from other interfaces.
	IsTransform_return_typeContext()
}

type Transform_return_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransform_return_typeContext() *Transform_return_typeContext {
	var p = new(Transform_return_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_transform_return_type
	return p
}

func (*Transform_return_typeContext) IsTransform_return_typeContext() {}

func NewTransform_return_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transform_return_typeContext {
	var p = new(Transform_return_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_transform_return_type

	return p
}

func (s *Transform_return_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Transform_return_typeContext) Set_of() ISet_ofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_ofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_ofContext)
}

func (s *Transform_return_typeContext) View_type_spec() IView_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_type_specContext)
}

func (s *Transform_return_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transform_return_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transform_return_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTransform_return_type(s)
	}
}

func (s *Transform_return_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTransform_return_type(s)
	}
}

func (p *SyslParser) Transform_return_type() (localctx ITransform_return_typeContext) {
	localctx = NewTransform_return_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, SyslParserRULE_transform_return_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1492)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 156, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1490)
			p.Set_of()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1491)
			p.View_type_spec()
		}

	}

	return localctx
}

// IView_return_typeContext is an interface to support dynamic dispatch.
type IView_return_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsView_return_typeContext differentiates from other interfaces.
	IsView_return_typeContext()
}

type View_return_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyView_return_typeContext() *View_return_typeContext {
	var p = new(View_return_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view_return_type
	return p
}

func (*View_return_typeContext) IsView_return_typeContext() {}

func NewView_return_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *View_return_typeContext {
	var p = new(View_return_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view_return_type

	return p
}

func (s *View_return_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *View_return_typeContext) View_type_spec() IView_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_type_specContext)
}

func (s *View_return_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *View_return_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *View_return_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView_return_type(s)
	}
}

func (s *View_return_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView_return_type(s)
	}
}

func (p *SyslParser) View_return_type() (localctx IView_return_typeContext) {
	localctx = NewView_return_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, SyslParserRULE_view_return_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1494)
		p.View_type_spec()
	}

	return localctx
}

// ITransform_scope_varContext is an interface to support dynamic dispatch.
type ITransform_scope_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransform_scope_varContext differentiates from other interfaces.
	IsTransform_scope_varContext()
}

type Transform_scope_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransform_scope_varContext() *Transform_scope_varContext {
	var p = new(Transform_scope_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_transform_scope_var
	return p
}

func (*Transform_scope_varContext) IsTransform_scope_varContext() {}

func NewTransform_scope_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transform_scope_varContext {
	var p = new(Transform_scope_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_transform_scope_var

	return p
}

func (s *Transform_scope_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Transform_scope_varContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Transform_scope_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transform_scope_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transform_scope_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTransform_scope_var(s)
	}
}

func (s *Transform_scope_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTransform_scope_var(s)
	}
}

func (p *SyslParser) Transform_scope_var() (localctx ITransform_scope_varContext) {
	localctx = NewTransform_scope_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, SyslParserRULE_transform_scope_var)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1496)
		p.Match(SyslParserE_Name)
	}

	return localctx
}

// ITransform_argContext is an interface to support dynamic dispatch.
type ITransform_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransform_argContext differentiates from other interfaces.
	IsTransform_argContext()
}

type Transform_argContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransform_argContext() *Transform_argContext {
	var p = new(Transform_argContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_transform_arg
	return p
}

func (*Transform_argContext) IsTransform_argContext() {}

func NewTransform_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transform_argContext {
	var p = new(Transform_argContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_transform_arg

	return p
}

func (s *Transform_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Transform_argContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Transform_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transform_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transform_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTransform_arg(s)
	}
}

func (s *Transform_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTransform_arg(s)
	}
}

func (p *SyslParser) Transform_arg() (localctx ITransform_argContext) {
	localctx = NewTransform_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, SyslParserRULE_transform_arg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1498)
		p.Expr()
	}

	return localctx
}

// ITransformContext is an interface to support dynamic dispatch.
type ITransformContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransformContext differentiates from other interfaces.
	IsTransformContext()
}

type TransformContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransformContext() *TransformContext {
	var p = new(TransformContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_transform
	return p
}

func (*TransformContext) IsTransformContext() {}

func NewTransformContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransformContext {
	var p = new(TransformContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_transform

	return p
}

func (s *TransformContext) GetParser() antlr.Parser { return s.parser }

func (s *TransformContext) E_ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ARROW_RIGHT, 0)
}

func (s *TransformContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *TransformContext) E_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserE_COLON, 0)
}

func (s *TransformContext) AllE_NL() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_NL)
}

func (s *TransformContext) E_NL(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, i)
}

func (s *TransformContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *TransformContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *TransformContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *TransformContext) Transform_arg() ITransform_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransform_argContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransform_argContext)
}

func (s *TransformContext) E_ANGLE_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_OPEN, 0)
}

func (s *TransformContext) Transform_return_type() ITransform_return_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransform_return_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransform_return_typeContext)
}

func (s *TransformContext) E_ANGLE_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_CLOSE, 0)
}

func (s *TransformContext) Transform_scope_var() ITransform_scope_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransform_scope_varContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransform_scope_varContext)
}

func (s *TransformContext) AllExpr_stmt() []IExpr_stmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_stmtContext)(nil)).Elem())
	var tst = make([]IExpr_stmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_stmtContext)
		}
	}

	return tst
}

func (s *TransformContext) Expr_stmt(i int) IExpr_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_stmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_stmtContext)
}

func (s *TransformContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransformContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransformContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTransform(s)
	}
}

func (s *TransformContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTransform(s)
	}
}

func (p *SyslParser) Transform() (localctx ITransformContext) {
	localctx = NewTransformContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, SyslParserRULE_transform)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1501)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 157, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1500)
			p.Transform_arg()
		}

	}
	{
		p.SetState(1503)
		p.Match(SyslParserE_ARROW_RIGHT)
	}
	p.SetState(1508)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_ANGLE_OPEN {
		{
			p.SetState(1504)
			p.Match(SyslParserE_ANGLE_OPEN)
		}
		{
			p.SetState(1505)
			p.Transform_return_type()
		}
		{
			p.SetState(1506)
			p.Match(SyslParserE_ANGLE_CLOSE)
		}

	}
	{
		p.SetState(1510)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1512)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_Name {
		{
			p.SetState(1511)
			p.Transform_scope_var()
		}

	}
	{
		p.SetState(1514)
		p.Match(SyslParserE_COLON)
	}
	{
		p.SetState(1515)
		p.Match(SyslParserE_NL)
	}
	{
		p.SetState(1516)
		p.Match(SyslParserINDENT)
	}
	p.SetState(1518)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserNativeDataTypes || _la == SyslParserE_TABLE_OF || _la == SyslParserE_LET || (((_la-129)&-(0x1f+1)) == 0 && ((1<<uint((_la-129)))&((1<<(SyslParserE_FUNC-129))|(1<<(SyslParserE_DOT_NAME_NL-129))|(1<<(SyslParserE_Name-129)))) != 0) {
		{
			p.SetState(1517)
			p.Expr_stmt()
		}

		p.SetState(1520)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1522)
		p.Match(SyslParserDEDENT)
	}
	{
		p.SetState(1523)
		p.Match(SyslParserE_CLOSE_PAREN)
	}
	{
		p.SetState(1524)
		p.Match(SyslParserE_NL)
	}

	return localctx
}

// IExpr_blockContext is an interface to support dynamic dispatch.
type IExpr_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_blockContext differentiates from other interfaces.
	IsExpr_blockContext()
}

type Expr_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_blockContext() *Expr_blockContext {
	var p = new(Expr_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_block
	return p
}

func (*Expr_blockContext) IsExpr_blockContext() {}

func NewExpr_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_blockContext {
	var p = new(Expr_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_block

	return p
}

func (s *Expr_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_blockContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Expr_blockContext) Transform() ITransformContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransformContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransformContext)
}

func (s *Expr_blockContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Expr_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_block(s)
	}
}

func (s *Expr_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_block(s)
	}
}

func (p *SyslParser) Expr_block() (localctx IExpr_blockContext) {
	localctx = NewExpr_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, SyslParserRULE_expr_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1526)
		p.Match(SyslParserINDENT)
	}
	{
		p.SetState(1527)
		p.Transform()
	}
	{
		p.SetState(1528)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IView_paramContext is an interface to support dynamic dispatch.
type IView_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsView_paramContext differentiates from other interfaces.
	IsView_paramContext()
}

type View_paramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyView_paramContext() *View_paramContext {
	var p = new(View_paramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view_param
	return p
}

func (*View_paramContext) IsView_paramContext() {}

func NewView_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *View_paramContext {
	var p = new(View_paramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view_param

	return p
}

func (s *View_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *View_paramContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *View_paramContext) LESS_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserLESS_COLON, 0)
}

func (s *View_paramContext) View_type_spec() IView_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_type_specContext)
}

func (s *View_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *View_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *View_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView_param(s)
	}
}

func (s *View_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView_param(s)
	}
}

func (p *SyslParser) View_param() (localctx IView_paramContext) {
	localctx = NewView_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, SyslParserRULE_view_param)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1530)
		p.Name_str()
	}
	{
		p.SetState(1531)
		p.Match(SyslParserLESS_COLON)
	}
	{
		p.SetState(1532)
		p.View_type_spec()
	}

	return localctx
}

// IView_paramsContext is an interface to support dynamic dispatch.
type IView_paramsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsView_paramsContext differentiates from other interfaces.
	IsView_paramsContext()
}

type View_paramsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyView_paramsContext() *View_paramsContext {
	var p = new(View_paramsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view_params
	return p
}

func (*View_paramsContext) IsView_paramsContext() {}

func NewView_paramsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *View_paramsContext {
	var p = new(View_paramsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view_params

	return p
}

func (s *View_paramsContext) GetParser() antlr.Parser { return s.parser }

func (s *View_paramsContext) AllView_param() []IView_paramContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IView_paramContext)(nil)).Elem())
	var tst = make([]IView_paramContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IView_paramContext)
		}
	}

	return tst
}

func (s *View_paramsContext) View_param(i int) IView_paramContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_paramContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IView_paramContext)
}

func (s *View_paramsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *View_paramsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *View_paramsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *View_paramsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *View_paramsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView_params(s)
	}
}

func (s *View_paramsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView_params(s)
	}
}

func (p *SyslParser) View_params() (localctx IView_paramsContext) {
	localctx = NewView_paramsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, SyslParserRULE_view_params)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1534)
		p.View_param()
	}
	p.SetState(1539)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(1535)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(1536)
			p.View_param()
		}

		p.SetState(1541)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAbstract_viewContext is an interface to support dynamic dispatch.
type IAbstract_viewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbstract_viewContext differentiates from other interfaces.
	IsAbstract_viewContext()
}

type Abstract_viewContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstract_viewContext() *Abstract_viewContext {
	var p = new(Abstract_viewContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_abstract_view
	return p
}

func (*Abstract_viewContext) IsAbstract_viewContext() {}

func NewAbstract_viewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Abstract_viewContext {
	var p = new(Abstract_viewContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_abstract_view

	return p
}

func (s *Abstract_viewContext) GetParser() antlr.Parser { return s.parser }

func (s *Abstract_viewContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(SyslParserABSTRACT, 0)
}

func (s *Abstract_viewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Abstract_viewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Abstract_viewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAbstract_view(s)
	}
}

func (s *Abstract_viewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAbstract_view(s)
	}
}

func (p *SyslParser) Abstract_view() (localctx IAbstract_viewContext) {
	localctx = NewAbstract_viewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, SyslParserRULE_abstract_view)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1542)
		p.Match(SyslParserABSTRACT)
	}

	return localctx
}

// IViewContext is an interface to support dynamic dispatch.
type IViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAbstractView returns the abstractView attribute.
	GetAbstractView() bool

	// SetAbstractView sets the abstractView attribute.
	SetAbstractView(bool)

	// IsViewContext differentiates from other interfaces.
	IsViewContext()
}

type ViewContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	abstractView bool
}

func NewEmptyViewContext() *ViewContext {
	var p = new(ViewContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view
	return p
}

func (*ViewContext) IsViewContext() {}

func NewViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewContext {
	var p = new(ViewContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view

	return p
}

func (s *ViewContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewContext) GetAbstractView() bool { return s.abstractView }

func (s *ViewContext) SetAbstractView(v bool) { s.abstractView = v }

func (s *ViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SyslParserVIEW, 0)
}

func (s *ViewContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *ViewContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *ViewContext) View_params() IView_paramsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_paramsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_paramsContext)
}

func (s *ViewContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *ViewContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *ViewContext) Expr_block() IExpr_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_blockContext)
}

func (s *ViewContext) Abstract_view() IAbstract_viewContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbstract_viewContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbstract_viewContext)
}

func (s *ViewContext) ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_RIGHT, 0)
}

func (s *ViewContext) View_return_type() IView_return_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_return_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_return_typeContext)
}

func (s *ViewContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *ViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView(s)
	}
}

func (s *ViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView(s)
	}
}

func (p *SyslParser) View() (localctx IViewContext) {
	localctx = NewViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, SyslParserRULE_view)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1544)
		p.Match(SyslParserVIEW)
	}
	{
		p.SetState(1545)
		p.Name_str()
	}
	{
		p.SetState(1546)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(1547)
		p.View_params()
	}
	{
		p.SetState(1548)
		p.Match(SyslParserCLOSE_PAREN)
	}
	p.SetState(1551)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserARROW_RIGHT {
		{
			p.SetState(1549)
			p.Match(SyslParserARROW_RIGHT)
		}
		{
			p.SetState(1550)
			p.View_return_type()
		}

	}
	p.SetState(1561)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserCOLON, SyslParserSQ_OPEN:
		p.SetState(1554)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserSQ_OPEN {
			{
				p.SetState(1553)
				p.Attribs_or_modifiers()
			}

		}
		{
			p.SetState(1556)
			p.Match(SyslParserCOLON)
		}
		{
			p.SetState(1557)
			p.Expr_block()
		}

	case SyslParserABSTRACT:
		{
			p.SetState(1558)
			p.Abstract_view()
		}
		localctx.(*ViewContext).SetAbstractView(true)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IApp_declContext is an interface to support dynamic dispatch.
type IApp_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_view returns the _view rule contexts.
	Get_view() IViewContext

	// Set_view sets the _view rule contexts.
	Set_view(IViewContext)

	// GetCheck returns the check attribute.
	GetCheck() bool

	// SetCheck sets the check attribute.
	SetCheck(bool)

	// IsApp_declContext differentiates from other interfaces.
	IsApp_declContext()
}

type App_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	check  bool
	_view  IViewContext
}

func NewEmptyApp_declContext() *App_declContext {
	var p = new(App_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_app_decl
	return p
}

func (*App_declContext) IsApp_declContext() {}

func NewApp_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *App_declContext {
	var p = new(App_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_app_decl

	return p
}

func (s *App_declContext) GetParser() antlr.Parser { return s.parser }

func (s *App_declContext) Get_view() IViewContext { return s._view }

func (s *App_declContext) Set_view(v IViewContext) { s._view = v }

func (s *App_declContext) GetCheck() bool { return s.check }

func (s *App_declContext) SetCheck(v bool) { s.check = v }

func (s *App_declContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *App_declContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *App_declContext) AllTable() []ITableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableContext)(nil)).Elem())
	var tst = make([]ITableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITableContext)
		}
	}

	return tst
}

func (s *App_declContext) Table(i int) ITableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *App_declContext) AllUnion() []IUnionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnionContext)(nil)).Elem())
	var tst = make([]IUnionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnionContext)
		}
	}

	return tst
}

func (s *App_declContext) Union(i int) IUnionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnionContext)
}

func (s *App_declContext) AllFacade() []IFacadeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFacadeContext)(nil)).Elem())
	var tst = make([]IFacadeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFacadeContext)
		}
	}

	return tst
}

func (s *App_declContext) Facade(i int) IFacadeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFacadeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFacadeContext)
}

func (s *App_declContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *App_declContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *App_declContext) AllRest_endpoint() []IRest_endpointContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRest_endpointContext)(nil)).Elem())
	var tst = make([]IRest_endpointContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRest_endpointContext)
		}
	}

	return tst
}

func (s *App_declContext) Rest_endpoint(i int) IRest_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRest_endpointContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRest_endpointContext)
}

func (s *App_declContext) AllSimple_endpoint() []ISimple_endpointContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_endpointContext)(nil)).Elem())
	var tst = make([]ISimple_endpointContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_endpointContext)
		}
	}

	return tst
}

func (s *App_declContext) Simple_endpoint(i int) ISimple_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_endpointContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_endpointContext)
}

func (s *App_declContext) AllCollector() []ICollectorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICollectorContext)(nil)).Elem())
	var tst = make([]ICollectorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICollectorContext)
		}
	}

	return tst
}

func (s *App_declContext) Collector(i int) ICollectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollectorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICollectorContext)
}

func (s *App_declContext) AllEvent() []IEventContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEventContext)(nil)).Elem())
	var tst = make([]IEventContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEventContext)
		}
	}

	return tst
}

func (s *App_declContext) Event(i int) IEventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEventContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEventContext)
}

func (s *App_declContext) AllSubscribe() []ISubscribeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubscribeContext)(nil)).Elem())
	var tst = make([]ISubscribeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubscribeContext)
		}
	}

	return tst
}

func (s *App_declContext) Subscribe(i int) ISubscribeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscribeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubscribeContext)
}

func (s *App_declContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *App_declContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *App_declContext) AllMixin() []IMixinContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMixinContext)(nil)).Elem())
	var tst = make([]IMixinContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMixinContext)
		}
	}

	return tst
}

func (s *App_declContext) Mixin(i int) IMixinContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMixinContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMixinContext)
}

func (s *App_declContext) AllView() []IViewContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IViewContext)(nil)).Elem())
	var tst = make([]IViewContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IViewContext)
		}
	}

	return tst
}

func (s *App_declContext) View(i int) IViewContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IViewContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IViewContext)
}

func (s *App_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *App_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *App_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterApp_decl(s)
	}
}

func (s *App_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitApp_decl(s)
	}
}

func (p *SyslParser) App_decl() (localctx IApp_declContext) {
	localctx = NewApp_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, SyslParserRULE_app_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1563)
		p.Match(SyslParserINDENT)
	}
	p.SetState(1578)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(1578)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 165, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1564)
					p.Table()
				}

			case 2:
				{
					p.SetState(1565)
					p.Union()
				}

			case 3:
				{
					p.SetState(1566)
					p.Facade()
				}

			case 4:
				{
					p.SetState(1567)
					p.Match(SyslParserSYSL_COMMENT)
				}

			case 5:
				{
					p.SetState(1568)
					p.Rest_endpoint()
				}

			case 6:
				{
					p.SetState(1569)
					p.Simple_endpoint()
				}

			case 7:
				{
					p.SetState(1570)
					p.Collector()
				}

			case 8:
				{
					p.SetState(1571)
					p.Event()
				}

			case 9:
				{
					p.SetState(1572)
					p.Subscribe()
				}

			case 10:
				{
					p.SetState(1573)
					p.Annotation()
				}

			case 11:
				{
					p.SetState(1574)
					p.Mixin()
				}

			case 12:
				{
					p.SetState(1575)

					var _x = p.View()

					localctx.(*App_declContext)._view = _x
				}
				localctx.(*App_declContext).check = localctx.(*App_declContext).Get_view().GetAbstractView()

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1580)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 166, p.GetParserRuleContext())
	}
	p.SetState(1584)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 167, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1582)

		if !(localctx.(*App_declContext).check) {
			panic(antlr.NewFailedPredicateException(p, "$check", ""))
		}

	case 2:
		{
			p.SetState(1583)
			p.Match(SyslParserDEDENT)
		}

	}

	return localctx
}

// IApplicationContext is an interface to support dynamic dispatch.
type IApplicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsApplicationContext differentiates from other interfaces.
	IsApplicationContext()
}

type ApplicationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyApplicationContext() *ApplicationContext {
	var p = new(ApplicationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_application
	return p
}

func (*ApplicationContext) IsApplicationContext() {}

func NewApplicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ApplicationContext {
	var p = new(ApplicationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_application

	return p
}

func (s *ApplicationContext) GetParser() antlr.Parser { return s.parser }

func (s *ApplicationContext) Name_with_attribs() IName_with_attribsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_with_attribsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_with_attribsContext)
}

func (s *ApplicationContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *ApplicationContext) App_decl() IApp_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_declContext)
}

func (s *ApplicationContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *ApplicationContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *ApplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ApplicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ApplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterApplication(s)
	}
}

func (s *ApplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitApplication(s)
	}
}

func (p *SyslParser) Application() (localctx IApplicationContext) {
	localctx = NewApplicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, SyslParserRULE_application)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1589)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserSYSL_COMMENT {
		{
			p.SetState(1586)
			p.Match(SyslParserSYSL_COMMENT)
		}

		p.SetState(1591)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1592)
		p.Name_with_attribs()
	}
	{
		p.SetState(1593)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(1594)
		p.App_decl()
	}

	return localctx
}

// IPathContext is an interface to support dynamic dispatch.
type IPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPathContext differentiates from other interfaces.
	IsPathContext()
}

type PathContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathContext() *PathContext {
	var p = new(PathContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_path
	return p
}

func (*PathContext) IsPathContext() {}

func NewPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathContext {
	var p = new(PathContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_path

	return p
}

func (s *PathContext) GetParser() antlr.Parser { return s.parser }

func (s *PathContext) AllName() []antlr.TerminalNode {
	return s.GetTokens(SyslParserName)
}

func (s *PathContext) Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserName, i)
}

func (s *PathContext) AllFORWARD_SLASH() []antlr.TerminalNode {
	return s.GetTokens(SyslParserFORWARD_SLASH)
}

func (s *PathContext) FORWARD_SLASH(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserFORWARD_SLASH, i)
}

func (s *PathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterPath(s)
	}
}

func (s *PathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitPath(s)
	}
}

func (p *SyslParser) Path() (localctx IPathContext) {
	localctx = NewPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, SyslParserRULE_path)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1597)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserFORWARD_SLASH {
		{
			p.SetState(1596)
			p.Match(SyslParserFORWARD_SLASH)
		}

	}
	{
		p.SetState(1599)
		p.Match(SyslParserName)
	}
	p.SetState(1604)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserFORWARD_SLASH {
		{
			p.SetState(1600)
			p.Match(SyslParserFORWARD_SLASH)
		}
		{
			p.SetState(1601)
			p.Match(SyslParserName)
		}

		p.SetState(1606)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IImport_stmtContext is an interface to support dynamic dispatch.
type IImport_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_stmtContext differentiates from other interfaces.
	IsImport_stmtContext()
}

type Import_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_stmtContext() *Import_stmtContext {
	var p = new(Import_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_import_stmt
	return p
}

func (*Import_stmtContext) IsImport_stmtContext() {}

func NewImport_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_stmtContext {
	var p = new(Import_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_import_stmt

	return p
}

func (s *Import_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_stmtContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(SyslParserIMPORT, 0)
}

func (s *Import_stmtContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *Import_stmtContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *Import_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterImport_stmt(s)
	}
}

func (s *Import_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitImport_stmt(s)
	}
}

func (p *SyslParser) Import_stmt() (localctx IImport_stmtContext) {
	localctx = NewImport_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, SyslParserRULE_import_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1607)
		p.Match(SyslParserIMPORT)
	}
	p.SetState(1611)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1608)
				p.Match(SyslParserSYSL_COMMENT)
			}

		}
		p.SetState(1613)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext())
	}

	return localctx
}

// IImports_declContext is an interface to support dynamic dispatch.
type IImports_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImports_declContext differentiates from other interfaces.
	IsImports_declContext()
}

type Imports_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImports_declContext() *Imports_declContext {
	var p = new(Imports_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_imports_decl
	return p
}

func (*Imports_declContext) IsImports_declContext() {}

func NewImports_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Imports_declContext {
	var p = new(Imports_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_imports_decl

	return p
}

func (s *Imports_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Imports_declContext) AllImport_stmt() []IImport_stmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImport_stmtContext)(nil)).Elem())
	var tst = make([]IImport_stmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImport_stmtContext)
		}
	}

	return tst
}

func (s *Imports_declContext) Import_stmt(i int) IImport_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_stmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImport_stmtContext)
}

func (s *Imports_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Imports_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Imports_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterImports_decl(s)
	}
}

func (s *Imports_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitImports_decl(s)
	}
}

func (p *SyslParser) Imports_decl() (localctx IImports_declContext) {
	localctx = NewImports_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, SyslParserRULE_imports_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1615)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserIMPORT {
		{
			p.SetState(1614)
			p.Import_stmt()
		}

		p.SetState(1617)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISysl_fileContext is an interface to support dynamic dispatch.
type ISysl_fileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSysl_fileContext differentiates from other interfaces.
	IsSysl_fileContext()
}

type Sysl_fileContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySysl_fileContext() *Sysl_fileContext {
	var p = new(Sysl_fileContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_sysl_file
	return p
}

func (*Sysl_fileContext) IsSysl_fileContext() {}

func NewSysl_fileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sysl_fileContext {
	var p = new(Sysl_fileContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_sysl_file

	return p
}

func (s *Sysl_fileContext) GetParser() antlr.Parser { return s.parser }

func (s *Sysl_fileContext) EOF() antlr.TerminalNode {
	return s.GetToken(SyslParserEOF, 0)
}

func (s *Sysl_fileContext) Imports_decl() IImports_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImports_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImports_declContext)
}

func (s *Sysl_fileContext) AllApplication() []IApplicationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IApplicationContext)(nil)).Elem())
	var tst = make([]IApplicationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IApplicationContext)
		}
	}

	return tst
}

func (s *Sysl_fileContext) Application(i int) IApplicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApplicationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IApplicationContext)
}

func (s *Sysl_fileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sysl_fileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sysl_fileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSysl_file(s)
	}
}

func (s *Sysl_fileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSysl_file(s)
	}
}

func (p *SyslParser) Sysl_file() (localctx ISysl_fileContext) {
	localctx = NewSysl_fileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, SyslParserRULE_sysl_file)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1620)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserIMPORT {
		{
			p.SetState(1619)
			p.Imports_decl()
		}

	}
	p.SetState(1623)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(SyslParserSYSL_COMMENT-57))|(1<<(SyslParserTEXT_LINE-57))|(1<<(SyslParserName-57)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(1622)
			p.Application()
		}

		p.SetState(1625)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1627)
		p.Match(SyslParserEOF)
	}

	return localctx
}

func (p *SyslParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 143:
		var t *Cond_blockContext = nil
		if localctx != nil {
			t = localctx.(*Cond_blockContext)
		}
		return p.Cond_block_Sempred(t, predIndex)

	case 144:
		var t *Final_elseContext = nil
		if localctx != nil {
			t = localctx.(*Final_elseContext)
		}
		return p.Final_else_Sempred(t, predIndex)

	case 155:
		var t *Expr_statementContext = nil
		if localctx != nil {
			t = localctx.(*Expr_statementContext)
		}
		return p.Expr_statement_Sempred(t, predIndex)

	case 168:
		var t *App_declContext = nil
		if localctx != nil {
			t = localctx.(*App_declContext)
		}
		return p.App_decl_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *SyslParser) Cond_block_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return localctx.(*Cond_blockContext).Get_else_block_stmt().GetNested() == true

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SyslParser) Final_else_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return localctx.(*Final_elseContext).Get_expr().GetNested() == true

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SyslParser) Expr_statement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return localctx.(*Expr_statementContext).nested == true

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SyslParser) App_decl_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return localctx.(*App_declContext).check

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
