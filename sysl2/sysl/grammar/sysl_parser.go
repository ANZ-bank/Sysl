// Generated from grammar/SyslParser.g4 by ANTLR 4.7.

package parser // SyslParser

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 150, 1732,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	4, 152, 9, 152, 4, 153, 9, 153, 4, 154, 9, 154, 4, 155, 9, 155, 4, 156,
	9, 156, 4, 157, 9, 157, 4, 158, 9, 158, 4, 159, 9, 159, 4, 160, 9, 160,
	4, 161, 9, 161, 4, 162, 9, 162, 4, 163, 9, 163, 4, 164, 9, 164, 4, 165,
	9, 165, 4, 166, 9, 166, 4, 167, 9, 167, 4, 168, 9, 168, 4, 169, 9, 169,
	4, 170, 9, 170, 4, 171, 9, 171, 4, 172, 9, 172, 4, 173, 9, 173, 4, 174,
	9, 174, 4, 175, 9, 175, 4, 176, 9, 176, 4, 177, 9, 177, 4, 178, 9, 178,
	4, 179, 9, 179, 4, 180, 9, 180, 4, 181, 9, 181, 4, 182, 9, 182, 3, 2, 3,
	2, 3, 2, 3, 2, 7, 2, 369, 10, 2, 12, 2, 14, 2, 372, 11, 2, 3, 3, 3, 3,
	3, 3, 3, 3, 5, 3, 378, 10, 3, 3, 3, 3, 3, 3, 4, 3, 4, 3, 4, 7, 4, 385,
	10, 4, 12, 4, 14, 4, 388, 11, 4, 3, 5, 3, 5, 3, 5, 3, 5, 3, 6, 3, 6, 3,
	7, 3, 7, 3, 7, 6, 7, 399, 10, 7, 13, 7, 14, 7, 400, 3, 8, 3, 8, 3, 8, 3,
	9, 3, 9, 3, 10, 3, 10, 3, 10, 3, 10, 7, 10, 412, 10, 10, 12, 10, 14, 10,
	415, 11, 10, 3, 10, 3, 10, 3, 11, 3, 11, 3, 11, 3, 11, 7, 11, 423, 10,
	11, 12, 11, 14, 11, 426, 11, 11, 3, 11, 3, 11, 3, 12, 3, 12, 3, 12, 3,
	12, 3, 12, 5, 12, 435, 10, 12, 3, 13, 3, 13, 3, 13, 3, 13, 7, 13, 441,
	10, 13, 12, 13, 14, 13, 444, 11, 13, 3, 13, 3, 13, 3, 14, 3, 14, 5, 14,
	450, 10, 14, 3, 15, 3, 15, 3, 15, 3, 15, 7, 15, 456, 10, 15, 12, 15, 14,
	15, 459, 11, 15, 3, 15, 3, 15, 3, 16, 3, 16, 3, 17, 3, 17, 3, 17, 5, 17,
	468, 10, 17, 3, 18, 3, 18, 5, 18, 472, 10, 18, 3, 19, 3, 19, 3, 19, 5,
	19, 477, 10, 19, 3, 20, 3, 20, 5, 20, 481, 10, 20, 3, 21, 3, 21, 3, 21,
	5, 21, 486, 10, 21, 3, 22, 3, 22, 5, 22, 490, 10, 22, 3, 23, 3, 23, 3,
	23, 6, 23, 495, 10, 23, 13, 23, 14, 23, 496, 3, 23, 3, 23, 3, 24, 3, 24,
	3, 24, 5, 24, 504, 10, 24, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 26, 3,
	26, 6, 26, 513, 10, 26, 13, 26, 14, 26, 514, 3, 26, 3, 26, 3, 27, 3, 27,
	3, 27, 3, 27, 5, 27, 523, 10, 27, 5, 27, 525, 10, 27, 3, 27, 5, 27, 528,
	10, 27, 3, 27, 5, 27, 531, 10, 27, 3, 27, 3, 27, 5, 27, 535, 10, 27, 3,
	28, 3, 28, 3, 28, 3, 28, 5, 28, 541, 10, 28, 3, 28, 3, 28, 3, 29, 3, 29,
	6, 29, 547, 10, 29, 13, 29, 14, 29, 548, 3, 29, 3, 29, 3, 30, 3, 30, 5,
	30, 555, 10, 30, 3, 30, 3, 30, 3, 30, 5, 30, 560, 10, 30, 3, 30, 5, 30,
	563, 10, 30, 5, 30, 565, 10, 30, 3, 31, 3, 31, 3, 32, 3, 32, 3, 32, 3,
	32, 3, 32, 3, 32, 6, 32, 575, 10, 32, 13, 32, 14, 32, 576, 3, 32, 3, 32,
	3, 33, 5, 33, 582, 10, 33, 3, 33, 3, 33, 3, 33, 5, 33, 587, 10, 33, 3,
	34, 7, 34, 590, 10, 34, 12, 34, 14, 34, 593, 11, 34, 3, 34, 3, 34, 3, 34,
	3, 34, 3, 35, 7, 35, 600, 10, 35, 12, 35, 14, 35, 603, 11, 35, 3, 35, 3,
	35, 3, 35, 5, 35, 608, 10, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35,
	3, 35, 6, 35, 617, 10, 35, 13, 35, 14, 35, 618, 3, 35, 5, 35, 622, 10,
	35, 3, 36, 3, 36, 3, 37, 3, 37, 3, 37, 3, 38, 3, 38, 7, 38, 631, 10, 38,
	12, 38, 14, 38, 634, 11, 38, 3, 39, 3, 39, 5, 39, 638, 10, 39, 3, 39, 5,
	39, 641, 10, 39, 3, 40, 3, 40, 3, 40, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41,
	650, 10, 41, 6, 41, 652, 10, 41, 13, 41, 14, 41, 653, 3, 41, 3, 41, 3,
	42, 3, 42, 3, 42, 5, 42, 661, 10, 42, 3, 43, 7, 43, 664, 10, 43, 12, 43,
	14, 43, 667, 11, 43, 3, 43, 3, 43, 3, 43, 3, 43, 6, 43, 673, 10, 43, 13,
	43, 14, 43, 674, 3, 43, 3, 43, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44,
	3, 45, 3, 45, 3, 45, 3, 45, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 5, 46, 694,
	10, 46, 3, 46, 5, 46, 697, 10, 46, 3, 47, 3, 47, 3, 47, 3, 47, 7, 47, 703,
	10, 47, 12, 47, 14, 47, 706, 11, 47, 3, 48, 3, 48, 5, 48, 710, 10, 48,
	3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 5, 49, 718, 10, 49, 3, 49, 3,
	49, 3, 50, 3, 50, 3, 51, 3, 51, 3, 51, 5, 51, 727, 10, 51, 3, 52, 3, 52,
	6, 52, 731, 10, 52, 13, 52, 14, 52, 732, 5, 52, 735, 10, 52, 3, 53, 3,
	53, 3, 53, 7, 53, 740, 10, 53, 12, 53, 14, 53, 743, 11, 53, 3, 54, 3, 54,
	3, 54, 3, 55, 3, 55, 3, 56, 3, 56, 3, 57, 3, 57, 6, 57, 754, 10, 57, 13,
	57, 14, 57, 755, 3, 57, 3, 57, 3, 57, 3, 57, 5, 57, 762, 10, 57, 5, 57,
	764, 10, 57, 3, 58, 3, 58, 3, 58, 3, 58, 7, 58, 770, 10, 58, 12, 58, 14,
	58, 773, 11, 58, 3, 58, 3, 58, 3, 59, 3, 59, 3, 59, 3, 59, 5, 59, 781,
	10, 59, 3, 59, 3, 59, 5, 59, 785, 10, 59, 3, 60, 3, 60, 3, 60, 3, 60, 3,
	60, 7, 60, 792, 10, 60, 12, 60, 14, 60, 795, 11, 60, 3, 60, 3, 60, 3, 61,
	3, 61, 5, 61, 801, 10, 61, 3, 61, 3, 61, 3, 61, 7, 61, 806, 10, 61, 12,
	61, 14, 61, 809, 11, 61, 3, 61, 3, 61, 3, 62, 3, 62, 7, 62, 815, 10, 62,
	12, 62, 14, 62, 818, 11, 62, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 7, 63,
	825, 10, 63, 12, 63, 14, 63, 828, 11, 63, 3, 63, 3, 63, 3, 64, 3, 64, 3,
	65, 3, 65, 3, 65, 3, 65, 6, 65, 838, 10, 65, 13, 65, 14, 65, 839, 3, 65,
	3, 65, 3, 66, 6, 66, 845, 10, 66, 13, 66, 14, 66, 846, 3, 67, 5, 67, 850,
	10, 67, 3, 67, 3, 67, 3, 67, 6, 67, 855, 10, 67, 13, 67, 14, 67, 856, 3,
	67, 3, 67, 3, 68, 3, 68, 3, 68, 3, 68, 6, 68, 865, 10, 68, 13, 68, 14,
	68, 866, 3, 68, 3, 68, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 5, 69, 876, 10,
	69, 3, 69, 5, 69, 879, 10, 69, 3, 70, 3, 70, 3, 70, 3, 71, 3, 71, 5, 71,
	886, 10, 71, 3, 72, 3, 72, 3, 72, 7, 72, 891, 10, 72, 12, 72, 14, 72, 894,
	11, 72, 3, 73, 3, 73, 3, 73, 3, 73, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74,
	3, 74, 3, 74, 3, 74, 3, 74, 5, 74, 909, 10, 74, 3, 74, 5, 74, 912, 10,
	74, 3, 75, 3, 75, 5, 75, 916, 10, 75, 3, 75, 5, 75, 919, 10, 75, 3, 75,
	5, 75, 922, 10, 75, 3, 75, 3, 75, 3, 75, 6, 75, 927, 10, 75, 13, 75, 14,
	75, 928, 3, 75, 3, 75, 3, 76, 3, 76, 3, 77, 3, 77, 3, 77, 5, 77, 938, 10,
	77, 3, 77, 5, 77, 941, 10, 77, 3, 77, 5, 77, 944, 10, 77, 3, 77, 3, 77,
	3, 77, 3, 77, 6, 77, 950, 10, 77, 13, 77, 14, 77, 951, 3, 77, 3, 77, 5,
	77, 956, 10, 77, 5, 77, 958, 10, 77, 3, 78, 3, 78, 5, 78, 962, 10, 78,
	3, 78, 3, 78, 3, 78, 3, 78, 6, 78, 968, 10, 78, 13, 78, 14, 78, 969, 3,
	78, 3, 78, 3, 79, 3, 79, 3, 79, 3, 79, 5, 79, 978, 10, 79, 3, 80, 3, 80,
	3, 80, 3, 80, 7, 80, 984, 10, 80, 12, 80, 14, 80, 987, 11, 80, 3, 81, 3,
	81, 3, 81, 3, 81, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 5, 82, 998, 10, 82,
	3, 83, 3, 83, 6, 83, 1002, 10, 83, 13, 83, 14, 83, 1003, 3, 83, 5, 83,
	1007, 10, 83, 3, 84, 3, 84, 3, 84, 3, 85, 3, 85, 3, 86, 3, 86, 3, 87, 3,
	87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 88, 3, 88, 3, 89, 3, 89, 3, 89, 3, 89,
	5, 89, 1028, 10, 89, 3, 89, 3, 89, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 6,
	90, 1037, 10, 90, 13, 90, 14, 90, 1038, 3, 90, 3, 90, 5, 90, 1043, 10,
	90, 3, 91, 3, 91, 3, 91, 5, 91, 1048, 10, 91, 3, 91, 5, 91, 1051, 10, 91,
	3, 91, 3, 91, 3, 91, 3, 91, 6, 91, 1057, 10, 91, 13, 91, 14, 91, 1058,
	3, 91, 3, 91, 5, 91, 1063, 10, 91, 3, 92, 3, 92, 3, 92, 3, 92, 5, 92, 1069,
	10, 92, 3, 92, 3, 92, 3, 92, 3, 92, 6, 92, 1075, 10, 92, 13, 92, 14, 92,
	1076, 3, 92, 3, 92, 5, 92, 1081, 10, 92, 3, 93, 3, 93, 5, 93, 1085, 10,
	93, 3, 94, 3, 94, 3, 95, 3, 95, 5, 95, 1091, 10, 95, 3, 95, 3, 95, 3, 96,
	3, 96, 3, 97, 3, 97, 3, 97, 7, 97, 1100, 10, 97, 12, 97, 14, 97, 1103,
	11, 97, 3, 98, 3, 98, 3, 98, 5, 98, 1108, 10, 98, 3, 98, 3, 98, 3, 99,
	3, 99, 5, 99, 1114, 10, 99, 3, 100, 3, 100, 3, 100, 7, 100, 1119, 10, 100,
	12, 100, 14, 100, 1122, 11, 100, 3, 101, 3, 101, 3, 101, 3, 101, 3, 101,
	5, 101, 1129, 10, 101, 3, 101, 3, 101, 3, 101, 3, 101, 3, 101, 3, 101,
	3, 102, 3, 102, 3, 102, 5, 102, 1140, 10, 102, 3, 102, 3, 102, 3, 102,
	3, 103, 3, 103, 3, 103, 3, 104, 3, 104, 5, 104, 1150, 10, 104, 3, 105,
	3, 105, 3, 105, 3, 105, 3, 105, 5, 105, 1157, 10, 105, 3, 105, 3, 105,
	3, 105, 3, 106, 3, 106, 3, 107, 3, 107, 3, 107, 5, 107, 1167, 10, 107,
	3, 107, 3, 107, 3, 107, 3, 108, 3, 108, 3, 108, 3, 108, 3, 108, 3, 109,
	3, 109, 3, 110, 3, 110, 3, 111, 3, 111, 3, 112, 5, 112, 1184, 10, 112,
	3, 112, 3, 112, 3, 113, 5, 113, 1189, 10, 113, 3, 113, 3, 113, 5, 113,
	1193, 10, 113, 3, 113, 3, 113, 3, 113, 5, 113, 1198, 10, 113, 3, 114, 3,
	114, 3, 114, 3, 114, 5, 114, 1204, 10, 114, 3, 115, 3, 115, 3, 115, 3,
	115, 7, 115, 1210, 10, 115, 12, 115, 14, 115, 1213, 11, 115, 3, 115, 3,
	115, 3, 116, 5, 116, 1218, 10, 116, 3, 116, 3, 116, 5, 116, 1222, 10, 116,
	3, 116, 3, 116, 3, 116, 3, 117, 3, 117, 3, 117, 3, 117, 3, 117, 3, 117,
	3, 117, 3, 117, 3, 117, 3, 117, 3, 117, 5, 117, 1238, 10, 117, 3, 118,
	3, 118, 3, 119, 3, 119, 3, 119, 7, 119, 1245, 10, 119, 12, 119, 14, 119,
	1248, 11, 119, 3, 120, 3, 120, 3, 120, 3, 120, 3, 121, 3, 121, 3, 122,
	3, 122, 3, 122, 3, 122, 3, 122, 3, 122, 3, 122, 3, 122, 3, 122, 3, 122,
	3, 122, 5, 122, 1267, 10, 122, 3, 123, 3, 123, 3, 123, 3, 123, 5, 123,
	1273, 10, 123, 3, 124, 3, 124, 3, 125, 3, 125, 3, 125, 3, 125, 3, 126,
	3, 126, 3, 126, 3, 126, 3, 127, 3, 127, 3, 127, 3, 127, 3, 127, 3, 127,
	3, 127, 3, 127, 5, 127, 1293, 10, 127, 3, 128, 3, 128, 7, 128, 1297, 10,
	128, 12, 128, 14, 128, 1300, 11, 128, 3, 129, 3, 129, 3, 129, 3, 130, 3,
	130, 5, 130, 1307, 10, 130, 3, 131, 5, 131, 1310, 10, 131, 3, 131, 3, 131,
	3, 132, 3, 132, 3, 132, 3, 133, 3, 133, 7, 133, 1319, 10, 133, 12, 133,
	14, 133, 1322, 11, 133, 3, 134, 3, 134, 3, 134, 3, 135, 3, 135, 7, 135,
	1329, 10, 135, 12, 135, 14, 135, 1332, 11, 135, 3, 136, 3, 136, 3, 137,
	3, 137, 3, 137, 3, 137, 7, 137, 1340, 10, 137, 12, 137, 14, 137, 1343,
	11, 137, 3, 138, 3, 138, 3, 138, 7, 138, 1348, 10, 138, 12, 138, 14, 138,
	1351, 11, 138, 3, 139, 3, 139, 3, 139, 7, 139, 1356, 10, 139, 12, 139,
	14, 139, 1359, 11, 139, 3, 140, 3, 140, 3, 140, 7, 140, 1364, 10, 140,
	12, 140, 14, 140, 1367, 11, 140, 3, 141, 3, 141, 3, 141, 7, 141, 1372,
	10, 141, 12, 141, 14, 141, 1375, 11, 141, 3, 142, 3, 142, 3, 142, 7, 142,
	1380, 10, 142, 12, 142, 14, 142, 1383, 11, 142, 3, 143, 3, 143, 3, 143,
	7, 143, 1388, 10, 143, 12, 143, 14, 143, 1391, 11, 143, 3, 144, 3, 144,
	3, 144, 7, 144, 1396, 10, 144, 12, 144, 14, 144, 1399, 11, 144, 3, 145,
	3, 145, 5, 145, 1403, 10, 145, 3, 145, 3, 145, 3, 145, 3, 145, 3, 145,
	3, 146, 3, 146, 3, 146, 3, 147, 3, 147, 3, 148, 3, 148, 3, 148, 7, 148,
	1418, 10, 148, 12, 148, 14, 148, 1421, 11, 148, 3, 149, 3, 149, 3, 149,
	3, 149, 3, 149, 5, 149, 1428, 10, 149, 3, 150, 3, 150, 3, 150, 3, 150,
	5, 150, 1434, 10, 150, 3, 151, 3, 151, 3, 151, 3, 152, 5, 152, 1440, 10,
	152, 3, 152, 3, 152, 3, 152, 3, 152, 6, 152, 1446, 10, 152, 13, 152, 14,
	152, 1447, 3, 152, 5, 152, 1451, 10, 152, 3, 152, 3, 152, 3, 153, 3, 153,
	3, 153, 3, 153, 3, 153, 5, 153, 1460, 10, 153, 3, 154, 3, 154, 3, 154,
	3, 154, 5, 154, 1466, 10, 154, 3, 155, 3, 155, 3, 155, 3, 155, 3, 155,
	3, 155, 3, 155, 5, 155, 1475, 10, 155, 3, 156, 3, 156, 3, 156, 3, 156,
	3, 157, 3, 157, 3, 157, 3, 157, 3, 157, 3, 158, 3, 158, 3, 158, 3, 158,
	3, 158, 3, 159, 3, 159, 3, 160, 3, 160, 3, 161, 3, 161, 3, 161, 7, 161,
	1498, 10, 161, 12, 161, 14, 161, 1501, 11, 161, 3, 161, 5, 161, 1504, 10,
	161, 3, 162, 3, 162, 5, 162, 1508, 10, 162, 3, 162, 7, 162, 1511, 10, 162,
	12, 162, 14, 162, 1514, 11, 162, 3, 162, 3, 162, 3, 163, 3, 163, 3, 163,
	3, 163, 3, 163, 3, 163, 3, 163, 3, 163, 3, 163, 5, 163, 1527, 10, 163,
	3, 163, 3, 163, 5, 163, 1531, 10, 163, 3, 164, 3, 164, 3, 164, 3, 164,
	3, 164, 3, 165, 3, 165, 3, 165, 5, 165, 1541, 10, 165, 3, 166, 3, 166,
	3, 166, 5, 166, 1546, 10, 166, 3, 167, 3, 167, 3, 168, 3, 168, 3, 169,
	3, 169, 3, 170, 5, 170, 1555, 10, 170, 3, 170, 3, 170, 3, 170, 3, 170,
	3, 170, 5, 170, 1562, 10, 170, 3, 170, 3, 170, 5, 170, 1566, 10, 170, 3,
	170, 3, 170, 3, 170, 3, 170, 3, 170, 6, 170, 1573, 10, 170, 13, 170, 14,
	170, 1574, 3, 170, 3, 170, 3, 170, 3, 170, 3, 171, 3, 171, 3, 171, 3, 171,
	3, 172, 3, 172, 3, 172, 3, 172, 3, 173, 3, 173, 3, 173, 7, 173, 1592, 10,
	173, 12, 173, 14, 173, 1595, 11, 173, 3, 174, 3, 174, 3, 175, 3, 175, 3,
	175, 3, 175, 3, 175, 3, 175, 3, 175, 5, 175, 1606, 10, 175, 3, 175, 5,
	175, 1609, 10, 175, 3, 175, 3, 175, 3, 175, 3, 175, 3, 175, 5, 175, 1616,
	10, 175, 3, 176, 3, 176, 3, 176, 5, 176, 1621, 10, 176, 3, 176, 3, 176,
	7, 176, 1625, 10, 176, 12, 176, 14, 176, 1628, 11, 176, 3, 176, 3, 176,
	5, 176, 1632, 10, 176, 3, 176, 3, 176, 7, 176, 1636, 10, 176, 12, 176,
	14, 176, 1639, 11, 176, 3, 176, 3, 176, 5, 176, 1643, 10, 176, 3, 176,
	3, 176, 5, 176, 1647, 10, 176, 3, 177, 3, 177, 3, 177, 3, 177, 3, 177,
	3, 177, 3, 177, 3, 177, 3, 177, 3, 177, 3, 177, 3, 177, 3, 177, 3, 177,
	3, 177, 3, 177, 6, 177, 1665, 10, 177, 13, 177, 14, 177, 1666, 3, 177,
	3, 177, 5, 177, 1671, 10, 177, 3, 178, 7, 178, 1674, 10, 178, 12, 178,
	14, 178, 1677, 11, 178, 3, 178, 3, 178, 3, 178, 3, 178, 3, 179, 3, 179,
	3, 179, 3, 180, 3, 180, 3, 180, 3, 180, 3, 180, 3, 180, 7, 180, 1692, 10,
	180, 12, 180, 14, 180, 1695, 11, 180, 5, 180, 1697, 10, 180, 3, 180, 7,
	180, 1700, 10, 180, 12, 180, 14, 180, 1703, 11, 180, 3, 180, 5, 180, 1706,
	10, 180, 3, 180, 7, 180, 1709, 10, 180, 12, 180, 14, 180, 1712, 11, 180,
	3, 180, 5, 180, 1715, 10, 180, 3, 181, 6, 181, 1718, 10, 181, 13, 181,
	14, 181, 1719, 3, 182, 5, 182, 1723, 10, 182, 3, 182, 6, 182, 1726, 10,
	182, 13, 182, 14, 182, 1727, 3, 182, 3, 182, 3, 182, 2, 2, 183, 2, 4, 6,
	8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,
	44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78,
	80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
	114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142,
	144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172,
	174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202,
	204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232,
	234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262,
	264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292,
	294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322,
	324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352,
	354, 356, 358, 360, 362, 2, 20, 4, 2, 63, 64, 143, 143, 4, 2, 44, 44, 144,
	144, 3, 2, 8, 9, 4, 2, 8, 9, 11, 11, 4, 2, 17, 19, 21, 23, 4, 2, 60, 60,
	63, 64, 4, 2, 118, 120, 138, 141, 4, 2, 88, 88, 144, 144, 5, 2, 5, 5, 135,
	135, 143, 143, 3, 2, 124, 125, 4, 2, 131, 131, 133, 133, 3, 2, 122, 123,
	4, 2, 76, 76, 143, 144, 5, 2, 97, 97, 100, 100, 102, 103, 4, 2, 98, 99,
	111, 111, 4, 2, 97, 97, 100, 100, 4, 2, 79, 80, 83, 84, 4, 2, 107, 107,
	109, 109, 2, 1804, 2, 364, 3, 2, 2, 2, 4, 373, 3, 2, 2, 2, 6, 381, 3, 2,
	2, 2, 8, 389, 3, 2, 2, 2, 10, 393, 3, 2, 2, 2, 12, 395, 3, 2, 2, 2, 14,
	402, 3, 2, 2, 2, 16, 405, 3, 2, 2, 2, 18, 407, 3, 2, 2, 2, 20, 418, 3,
	2, 2, 2, 22, 429, 3, 2, 2, 2, 24, 436, 3, 2, 2, 2, 26, 449, 3, 2, 2, 2,
	28, 451, 3, 2, 2, 2, 30, 462, 3, 2, 2, 2, 32, 467, 3, 2, 2, 2, 34, 471,
	3, 2, 2, 2, 36, 473, 3, 2, 2, 2, 38, 480, 3, 2, 2, 2, 40, 482, 3, 2, 2,
	2, 42, 489, 3, 2, 2, 2, 44, 491, 3, 2, 2, 2, 46, 503, 3, 2, 2, 2, 48, 505,
	3, 2, 2, 2, 50, 510, 3, 2, 2, 2, 52, 524, 3, 2, 2, 2, 54, 536, 3, 2, 2,
	2, 56, 544, 3, 2, 2, 2, 58, 552, 3, 2, 2, 2, 60, 566, 3, 2, 2, 2, 62, 568,
	3, 2, 2, 2, 64, 581, 3, 2, 2, 2, 66, 591, 3, 2, 2, 2, 68, 601, 3, 2, 2,
	2, 70, 623, 3, 2, 2, 2, 72, 625, 3, 2, 2, 2, 74, 628, 3, 2, 2, 2, 76, 635,
	3, 2, 2, 2, 78, 642, 3, 2, 2, 2, 80, 645, 3, 2, 2, 2, 82, 657, 3, 2, 2,
	2, 84, 665, 3, 2, 2, 2, 86, 678, 3, 2, 2, 2, 88, 684, 3, 2, 2, 2, 90, 688,
	3, 2, 2, 2, 92, 698, 3, 2, 2, 2, 94, 709, 3, 2, 2, 2, 96, 711, 3, 2, 2,
	2, 98, 721, 3, 2, 2, 2, 100, 723, 3, 2, 2, 2, 102, 734, 3, 2, 2, 2, 104,
	736, 3, 2, 2, 2, 106, 744, 3, 2, 2, 2, 108, 747, 3, 2, 2, 2, 110, 749,
	3, 2, 2, 2, 112, 763, 3, 2, 2, 2, 114, 765, 3, 2, 2, 2, 116, 780, 3, 2,
	2, 2, 118, 786, 3, 2, 2, 2, 120, 798, 3, 2, 2, 2, 122, 812, 3, 2, 2, 2,
	124, 819, 3, 2, 2, 2, 126, 831, 3, 2, 2, 2, 128, 833, 3, 2, 2, 2, 130,
	844, 3, 2, 2, 2, 132, 849, 3, 2, 2, 2, 134, 860, 3, 2, 2, 2, 136, 878,
	3, 2, 2, 2, 138, 880, 3, 2, 2, 2, 140, 885, 3, 2, 2, 2, 142, 887, 3, 2,
	2, 2, 144, 895, 3, 2, 2, 2, 146, 908, 3, 2, 2, 2, 148, 913, 3, 2, 2, 2,
	150, 932, 3, 2, 2, 2, 152, 957, 3, 2, 2, 2, 154, 959, 3, 2, 2, 2, 156,
	973, 3, 2, 2, 2, 158, 979, 3, 2, 2, 2, 160, 988, 3, 2, 2, 2, 162, 997,
	3, 2, 2, 2, 164, 1001, 3, 2, 2, 2, 166, 1008, 3, 2, 2, 2, 168, 1011, 3,
	2, 2, 2, 170, 1013, 3, 2, 2, 2, 172, 1015, 3, 2, 2, 2, 174, 1021, 3, 2,
	2, 2, 176, 1027, 3, 2, 2, 2, 178, 1031, 3, 2, 2, 2, 180, 1044, 3, 2, 2,
	2, 182, 1064, 3, 2, 2, 2, 184, 1084, 3, 2, 2, 2, 186, 1086, 3, 2, 2, 2,
	188, 1088, 3, 2, 2, 2, 190, 1094, 3, 2, 2, 2, 192, 1096, 3, 2, 2, 2, 194,
	1104, 3, 2, 2, 2, 196, 1111, 3, 2, 2, 2, 198, 1115, 3, 2, 2, 2, 200, 1123,
	3, 2, 2, 2, 202, 1136, 3, 2, 2, 2, 204, 1144, 3, 2, 2, 2, 206, 1149, 3,
	2, 2, 2, 208, 1151, 3, 2, 2, 2, 210, 1161, 3, 2, 2, 2, 212, 1163, 3, 2,
	2, 2, 214, 1171, 3, 2, 2, 2, 216, 1176, 3, 2, 2, 2, 218, 1178, 3, 2, 2,
	2, 220, 1180, 3, 2, 2, 2, 222, 1183, 3, 2, 2, 2, 224, 1188, 3, 2, 2, 2,
	226, 1203, 3, 2, 2, 2, 228, 1205, 3, 2, 2, 2, 230, 1217, 3, 2, 2, 2, 232,
	1237, 3, 2, 2, 2, 234, 1239, 3, 2, 2, 2, 236, 1241, 3, 2, 2, 2, 238, 1249,
	3, 2, 2, 2, 240, 1253, 3, 2, 2, 2, 242, 1255, 3, 2, 2, 2, 244, 1272, 3,
	2, 2, 2, 246, 1274, 3, 2, 2, 2, 248, 1276, 3, 2, 2, 2, 250, 1280, 3, 2,
	2, 2, 252, 1292, 3, 2, 2, 2, 254, 1294, 3, 2, 2, 2, 256, 1301, 3, 2, 2,
	2, 258, 1304, 3, 2, 2, 2, 260, 1309, 3, 2, 2, 2, 262, 1313, 3, 2, 2, 2,
	264, 1316, 3, 2, 2, 2, 266, 1323, 3, 2, 2, 2, 268, 1326, 3, 2, 2, 2, 270,
	1333, 3, 2, 2, 2, 272, 1335, 3, 2, 2, 2, 274, 1344, 3, 2, 2, 2, 276, 1352,
	3, 2, 2, 2, 278, 1360, 3, 2, 2, 2, 280, 1368, 3, 2, 2, 2, 282, 1376, 3,
	2, 2, 2, 284, 1384, 3, 2, 2, 2, 286, 1392, 3, 2, 2, 2, 288, 1400, 3, 2,
	2, 2, 290, 1409, 3, 2, 2, 2, 292, 1412, 3, 2, 2, 2, 294, 1414, 3, 2, 2,
	2, 296, 1422, 3, 2, 2, 2, 298, 1429, 3, 2, 2, 2, 300, 1435, 3, 2, 2, 2,
	302, 1439, 3, 2, 2, 2, 304, 1454, 3, 2, 2, 2, 306, 1465, 3, 2, 2, 2, 308,
	1467, 3, 2, 2, 2, 310, 1476, 3, 2, 2, 2, 312, 1480, 3, 2, 2, 2, 314, 1485,
	3, 2, 2, 2, 316, 1490, 3, 2, 2, 2, 318, 1492, 3, 2, 2, 2, 320, 1503, 3,
	2, 2, 2, 322, 1505, 3, 2, 2, 2, 324, 1526, 3, 2, 2, 2, 326, 1532, 3, 2,
	2, 2, 328, 1540, 3, 2, 2, 2, 330, 1545, 3, 2, 2, 2, 332, 1547, 3, 2, 2,
	2, 334, 1549, 3, 2, 2, 2, 336, 1551, 3, 2, 2, 2, 338, 1554, 3, 2, 2, 2,
	340, 1580, 3, 2, 2, 2, 342, 1584, 3, 2, 2, 2, 344, 1588, 3, 2, 2, 2, 346,
	1596, 3, 2, 2, 2, 348, 1598, 3, 2, 2, 2, 350, 1617, 3, 2, 2, 2, 352, 1648,
	3, 2, 2, 2, 354, 1675, 3, 2, 2, 2, 356, 1682, 3, 2, 2, 2, 358, 1685, 3,
	2, 2, 2, 360, 1717, 3, 2, 2, 2, 362, 1722, 3, 2, 2, 2, 364, 365, 7, 39,
	2, 2, 365, 370, 7, 64, 2, 2, 366, 367, 7, 37, 2, 2, 367, 369, 7, 64, 2,
	2, 368, 366, 3, 2, 2, 2, 369, 372, 3, 2, 2, 2, 370, 368, 3, 2, 2, 2, 370,
	371, 3, 2, 2, 2, 371, 3, 3, 2, 2, 2, 372, 370, 3, 2, 2, 2, 373, 374, 7,
	52, 2, 2, 374, 377, 7, 59, 2, 2, 375, 376, 7, 44, 2, 2, 376, 378, 7, 59,
	2, 2, 377, 375, 3, 2, 2, 2, 377, 378, 3, 2, 2, 2, 378, 379, 3, 2, 2, 2,
	379, 380, 7, 53, 2, 2, 380, 5, 3, 2, 2, 2, 381, 386, 5, 2, 2, 2, 382, 383,
	7, 40, 2, 2, 383, 385, 5, 2, 2, 2, 384, 382, 3, 2, 2, 2, 385, 388, 3, 2,
	2, 2, 386, 384, 3, 2, 2, 2, 386, 387, 3, 2, 2, 2, 387, 7, 3, 2, 2, 2, 388,
	386, 3, 2, 2, 2, 389, 390, 7, 48, 2, 2, 390, 391, 5, 6, 4, 2, 391, 392,
	7, 49, 2, 2, 392, 9, 3, 2, 2, 2, 393, 394, 9, 2, 2, 2, 394, 11, 3, 2, 2,
	2, 395, 398, 5, 74, 38, 2, 396, 397, 9, 3, 2, 2, 397, 399, 5, 10, 6, 2,
	398, 396, 3, 2, 2, 2, 399, 400, 3, 2, 2, 2, 400, 398, 3, 2, 2, 2, 400,
	401, 3, 2, 2, 2, 401, 13, 3, 2, 2, 2, 402, 403, 7, 56, 2, 2, 403, 404,
	7, 71, 2, 2, 404, 15, 3, 2, 2, 2, 405, 406, 7, 60, 2, 2, 406, 17, 3, 2,
	2, 2, 407, 408, 7, 48, 2, 2, 408, 413, 5, 16, 9, 2, 409, 410, 7, 40, 2,
	2, 410, 412, 5, 16, 9, 2, 411, 409, 3, 2, 2, 2, 412, 415, 3, 2, 2, 2, 413,
	411, 3, 2, 2, 2, 413, 414, 3, 2, 2, 2, 414, 416, 3, 2, 2, 2, 415, 413,
	3, 2, 2, 2, 416, 417, 7, 49, 2, 2, 417, 19, 3, 2, 2, 2, 418, 419, 7, 48,
	2, 2, 419, 424, 5, 18, 10, 2, 420, 421, 7, 40, 2, 2, 421, 423, 5, 18, 10,
	2, 422, 420, 3, 2, 2, 2, 423, 426, 3, 2, 2, 2, 424, 422, 3, 2, 2, 2, 424,
	425, 3, 2, 2, 2, 425, 427, 3, 2, 2, 2, 426, 424, 3, 2, 2, 2, 427, 428,
	7, 49, 2, 2, 428, 21, 3, 2, 2, 2, 429, 430, 7, 64, 2, 2, 430, 434, 7, 41,
	2, 2, 431, 435, 5, 16, 9, 2, 432, 435, 5, 18, 10, 2, 433, 435, 5, 20, 11,
	2, 434, 431, 3, 2, 2, 2, 434, 432, 3, 2, 2, 2, 434, 433, 3, 2, 2, 2, 435,
	23, 3, 2, 2, 2, 436, 437, 7, 48, 2, 2, 437, 442, 5, 22, 12, 2, 438, 439,
	7, 40, 2, 2, 439, 441, 5, 22, 12, 2, 440, 438, 3, 2, 2, 2, 441, 444, 3,
	2, 2, 2, 442, 440, 3, 2, 2, 2, 442, 443, 3, 2, 2, 2, 443, 445, 3, 2, 2,
	2, 444, 442, 3, 2, 2, 2, 445, 446, 7, 49, 2, 2, 446, 25, 3, 2, 2, 2, 447,
	450, 5, 22, 12, 2, 448, 450, 5, 2, 2, 2, 449, 447, 3, 2, 2, 2, 449, 448,
	3, 2, 2, 2, 450, 27, 3, 2, 2, 2, 451, 452, 7, 48, 2, 2, 452, 457, 5, 26,
	14, 2, 453, 454, 7, 40, 2, 2, 454, 456, 5, 26, 14, 2, 455, 453, 3, 2, 2,
	2, 456, 459, 3, 2, 2, 2, 457, 455, 3, 2, 2, 2, 457, 458, 3, 2, 2, 2, 458,
	460, 3, 2, 2, 2, 459, 457, 3, 2, 2, 2, 460, 461, 7, 49, 2, 2, 461, 29,
	3, 2, 2, 2, 462, 463, 5, 10, 6, 2, 463, 31, 3, 2, 2, 2, 464, 468, 5, 30,
	16, 2, 465, 468, 5, 12, 7, 2, 466, 468, 7, 5, 2, 2, 467, 464, 3, 2, 2,
	2, 467, 465, 3, 2, 2, 2, 467, 466, 3, 2, 2, 2, 468, 33, 3, 2, 2, 2, 469,
	472, 7, 27, 2, 2, 470, 472, 7, 123, 2, 2, 471, 469, 3, 2, 2, 2, 471, 470,
	3, 2, 2, 2, 472, 35, 3, 2, 2, 2, 473, 474, 5, 34, 18, 2, 474, 476, 5, 32,
	17, 2, 475, 477, 5, 4, 3, 2, 476, 475, 3, 2, 2, 2, 476, 477, 3, 2, 2, 2,
	477, 37, 3, 2, 2, 2, 478, 481, 7, 26, 2, 2, 479, 481, 7, 122, 2, 2, 480,
	478, 3, 2, 2, 2, 480, 479, 3, 2, 2, 2, 481, 39, 3, 2, 2, 2, 482, 483, 5,
	38, 20, 2, 483, 485, 5, 32, 17, 2, 484, 486, 5, 4, 3, 2, 485, 484, 3, 2,
	2, 2, 485, 486, 3, 2, 2, 2, 486, 41, 3, 2, 2, 2, 487, 490, 5, 36, 19, 2,
	488, 490, 5, 40, 21, 2, 489, 487, 3, 2, 2, 2, 489, 488, 3, 2, 2, 2, 490,
	43, 3, 2, 2, 2, 491, 492, 7, 43, 2, 2, 492, 494, 7, 3, 2, 2, 493, 495,
	5, 14, 8, 2, 494, 493, 3, 2, 2, 2, 495, 496, 3, 2, 2, 2, 496, 494, 3, 2,
	2, 2, 496, 497, 3, 2, 2, 2, 497, 498, 3, 2, 2, 2, 498, 499, 7, 4, 2, 2,
	499, 45, 3, 2, 2, 2, 500, 504, 7, 60, 2, 2, 501, 504, 5, 18, 10, 2, 502,
	504, 5, 44, 23, 2, 503, 500, 3, 2, 2, 2, 503, 501, 3, 2, 2, 2, 503, 502,
	3, 2, 2, 2, 504, 47, 3, 2, 2, 2, 505, 506, 7, 46, 2, 2, 506, 507, 7, 73,
	2, 2, 507, 508, 7, 41, 2, 2, 508, 509, 5, 46, 24, 2, 509, 49, 3, 2, 2,
	2, 510, 512, 7, 3, 2, 2, 511, 513, 5, 48, 25, 2, 512, 511, 3, 2, 2, 2,
	513, 514, 3, 2, 2, 2, 514, 512, 3, 2, 2, 2, 514, 515, 3, 2, 2, 2, 515,
	516, 3, 2, 2, 2, 516, 517, 7, 4, 2, 2, 517, 51, 3, 2, 2, 2, 518, 525, 5,
	42, 22, 2, 519, 522, 5, 32, 17, 2, 520, 523, 5, 54, 28, 2, 521, 523, 5,
	4, 3, 2, 522, 520, 3, 2, 2, 2, 522, 521, 3, 2, 2, 2, 522, 523, 3, 2, 2,
	2, 523, 525, 3, 2, 2, 2, 524, 518, 3, 2, 2, 2, 524, 519, 3, 2, 2, 2, 525,
	527, 3, 2, 2, 2, 526, 528, 7, 45, 2, 2, 527, 526, 3, 2, 2, 2, 527, 528,
	3, 2, 2, 2, 528, 530, 3, 2, 2, 2, 529, 531, 5, 28, 15, 2, 530, 529, 3,
	2, 2, 2, 530, 531, 3, 2, 2, 2, 531, 534, 3, 2, 2, 2, 532, 533, 7, 43, 2,
	2, 533, 535, 5, 50, 26, 2, 534, 532, 3, 2, 2, 2, 534, 535, 3, 2, 2, 2,
	535, 53, 3, 2, 2, 2, 536, 537, 7, 52, 2, 2, 537, 538, 7, 59, 2, 2, 538,
	540, 7, 25, 2, 2, 539, 541, 7, 59, 2, 2, 540, 539, 3, 2, 2, 2, 540, 541,
	3, 2, 2, 2, 541, 542, 3, 2, 2, 2, 542, 543, 7, 53, 2, 2, 543, 55, 3, 2,
	2, 2, 544, 546, 7, 3, 2, 2, 545, 547, 5, 58, 30, 2, 546, 545, 3, 2, 2,
	2, 547, 548, 3, 2, 2, 2, 548, 546, 3, 2, 2, 2, 548, 549, 3, 2, 2, 2, 549,
	550, 3, 2, 2, 2, 550, 551, 7, 4, 2, 2, 551, 57, 3, 2, 2, 2, 552, 564, 5,
	10, 6, 2, 553, 555, 5, 54, 28, 2, 554, 553, 3, 2, 2, 2, 554, 555, 3, 2,
	2, 2, 555, 556, 3, 2, 2, 2, 556, 559, 7, 33, 2, 2, 557, 560, 5, 52, 27,
	2, 558, 560, 5, 56, 29, 2, 559, 557, 3, 2, 2, 2, 559, 558, 3, 2, 2, 2,
	560, 562, 3, 2, 2, 2, 561, 563, 7, 60, 2, 2, 562, 561, 3, 2, 2, 2, 562,
	563, 3, 2, 2, 2, 563, 565, 3, 2, 2, 2, 564, 554, 3, 2, 2, 2, 564, 565,
	3, 2, 2, 2, 565, 59, 3, 2, 2, 2, 566, 567, 5, 66, 34, 2, 567, 61, 3, 2,
	2, 2, 568, 574, 7, 3, 2, 2, 569, 575, 7, 62, 2, 2, 570, 575, 5, 58, 30,
	2, 571, 575, 5, 48, 25, 2, 572, 575, 5, 60, 31, 2, 573, 575, 7, 24, 2,
	2, 574, 569, 3, 2, 2, 2, 574, 570, 3, 2, 2, 2, 574, 571, 3, 2, 2, 2, 574,
	572, 3, 2, 2, 2, 574, 573, 3, 2, 2, 2, 575, 576, 3, 2, 2, 2, 576, 574,
	3, 2, 2, 2, 576, 577, 3, 2, 2, 2, 577, 578, 3, 2, 2, 2, 578, 579, 7, 4,
	2, 2, 579, 63, 3, 2, 2, 2, 580, 582, 5, 28, 15, 2, 581, 580, 3, 2, 2, 2,
	581, 582, 3, 2, 2, 2, 582, 583, 3, 2, 2, 2, 583, 586, 7, 43, 2, 2, 584,
	587, 7, 24, 2, 2, 585, 587, 5, 62, 32, 2, 586, 584, 3, 2, 2, 2, 586, 585,
	3, 2, 2, 2, 587, 65, 3, 2, 2, 2, 588, 590, 7, 62, 2, 2, 589, 588, 3, 2,
	2, 2, 590, 593, 3, 2, 2, 2, 591, 589, 3, 2, 2, 2, 591, 592, 3, 2, 2, 2,
	592, 594, 3, 2, 2, 2, 593, 591, 3, 2, 2, 2, 594, 595, 9, 4, 2, 2, 595,
	596, 5, 10, 6, 2, 596, 597, 5, 64, 33, 2, 597, 67, 3, 2, 2, 2, 598, 600,
	7, 62, 2, 2, 599, 598, 3, 2, 2, 2, 600, 603, 3, 2, 2, 2, 601, 599, 3, 2,
	2, 2, 601, 602, 3, 2, 2, 2, 602, 604, 3, 2, 2, 2, 603, 601, 3, 2, 2, 2,
	604, 605, 7, 11, 2, 2, 605, 607, 5, 10, 6, 2, 606, 608, 5, 28, 15, 2, 607,
	606, 3, 2, 2, 2, 607, 608, 3, 2, 2, 2, 608, 609, 3, 2, 2, 2, 609, 621,
	7, 43, 2, 2, 610, 622, 7, 24, 2, 2, 611, 616, 7, 3, 2, 2, 612, 617, 7,
	62, 2, 2, 613, 617, 5, 30, 16, 2, 614, 617, 5, 48, 25, 2, 615, 617, 7,
	24, 2, 2, 616, 612, 3, 2, 2, 2, 616, 613, 3, 2, 2, 2, 616, 614, 3, 2, 2,
	2, 616, 615, 3, 2, 2, 2, 617, 618, 3, 2, 2, 2, 618, 616, 3, 2, 2, 2, 618,
	619, 3, 2, 2, 2, 619, 620, 3, 2, 2, 2, 620, 622, 7, 4, 2, 2, 621, 610,
	3, 2, 2, 2, 621, 611, 3, 2, 2, 2, 622, 69, 3, 2, 2, 2, 623, 624, 5, 10,
	6, 2, 624, 71, 3, 2, 2, 2, 625, 626, 7, 32, 2, 2, 626, 627, 5, 70, 36,
	2, 627, 73, 3, 2, 2, 2, 628, 632, 5, 70, 36, 2, 629, 631, 5, 72, 37, 2,
	630, 629, 3, 2, 2, 2, 631, 634, 3, 2, 2, 2, 632, 630, 3, 2, 2, 2, 632,
	633, 3, 2, 2, 2, 633, 75, 3, 2, 2, 2, 634, 632, 3, 2, 2, 2, 635, 637, 5,
	74, 38, 2, 636, 638, 7, 60, 2, 2, 637, 636, 3, 2, 2, 2, 637, 638, 3, 2,
	2, 2, 638, 640, 3, 2, 2, 2, 639, 641, 5, 28, 15, 2, 640, 639, 3, 2, 2,
	2, 640, 641, 3, 2, 2, 2, 641, 77, 3, 2, 2, 2, 642, 643, 7, 64, 2, 2, 643,
	644, 7, 43, 2, 2, 644, 79, 3, 2, 2, 2, 645, 646, 7, 43, 2, 2, 646, 651,
	7, 3, 2, 2, 647, 649, 7, 64, 2, 2, 648, 650, 5, 28, 15, 2, 649, 648, 3,
	2, 2, 2, 649, 650, 3, 2, 2, 2, 650, 652, 3, 2, 2, 2, 651, 647, 3, 2, 2,
	2, 652, 653, 3, 2, 2, 2, 653, 651, 3, 2, 2, 2, 653, 654, 3, 2, 2, 2, 654,
	655, 3, 2, 2, 2, 655, 656, 7, 4, 2, 2, 656, 81, 3, 2, 2, 2, 657, 658, 9,
	5, 2, 2, 658, 660, 7, 64, 2, 2, 659, 661, 5, 80, 41, 2, 660, 659, 3, 2,
	2, 2, 660, 661, 3, 2, 2, 2, 661, 83, 3, 2, 2, 2, 662, 664, 7, 62, 2, 2,
	663, 662, 3, 2, 2, 2, 664, 667, 3, 2, 2, 2, 665, 663, 3, 2, 2, 2, 665,
	666, 3, 2, 2, 2, 666, 668, 3, 2, 2, 2, 667, 665, 3, 2, 2, 2, 668, 669,
	7, 7, 2, 2, 669, 670, 5, 78, 40, 2, 670, 672, 7, 3, 2, 2, 671, 673, 5,
	82, 42, 2, 672, 671, 3, 2, 2, 2, 673, 674, 3, 2, 2, 2, 674, 672, 3, 2,
	2, 2, 674, 675, 3, 2, 2, 2, 675, 676, 3, 2, 2, 2, 676, 677, 7, 4, 2, 2,
	677, 85, 3, 2, 2, 2, 678, 679, 7, 46, 2, 2, 679, 680, 7, 64, 2, 2, 680,
	681, 7, 41, 2, 2, 681, 682, 7, 60, 2, 2, 682, 683, 7, 61, 2, 2, 683, 87,
	3, 2, 2, 2, 684, 685, 7, 50, 2, 2, 685, 686, 7, 64, 2, 2, 686, 687, 7,
	51, 2, 2, 687, 89, 3, 2, 2, 2, 688, 689, 7, 64, 2, 2, 689, 693, 7, 41,
	2, 2, 690, 694, 7, 5, 2, 2, 691, 694, 5, 10, 6, 2, 692, 694, 5, 88, 45,
	2, 693, 690, 3, 2, 2, 2, 693, 691, 3, 2, 2, 2, 693, 692, 3, 2, 2, 2, 694,
	696, 3, 2, 2, 2, 695, 697, 7, 45, 2, 2, 696, 695, 3, 2, 2, 2, 696, 697,
	3, 2, 2, 2, 697, 91, 3, 2, 2, 2, 698, 699, 7, 45, 2, 2, 699, 704, 5, 90,
	46, 2, 700, 701, 7, 47, 2, 2, 701, 703, 5, 90, 46, 2, 702, 700, 3, 2, 2,
	2, 703, 706, 3, 2, 2, 2, 704, 702, 3, 2, 2, 2, 704, 705, 3, 2, 2, 2, 705,
	93, 3, 2, 2, 2, 706, 704, 3, 2, 2, 2, 707, 710, 5, 10, 6, 2, 708, 710,
	7, 59, 2, 2, 709, 707, 3, 2, 2, 2, 709, 708, 3, 2, 2, 2, 710, 95, 3, 2,
	2, 2, 711, 712, 7, 50, 2, 2, 712, 713, 5, 94, 48, 2, 713, 717, 7, 33, 2,
	2, 714, 718, 7, 5, 2, 2, 715, 718, 5, 10, 6, 2, 716, 718, 5, 12, 7, 2,
	717, 714, 3, 2, 2, 2, 717, 715, 3, 2, 2, 2, 717, 716, 3, 2, 2, 2, 718,
	719, 3, 2, 2, 2, 719, 720, 7, 51, 2, 2, 720, 97, 3, 2, 2, 2, 721, 722,
	5, 94, 48, 2, 722, 99, 3, 2, 2, 2, 723, 726, 7, 42, 2, 2, 724, 727, 5,
	98, 50, 2, 725, 727, 5, 96, 49, 2, 726, 724, 3, 2, 2, 2, 726, 725, 3, 2,
	2, 2, 727, 101, 3, 2, 2, 2, 728, 735, 7, 42, 2, 2, 729, 731, 5, 100, 51,
	2, 730, 729, 3, 2, 2, 2, 731, 732, 3, 2, 2, 2, 732, 730, 3, 2, 2, 2, 732,
	733, 3, 2, 2, 2, 733, 735, 3, 2, 2, 2, 734, 728, 3, 2, 2, 2, 734, 730,
	3, 2, 2, 2, 735, 103, 3, 2, 2, 2, 736, 741, 5, 10, 6, 2, 737, 738, 7, 42,
	2, 2, 738, 740, 5, 10, 6, 2, 739, 737, 3, 2, 2, 2, 740, 743, 3, 2, 2, 2,
	741, 739, 3, 2, 2, 2, 741, 742, 3, 2, 2, 2, 742, 105, 3, 2, 2, 2, 743,
	741, 3, 2, 2, 2, 744, 745, 7, 15, 2, 2, 745, 746, 7, 71, 2, 2, 746, 107,
	3, 2, 2, 2, 747, 748, 5, 74, 38, 2, 748, 109, 3, 2, 2, 2, 749, 750, 5,
	10, 6, 2, 750, 111, 3, 2, 2, 2, 751, 754, 7, 60, 2, 2, 752, 754, 5, 10,
	6, 2, 753, 751, 3, 2, 2, 2, 753, 752, 3, 2, 2, 2, 754, 755, 3, 2, 2, 2,
	755, 753, 3, 2, 2, 2, 755, 756, 3, 2, 2, 2, 756, 764, 3, 2, 2, 2, 757,
	758, 5, 10, 6, 2, 758, 761, 7, 33, 2, 2, 759, 762, 5, 10, 6, 2, 760, 762,
	7, 5, 2, 2, 761, 759, 3, 2, 2, 2, 761, 760, 3, 2, 2, 2, 762, 764, 3, 2,
	2, 2, 763, 753, 3, 2, 2, 2, 763, 757, 3, 2, 2, 2, 764, 113, 3, 2, 2, 2,
	765, 766, 7, 52, 2, 2, 766, 771, 5, 112, 57, 2, 767, 768, 7, 40, 2, 2,
	768, 770, 5, 112, 57, 2, 769, 767, 3, 2, 2, 2, 770, 773, 3, 2, 2, 2, 771,
	769, 3, 2, 2, 2, 771, 772, 3, 2, 2, 2, 772, 774, 3, 2, 2, 2, 773, 771,
	3, 2, 2, 2, 774, 775, 7, 53, 2, 2, 775, 115, 3, 2, 2, 2, 776, 781, 7, 31,
	2, 2, 777, 778, 5, 108, 55, 2, 778, 779, 7, 34, 2, 2, 779, 781, 3, 2, 2,
	2, 780, 776, 3, 2, 2, 2, 780, 777, 3, 2, 2, 2, 781, 782, 3, 2, 2, 2, 782,
	784, 5, 110, 56, 2, 783, 785, 5, 114, 58, 2, 784, 783, 3, 2, 2, 2, 784,
	785, 3, 2, 2, 2, 785, 117, 3, 2, 2, 2, 786, 787, 7, 16, 2, 2, 787, 788,
	7, 67, 2, 2, 788, 789, 7, 43, 2, 2, 789, 793, 7, 3, 2, 2, 790, 792, 5,
	146, 74, 2, 791, 790, 3, 2, 2, 2, 792, 795, 3, 2, 2, 2, 793, 791, 3, 2,
	2, 2, 793, 794, 3, 2, 2, 2, 794, 796, 3, 2, 2, 2, 795, 793, 3, 2, 2, 2,
	796, 797, 7, 4, 2, 2, 797, 119, 3, 2, 2, 2, 798, 800, 7, 20, 2, 2, 799,
	801, 7, 67, 2, 2, 800, 799, 3, 2, 2, 2, 800, 801, 3, 2, 2, 2, 801, 802,
	3, 2, 2, 2, 802, 803, 7, 43, 2, 2, 803, 807, 7, 3, 2, 2, 804, 806, 5, 146,
	74, 2, 805, 804, 3, 2, 2, 2, 806, 809, 3, 2, 2, 2, 807, 805, 3, 2, 2, 2,
	807, 808, 3, 2, 2, 2, 808, 810, 3, 2, 2, 2, 809, 807, 3, 2, 2, 2, 810,
	811, 7, 4, 2, 2, 811, 121, 3, 2, 2, 2, 812, 816, 5, 118, 60, 2, 813, 815,
	5, 120, 61, 2, 814, 813, 3, 2, 2, 2, 815, 818, 3, 2, 2, 2, 816, 814, 3,
	2, 2, 2, 816, 817, 3, 2, 2, 2, 817, 123, 3, 2, 2, 2, 818, 816, 3, 2, 2,
	2, 819, 820, 9, 6, 2, 2, 820, 821, 7, 67, 2, 2, 821, 822, 7, 43, 2, 2,
	822, 826, 7, 3, 2, 2, 823, 825, 5, 146, 74, 2, 824, 823, 3, 2, 2, 2, 825,
	828, 3, 2, 2, 2, 826, 824, 3, 2, 2, 2, 826, 827, 3, 2, 2, 2, 827, 829,
	3, 2, 2, 2, 828, 826, 3, 2, 2, 2, 829, 830, 7, 4, 2, 2, 830, 125, 3, 2,
	2, 2, 831, 832, 7, 62, 2, 2, 832, 127, 3, 2, 2, 2, 833, 834, 5, 10, 6,
	2, 834, 835, 7, 43, 2, 2, 835, 837, 7, 3, 2, 2, 836, 838, 5, 146, 74, 2,
	837, 836, 3, 2, 2, 2, 838, 839, 3, 2, 2, 2, 839, 837, 3, 2, 2, 2, 839,
	840, 3, 2, 2, 2, 840, 841, 3, 2, 2, 2, 841, 842, 7, 4, 2, 2, 842, 129,
	3, 2, 2, 2, 843, 845, 9, 7, 2, 2, 844, 843, 3, 2, 2, 2, 845, 846, 3, 2,
	2, 2, 846, 844, 3, 2, 2, 2, 846, 847, 3, 2, 2, 2, 847, 131, 3, 2, 2, 2,
	848, 850, 5, 130, 66, 2, 849, 848, 3, 2, 2, 2, 849, 850, 3, 2, 2, 2, 850,
	851, 3, 2, 2, 2, 851, 852, 7, 43, 2, 2, 852, 854, 7, 3, 2, 2, 853, 855,
	5, 146, 74, 2, 854, 853, 3, 2, 2, 2, 855, 856, 3, 2, 2, 2, 856, 854, 3,
	2, 2, 2, 856, 857, 3, 2, 2, 2, 857, 858, 3, 2, 2, 2, 858, 859, 7, 4, 2,
	2, 859, 133, 3, 2, 2, 2, 860, 861, 7, 28, 2, 2, 861, 862, 7, 43, 2, 2,
	862, 864, 7, 3, 2, 2, 863, 865, 5, 132, 67, 2, 864, 863, 3, 2, 2, 2, 865,
	866, 3, 2, 2, 2, 866, 864, 3, 2, 2, 2, 866, 867, 3, 2, 2, 2, 867, 868,
	3, 2, 2, 2, 868, 869, 7, 4, 2, 2, 869, 135, 3, 2, 2, 2, 870, 879, 5, 14,
	8, 2, 871, 879, 7, 60, 2, 2, 872, 875, 5, 74, 38, 2, 873, 874, 7, 35, 2,
	2, 874, 876, 5, 10, 6, 2, 875, 873, 3, 2, 2, 2, 875, 876, 3, 2, 2, 2, 876,
	879, 3, 2, 2, 2, 877, 879, 7, 24, 2, 2, 878, 870, 3, 2, 2, 2, 878, 871,
	3, 2, 2, 2, 878, 872, 3, 2, 2, 2, 878, 877, 3, 2, 2, 2, 879, 137, 3, 2,
	2, 2, 880, 881, 7, 29, 2, 2, 881, 882, 5, 74, 38, 2, 882, 139, 3, 2, 2,
	2, 883, 886, 5, 12, 7, 2, 884, 886, 5, 58, 30, 2, 885, 883, 3, 2, 2, 2,
	885, 884, 3, 2, 2, 2, 886, 141, 3, 2, 2, 2, 887, 892, 5, 140, 71, 2, 888,
	889, 7, 40, 2, 2, 889, 891, 5, 140, 71, 2, 890, 888, 3, 2, 2, 2, 891, 894,
	3, 2, 2, 2, 892, 890, 3, 2, 2, 2, 892, 893, 3, 2, 2, 2, 893, 143, 3, 2,
	2, 2, 894, 892, 3, 2, 2, 2, 895, 896, 7, 52, 2, 2, 896, 897, 5, 142, 72,
	2, 897, 898, 7, 53, 2, 2, 898, 145, 3, 2, 2, 2, 899, 909, 5, 122, 62, 2,
	900, 909, 5, 124, 63, 2, 901, 909, 5, 106, 54, 2, 902, 909, 5, 116, 59,
	2, 903, 909, 5, 134, 68, 2, 904, 909, 5, 126, 64, 2, 905, 909, 5, 128,
	65, 2, 906, 909, 5, 136, 69, 2, 907, 909, 5, 48, 25, 2, 908, 899, 3, 2,
	2, 2, 908, 900, 3, 2, 2, 2, 908, 901, 3, 2, 2, 2, 908, 902, 3, 2, 2, 2,
	908, 903, 3, 2, 2, 2, 908, 904, 3, 2, 2, 2, 908, 905, 3, 2, 2, 2, 908,
	906, 3, 2, 2, 2, 908, 907, 3, 2, 2, 2, 909, 911, 3, 2, 2, 2, 910, 912,
	5, 28, 15, 2, 911, 910, 3, 2, 2, 2, 911, 912, 3, 2, 2, 2, 912, 147, 3,
	2, 2, 2, 913, 915, 7, 6, 2, 2, 914, 916, 5, 144, 73, 2, 915, 914, 3, 2,
	2, 2, 915, 916, 3, 2, 2, 2, 916, 918, 3, 2, 2, 2, 917, 919, 5, 92, 47,
	2, 918, 917, 3, 2, 2, 2, 918, 919, 3, 2, 2, 2, 919, 921, 3, 2, 2, 2, 920,
	922, 5, 28, 15, 2, 921, 920, 3, 2, 2, 2, 921, 922, 3, 2, 2, 2, 922, 923,
	3, 2, 2, 2, 923, 924, 7, 43, 2, 2, 924, 926, 7, 3, 2, 2, 925, 927, 5, 146,
	74, 2, 926, 925, 3, 2, 2, 2, 927, 928, 3, 2, 2, 2, 928, 926, 3, 2, 2, 2,
	928, 929, 3, 2, 2, 2, 929, 930, 3, 2, 2, 2, 930, 931, 7, 4, 2, 2, 931,
	149, 3, 2, 2, 2, 932, 933, 7, 24, 2, 2, 933, 151, 3, 2, 2, 2, 934, 958,
	7, 24, 2, 2, 935, 937, 5, 104, 53, 2, 936, 938, 7, 60, 2, 2, 937, 936,
	3, 2, 2, 2, 937, 938, 3, 2, 2, 2, 938, 940, 3, 2, 2, 2, 939, 941, 5, 144,
	73, 2, 940, 939, 3, 2, 2, 2, 940, 941, 3, 2, 2, 2, 941, 943, 3, 2, 2, 2,
	942, 944, 5, 28, 15, 2, 943, 942, 3, 2, 2, 2, 943, 944, 3, 2, 2, 2, 944,
	945, 3, 2, 2, 2, 945, 955, 7, 43, 2, 2, 946, 956, 5, 150, 76, 2, 947, 949,
	7, 3, 2, 2, 948, 950, 5, 146, 74, 2, 949, 948, 3, 2, 2, 2, 950, 951, 3,
	2, 2, 2, 951, 949, 3, 2, 2, 2, 951, 952, 3, 2, 2, 2, 952, 953, 3, 2, 2,
	2, 953, 954, 7, 4, 2, 2, 954, 956, 3, 2, 2, 2, 955, 946, 3, 2, 2, 2, 955,
	947, 3, 2, 2, 2, 956, 958, 3, 2, 2, 2, 957, 934, 3, 2, 2, 2, 957, 935,
	3, 2, 2, 2, 958, 153, 3, 2, 2, 2, 959, 961, 5, 102, 52, 2, 960, 962, 5,
	28, 15, 2, 961, 960, 3, 2, 2, 2, 961, 962, 3, 2, 2, 2, 962, 963, 3, 2,
	2, 2, 963, 964, 7, 43, 2, 2, 964, 967, 7, 3, 2, 2, 965, 968, 5, 148, 75,
	2, 966, 968, 5, 154, 78, 2, 967, 965, 3, 2, 2, 2, 967, 966, 3, 2, 2, 2,
	968, 969, 3, 2, 2, 2, 969, 967, 3, 2, 2, 2, 969, 970, 3, 2, 2, 2, 970,
	971, 3, 2, 2, 2, 971, 972, 7, 4, 2, 2, 972, 155, 3, 2, 2, 2, 973, 974,
	5, 10, 6, 2, 974, 977, 7, 41, 2, 2, 975, 978, 7, 5, 2, 2, 976, 978, 5,
	10, 6, 2, 977, 975, 3, 2, 2, 2, 977, 976, 3, 2, 2, 2, 978, 157, 3, 2, 2,
	2, 979, 980, 7, 45, 2, 2, 980, 985, 5, 156, 79, 2, 981, 982, 7, 47, 2,
	2, 982, 984, 5, 156, 79, 2, 983, 981, 3, 2, 2, 2, 984, 987, 3, 2, 2, 2,
	985, 983, 3, 2, 2, 2, 985, 986, 3, 2, 2, 2, 986, 159, 3, 2, 2, 2, 987,
	985, 3, 2, 2, 2, 988, 989, 5, 108, 55, 2, 989, 990, 7, 34, 2, 2, 990, 991,
	5, 110, 56, 2, 991, 161, 3, 2, 2, 2, 992, 998, 5, 10, 6, 2, 993, 994, 7,
	50, 2, 2, 994, 995, 5, 10, 6, 2, 995, 996, 7, 51, 2, 2, 996, 998, 3, 2,
	2, 2, 997, 992, 3, 2, 2, 2, 997, 993, 3, 2, 2, 2, 998, 163, 3, 2, 2, 2,
	999, 1000, 7, 42, 2, 2, 1000, 1002, 5, 162, 82, 2, 1001, 999, 3, 2, 2,
	2, 1002, 1003, 3, 2, 2, 2, 1003, 1001, 3, 2, 2, 2, 1003, 1004, 3, 2, 2,
	2, 1004, 1006, 3, 2, 2, 2, 1005, 1007, 5, 158, 80, 2, 1006, 1005, 3, 2,
	2, 2, 1006, 1007, 3, 2, 2, 2, 1007, 165, 3, 2, 2, 2, 1008, 1009, 7, 6,
	2, 2, 1009, 1010, 5, 164, 83, 2, 1010, 167, 3, 2, 2, 2, 1011, 1012, 5,
	74, 38, 2, 1012, 169, 3, 2, 2, 2, 1013, 1014, 5, 74, 38, 2, 1014, 171,
	3, 2, 2, 2, 1015, 1016, 5, 170, 86, 2, 1016, 1017, 7, 34, 2, 2, 1017, 1018,
	5, 168, 85, 2, 1018, 1019, 7, 35, 2, 2, 1019, 1020, 5, 10, 6, 2, 1020,
	173, 3, 2, 2, 2, 1021, 1022, 5, 10, 6, 2, 1022, 175, 3, 2, 2, 2, 1023,
	1028, 5, 174, 88, 2, 1024, 1028, 5, 160, 81, 2, 1025, 1028, 5, 166, 84,
	2, 1026, 1028, 5, 172, 87, 2, 1027, 1023, 3, 2, 2, 2, 1027, 1024, 3, 2,
	2, 2, 1027, 1025, 3, 2, 2, 2, 1027, 1026, 3, 2, 2, 2, 1028, 1029, 3, 2,
	2, 2, 1029, 1030, 5, 28, 15, 2, 1030, 177, 3, 2, 2, 2, 1031, 1032, 7, 36,
	2, 2, 1032, 1042, 7, 43, 2, 2, 1033, 1043, 7, 24, 2, 2, 1034, 1036, 7,
	3, 2, 2, 1035, 1037, 5, 176, 89, 2, 1036, 1035, 3, 2, 2, 2, 1037, 1038,
	3, 2, 2, 2, 1038, 1036, 3, 2, 2, 2, 1038, 1039, 3, 2, 2, 2, 1039, 1040,
	3, 2, 2, 2, 1040, 1041, 7, 4, 2, 2, 1041, 1043, 3, 2, 2, 2, 1042, 1033,
	3, 2, 2, 2, 1042, 1034, 3, 2, 2, 2, 1043, 179, 3, 2, 2, 2, 1044, 1045,
	7, 30, 2, 2, 1045, 1047, 5, 10, 6, 2, 1046, 1048, 5, 144, 73, 2, 1047,
	1046, 3, 2, 2, 2, 1047, 1048, 3, 2, 2, 2, 1048, 1050, 3, 2, 2, 2, 1049,
	1051, 5, 28, 15, 2, 1050, 1049, 3, 2, 2, 2, 1050, 1051, 3, 2, 2, 2, 1051,
	1052, 3, 2, 2, 2, 1052, 1062, 7, 43, 2, 2, 1053, 1063, 7, 24, 2, 2, 1054,
	1056, 7, 3, 2, 2, 1055, 1057, 5, 146, 74, 2, 1056, 1055, 3, 2, 2, 2, 1057,
	1058, 3, 2, 2, 2, 1058, 1056, 3, 2, 2, 2, 1058, 1059, 3, 2, 2, 2, 1059,
	1060, 3, 2, 2, 2, 1060, 1061, 7, 4, 2, 2, 1061, 1063, 3, 2, 2, 2, 1062,
	1053, 3, 2, 2, 2, 1062, 1054, 3, 2, 2, 2, 1063, 181, 3, 2, 2, 2, 1064,
	1065, 5, 74, 38, 2, 1065, 1066, 7, 35, 2, 2, 1066, 1068, 5, 10, 6, 2, 1067,
	1069, 5, 28, 15, 2, 1068, 1067, 3, 2, 2, 2, 1068, 1069, 3, 2, 2, 2, 1069,
	1070, 3, 2, 2, 2, 1070, 1080, 7, 43, 2, 2, 1071, 1081, 7, 24, 2, 2, 1072,
	1074, 7, 3, 2, 2, 1073, 1075, 5, 146, 74, 2, 1074, 1073, 3, 2, 2, 2, 1075,
	1076, 3, 2, 2, 2, 1076, 1074, 3, 2, 2, 2, 1076, 1077, 3, 2, 2, 2, 1077,
	1078, 3, 2, 2, 2, 1078, 1079, 7, 4, 2, 2, 1079, 1081, 3, 2, 2, 2, 1080,
	1071, 3, 2, 2, 2, 1080, 1072, 3, 2, 2, 2, 1081, 183, 3, 2, 2, 2, 1082,
	1085, 5, 42, 22, 2, 1083, 1085, 5, 32, 17, 2, 1084, 1082, 3, 2, 2, 2, 1084,
	1083, 3, 2, 2, 2, 1085, 185, 3, 2, 2, 2, 1086, 1087, 9, 8, 2, 2, 1087,
	187, 3, 2, 2, 2, 1088, 1090, 9, 9, 2, 2, 1089, 1091, 7, 89, 2, 2, 1090,
	1089, 3, 2, 2, 2, 1090, 1091, 3, 2, 2, 2, 1091, 1092, 3, 2, 2, 2, 1092,
	1093, 7, 143, 2, 2, 1093, 189, 3, 2, 2, 2, 1094, 1095, 5, 306, 154, 2,
	1095, 191, 3, 2, 2, 2, 1096, 1101, 5, 190, 96, 2, 1097, 1098, 7, 95, 2,
	2, 1098, 1100, 5, 190, 96, 2, 1099, 1097, 3, 2, 2, 2, 1100, 1103, 3, 2,
	2, 2, 1101, 1099, 3, 2, 2, 2, 1101, 1102, 3, 2, 2, 2, 1102, 193, 3, 2,
	2, 2, 1103, 1101, 3, 2, 2, 2, 1104, 1105, 9, 10, 2, 2, 1105, 1107, 7, 93,
	2, 2, 1106, 1108, 5, 192, 97, 2, 1107, 1106, 3, 2, 2, 2, 1107, 1108, 3,
	2, 2, 2, 1108, 1109, 3, 2, 2, 2, 1109, 1110, 7, 94, 2, 2, 1110, 195, 3,
	2, 2, 2, 1111, 1113, 5, 306, 154, 2, 1112, 1114, 9, 11, 2, 2, 1113, 1112,
	3, 2, 2, 2, 1113, 1114, 3, 2, 2, 2, 1114, 197, 3, 2, 2, 2, 1115, 1120,
	5, 196, 99, 2, 1116, 1117, 7, 95, 2, 2, 1117, 1119, 5, 196, 99, 2, 1118,
	1116, 3, 2, 2, 2, 1119, 1122, 3, 2, 2, 2, 1120, 1118, 3, 2, 2, 2, 1120,
	1121, 3, 2, 2, 2, 1121, 199, 3, 2, 2, 2, 1122, 1120, 3, 2, 2, 2, 1123,
	1128, 7, 126, 2, 2, 1124, 1125, 7, 83, 2, 2, 1125, 1126, 5, 184, 93, 2,
	1126, 1127, 7, 84, 2, 2, 1127, 1129, 3, 2, 2, 2, 1128, 1124, 3, 2, 2, 2,
	1128, 1129, 3, 2, 2, 2, 1129, 1130, 3, 2, 2, 2, 1130, 1131, 7, 93, 2, 2,
	1131, 1132, 5, 198, 100, 2, 1132, 1133, 7, 112, 2, 2, 1133, 1134, 7, 143,
	2, 2, 1134, 1135, 7, 94, 2, 2, 1135, 201, 3, 2, 2, 2, 1136, 1137, 7, 127,
	2, 2, 1137, 1139, 7, 93, 2, 2, 1138, 1140, 5, 204, 103, 2, 1139, 1138,
	3, 2, 2, 2, 1139, 1140, 3, 2, 2, 2, 1140, 1141, 3, 2, 2, 2, 1141, 1142,
	5, 192, 97, 2, 1142, 1143, 7, 94, 2, 2, 1143, 203, 3, 2, 2, 2, 1144, 1145,
	7, 143, 2, 2, 1145, 1146, 7, 92, 2, 2, 1146, 205, 3, 2, 2, 2, 1147, 1150,
	7, 120, 2, 2, 1148, 1150, 5, 306, 154, 2, 1149, 1147, 3, 2, 2, 2, 1149,
	1148, 3, 2, 2, 2, 1150, 207, 3, 2, 2, 2, 1151, 1152, 7, 134, 2, 2, 1152,
	1153, 5, 206, 104, 2, 1153, 1154, 7, 108, 2, 2, 1154, 1156, 7, 93, 2, 2,
	1155, 1157, 5, 204, 103, 2, 1156, 1155, 3, 2, 2, 2, 1156, 1157, 3, 2, 2,
	2, 1157, 1158, 3, 2, 2, 2, 1158, 1159, 5, 198, 100, 2, 1159, 1160, 7, 94,
	2, 2, 1160, 209, 3, 2, 2, 2, 1161, 1162, 9, 12, 2, 2, 1162, 211, 3, 2,
	2, 2, 1163, 1164, 5, 210, 106, 2, 1164, 1166, 7, 93, 2, 2, 1165, 1167,
	5, 204, 103, 2, 1166, 1165, 3, 2, 2, 2, 1166, 1167, 3, 2, 2, 2, 1167, 1168,
	3, 2, 2, 2, 1168, 1169, 5, 306, 154, 2, 1169, 1170, 7, 94, 2, 2, 1170,
	213, 3, 2, 2, 2, 1171, 1172, 7, 128, 2, 2, 1172, 1173, 7, 93, 2, 2, 1173,
	1174, 5, 306, 154, 2, 1174, 1175, 7, 94, 2, 2, 1175, 215, 3, 2, 2, 2, 1176,
	1177, 7, 129, 2, 2, 1177, 217, 3, 2, 2, 2, 1178, 1179, 7, 130, 2, 2, 1179,
	219, 3, 2, 2, 2, 1180, 1181, 7, 132, 2, 2, 1181, 221, 3, 2, 2, 2, 1182,
	1184, 7, 144, 2, 2, 1183, 1182, 3, 2, 2, 2, 1183, 1184, 3, 2, 2, 2, 1184,
	1185, 3, 2, 2, 2, 1185, 1186, 7, 143, 2, 2, 1186, 223, 3, 2, 2, 2, 1187,
	1189, 7, 101, 2, 2, 1188, 1187, 3, 2, 2, 2, 1188, 1189, 3, 2, 2, 2, 1189,
	1190, 3, 2, 2, 2, 1190, 1192, 7, 78, 2, 2, 1191, 1193, 9, 13, 2, 2, 1192,
	1191, 3, 2, 2, 2, 1192, 1193, 3, 2, 2, 2, 1193, 1194, 3, 2, 2, 2, 1194,
	1197, 5, 222, 112, 2, 1195, 1196, 7, 113, 2, 2, 1196, 1198, 7, 143, 2,
	2, 1197, 1195, 3, 2, 2, 2, 1197, 1198, 3, 2, 2, 2, 1198, 225, 3, 2, 2,
	2, 1199, 1204, 5, 188, 95, 2, 1200, 1204, 5, 224, 113, 2, 1201, 1204, 5,
	248, 125, 2, 1202, 1204, 7, 143, 2, 2, 1203, 1199, 3, 2, 2, 2, 1203, 1200,
	3, 2, 2, 2, 1203, 1201, 3, 2, 2, 2, 1203, 1202, 3, 2, 2, 2, 1204, 227,
	3, 2, 2, 2, 1205, 1206, 7, 81, 2, 2, 1206, 1211, 7, 143, 2, 2, 1207, 1208,
	7, 95, 2, 2, 1208, 1210, 7, 143, 2, 2, 1209, 1207, 3, 2, 2, 2, 1210, 1213,
	3, 2, 2, 2, 1211, 1209, 3, 2, 2, 2, 1211, 1212, 3, 2, 2, 2, 1212, 1214,
	3, 2, 2, 2, 1213, 1211, 3, 2, 2, 2, 1214, 1215, 7, 82, 2, 2, 1215, 229,
	3, 2, 2, 2, 1216, 1218, 7, 103, 2, 2, 1217, 1216, 3, 2, 2, 2, 1217, 1218,
	3, 2, 2, 2, 1218, 1219, 3, 2, 2, 2, 1219, 1221, 7, 102, 2, 2, 1220, 1222,
	5, 228, 115, 2, 1221, 1220, 3, 2, 2, 2, 1221, 1222, 3, 2, 2, 2, 1222, 1223,
	3, 2, 2, 2, 1223, 1224, 7, 84, 2, 2, 1224, 1225, 5, 226, 114, 2, 1225,
	231, 3, 2, 2, 2, 1226, 1238, 5, 188, 95, 2, 1227, 1238, 5, 200, 101, 2,
	1228, 1238, 5, 202, 102, 2, 1229, 1238, 5, 212, 107, 2, 1230, 1238, 5,
	214, 108, 2, 1231, 1238, 5, 220, 111, 2, 1232, 1238, 5, 216, 109, 2, 1233,
	1238, 5, 218, 110, 2, 1234, 1238, 5, 208, 105, 2, 1235, 1238, 5, 224, 113,
	2, 1236, 1238, 5, 230, 116, 2, 1237, 1226, 3, 2, 2, 2, 1237, 1227, 3, 2,
	2, 2, 1237, 1228, 3, 2, 2, 2, 1237, 1229, 3, 2, 2, 2, 1237, 1230, 3, 2,
	2, 2, 1237, 1231, 3, 2, 2, 2, 1237, 1232, 3, 2, 2, 2, 1237, 1233, 3, 2,
	2, 2, 1237, 1234, 3, 2, 2, 2, 1237, 1235, 3, 2, 2, 2, 1237, 1236, 3, 2,
	2, 2, 1238, 233, 3, 2, 2, 2, 1239, 1240, 5, 306, 154, 2, 1240, 235, 3,
	2, 2, 2, 1241, 1246, 5, 234, 118, 2, 1242, 1243, 7, 95, 2, 2, 1243, 1245,
	5, 234, 118, 2, 1244, 1242, 3, 2, 2, 2, 1245, 1248, 3, 2, 2, 2, 1246, 1244,
	3, 2, 2, 2, 1246, 1247, 3, 2, 2, 2, 1247, 237, 3, 2, 2, 2, 1248, 1246,
	3, 2, 2, 2, 1249, 1250, 7, 86, 2, 2, 1250, 1251, 5, 236, 119, 2, 1251,
	1252, 7, 87, 2, 2, 1252, 239, 3, 2, 2, 2, 1253, 1254, 7, 85, 2, 2, 1254,
	241, 3, 2, 2, 2, 1255, 1266, 7, 144, 2, 2, 1256, 1267, 5, 200, 101, 2,
	1257, 1267, 5, 202, 102, 2, 1258, 1267, 5, 212, 107, 2, 1259, 1267, 5,
	214, 108, 2, 1260, 1267, 5, 220, 111, 2, 1261, 1267, 5, 216, 109, 2, 1262,
	1267, 5, 218, 110, 2, 1263, 1267, 5, 208, 105, 2, 1264, 1267, 5, 224, 113,
	2, 1265, 1267, 5, 230, 116, 2, 1266, 1256, 3, 2, 2, 2, 1266, 1257, 3, 2,
	2, 2, 1266, 1258, 3, 2, 2, 2, 1266, 1259, 3, 2, 2, 2, 1266, 1260, 3, 2,
	2, 2, 1266, 1261, 3, 2, 2, 2, 1266, 1262, 3, 2, 2, 2, 1266, 1263, 3, 2,
	2, 2, 1266, 1264, 3, 2, 2, 2, 1266, 1265, 3, 2, 2, 2, 1267, 243, 3, 2,
	2, 2, 1268, 1273, 5, 242, 122, 2, 1269, 1273, 5, 224, 113, 2, 1270, 1273,
	5, 230, 116, 2, 1271, 1273, 5, 188, 95, 2, 1272, 1268, 3, 2, 2, 2, 1272,
	1269, 3, 2, 2, 2, 1272, 1270, 3, 2, 2, 2, 1272, 1271, 3, 2, 2, 2, 1273,
	245, 3, 2, 2, 2, 1274, 1275, 9, 14, 2, 2, 1275, 247, 3, 2, 2, 2, 1276,
	1277, 7, 93, 2, 2, 1277, 1278, 5, 306, 154, 2, 1278, 1279, 7, 94, 2, 2,
	1279, 249, 3, 2, 2, 2, 1280, 1281, 7, 81, 2, 2, 1281, 1282, 5, 236, 119,
	2, 1282, 1283, 7, 82, 2, 2, 1283, 251, 3, 2, 2, 2, 1284, 1293, 5, 194,
	98, 2, 1285, 1293, 5, 238, 120, 2, 1286, 1293, 5, 250, 126, 2, 1287, 1293,
	5, 240, 121, 2, 1288, 1293, 5, 248, 125, 2, 1289, 1293, 5, 186, 94, 2,
	1290, 1293, 5, 244, 123, 2, 1291, 1293, 5, 246, 124, 2, 1292, 1284, 3,
	2, 2, 2, 1292, 1285, 3, 2, 2, 2, 1292, 1286, 3, 2, 2, 2, 1292, 1287, 3,
	2, 2, 2, 1292, 1288, 3, 2, 2, 2, 1292, 1289, 3, 2, 2, 2, 1292, 1290, 3,
	2, 2, 2, 1292, 1291, 3, 2, 2, 2, 1293, 253, 3, 2, 2, 2, 1294, 1298, 5,
	252, 127, 2, 1295, 1297, 5, 232, 117, 2, 1296, 1295, 3, 2, 2, 2, 1297,
	1300, 3, 2, 2, 2, 1298, 1296, 3, 2, 2, 2, 1298, 1299, 3, 2, 2, 2, 1299,
	255, 3, 2, 2, 2, 1300, 1298, 3, 2, 2, 2, 1301, 1302, 7, 90, 2, 2, 1302,
	1303, 5, 260, 131, 2, 1303, 257, 3, 2, 2, 2, 1304, 1306, 5, 254, 128, 2,
	1305, 1307, 5, 256, 129, 2, 1306, 1305, 3, 2, 2, 2, 1306, 1307, 3, 2, 2,
	2, 1307, 259, 3, 2, 2, 2, 1308, 1310, 9, 15, 2, 2, 1309, 1308, 3, 2, 2,
	2, 1309, 1310, 3, 2, 2, 2, 1310, 1311, 3, 2, 2, 2, 1311, 1312, 5, 258,
	130, 2, 1312, 261, 3, 2, 2, 2, 1313, 1314, 9, 16, 2, 2, 1314, 1315, 5,
	260, 131, 2, 1315, 263, 3, 2, 2, 2, 1316, 1320, 5, 260, 131, 2, 1317, 1319,
	5, 262, 132, 2, 1318, 1317, 3, 2, 2, 2, 1319, 1322, 3, 2, 2, 2, 1320, 1318,
	3, 2, 2, 2, 1320, 1321, 3, 2, 2, 2, 1321, 265, 3, 2, 2, 2, 1322, 1320,
	3, 2, 2, 2, 1323, 1324, 9, 17, 2, 2, 1324, 1325, 5, 264, 133, 2, 1325,
	267, 3, 2, 2, 2, 1326, 1330, 5, 264, 133, 2, 1327, 1329, 5, 266, 134, 2,
	1328, 1327, 3, 2, 2, 2, 1329, 1332, 3, 2, 2, 2, 1330, 1328, 3, 2, 2, 2,
	1330, 1331, 3, 2, 2, 2, 1331, 269, 3, 2, 2, 2, 1332, 1330, 3, 2, 2, 2,
	1333, 1334, 9, 18, 2, 2, 1334, 271, 3, 2, 2, 2, 1335, 1341, 5, 268, 135,
	2, 1336, 1337, 5, 270, 136, 2, 1337, 1338, 5, 268, 135, 2, 1338, 1340,
	3, 2, 2, 2, 1339, 1336, 3, 2, 2, 2, 1340, 1343, 3, 2, 2, 2, 1341, 1339,
	3, 2, 2, 2, 1341, 1342, 3, 2, 2, 2, 1342, 273, 3, 2, 2, 2, 1343, 1341,
	3, 2, 2, 2, 1344, 1349, 5, 272, 137, 2, 1345, 1346, 9, 19, 2, 2, 1346,
	1348, 5, 272, 137, 2, 1347, 1345, 3, 2, 2, 2, 1348, 1351, 3, 2, 2, 2, 1349,
	1347, 3, 2, 2, 2, 1349, 1350, 3, 2, 2, 2, 1350, 275, 3, 2, 2, 2, 1351,
	1349, 3, 2, 2, 2, 1352, 1357, 5, 274, 138, 2, 1353, 1354, 7, 104, 2, 2,
	1354, 1356, 5, 274, 138, 2, 1355, 1353, 3, 2, 2, 2, 1356, 1359, 3, 2, 2,
	2, 1357, 1355, 3, 2, 2, 2, 1357, 1358, 3, 2, 2, 2, 1358, 277, 3, 2, 2,
	2, 1359, 1357, 3, 2, 2, 2, 1360, 1365, 5, 276, 139, 2, 1361, 1362, 7, 110,
	2, 2, 1362, 1364, 5, 276, 139, 2, 1363, 1361, 3, 2, 2, 2, 1364, 1367, 3,
	2, 2, 2, 1365, 1363, 3, 2, 2, 2, 1365, 1366, 3, 2, 2, 2, 1366, 279, 3,
	2, 2, 2, 1367, 1365, 3, 2, 2, 2, 1368, 1373, 5, 278, 140, 2, 1369, 1370,
	7, 106, 2, 2, 1370, 1372, 5, 278, 140, 2, 1371, 1369, 3, 2, 2, 2, 1372,
	1375, 3, 2, 2, 2, 1373, 1371, 3, 2, 2, 2, 1373, 1374, 3, 2, 2, 2, 1374,
	281, 3, 2, 2, 2, 1375, 1373, 3, 2, 2, 2, 1376, 1381, 5, 280, 141, 2, 1377,
	1378, 7, 105, 2, 2, 1378, 1380, 5, 280, 141, 2, 1379, 1377, 3, 2, 2, 2,
	1380, 1383, 3, 2, 2, 2, 1381, 1379, 3, 2, 2, 2, 1381, 1382, 3, 2, 2, 2,
	1382, 283, 3, 2, 2, 2, 1383, 1381, 3, 2, 2, 2, 1384, 1389, 5, 282, 142,
	2, 1385, 1386, 7, 121, 2, 2, 1386, 1388, 5, 282, 142, 2, 1387, 1385, 3,
	2, 2, 2, 1388, 1391, 3, 2, 2, 2, 1389, 1387, 3, 2, 2, 2, 1389, 1390, 3,
	2, 2, 2, 1390, 285, 3, 2, 2, 2, 1391, 1389, 3, 2, 2, 2, 1392, 1397, 5,
	284, 143, 2, 1393, 1394, 7, 91, 2, 2, 1394, 1396, 5, 284, 143, 2, 1395,
	1393, 3, 2, 2, 2, 1396, 1399, 3, 2, 2, 2, 1397, 1395, 3, 2, 2, 2, 1397,
	1398, 3, 2, 2, 2, 1398, 287, 3, 2, 2, 2, 1399, 1397, 3, 2, 2, 2, 1400,
	1402, 5, 306, 154, 2, 1401, 1403, 7, 101, 2, 2, 1402, 1401, 3, 2, 2, 2,
	1402, 1403, 3, 2, 2, 2, 1403, 1404, 3, 2, 2, 2, 1404, 1405, 7, 115, 2,
	2, 1405, 1406, 5, 306, 154, 2, 1406, 1407, 7, 116, 2, 2, 1407, 1408, 5,
	306, 154, 2, 1408, 289, 3, 2, 2, 2, 1409, 1410, 5, 306, 154, 2, 1410, 1411,
	8, 146, 1, 2, 1411, 291, 3, 2, 2, 2, 1412, 1413, 5, 306, 154, 2, 1413,
	293, 3, 2, 2, 2, 1414, 1419, 5, 292, 147, 2, 1415, 1416, 7, 95, 2, 2, 1416,
	1418, 5, 292, 147, 2, 1417, 1415, 3, 2, 2, 2, 1418, 1421, 3, 2, 2, 2, 1419,
	1417, 3, 2, 2, 2, 1419, 1420, 3, 2, 2, 2, 1420, 295, 3, 2, 2, 2, 1421,
	1419, 3, 2, 2, 2, 1422, 1423, 5, 294, 148, 2, 1423, 1424, 7, 77, 2, 2,
	1424, 1427, 5, 290, 146, 2, 1425, 1428, 6, 149, 2, 3, 1426, 1428, 7, 147,
	2, 2, 1427, 1425, 3, 2, 2, 2, 1427, 1426, 3, 2, 2, 2, 1428, 297, 3, 2,
	2, 2, 1429, 1430, 7, 116, 2, 2, 1430, 1433, 5, 306, 154, 2, 1431, 1434,
	6, 150, 3, 3, 1432, 1434, 7, 147, 2, 2, 1433, 1431, 3, 2, 2, 2, 1433, 1432,
	3, 2, 2, 2, 1434, 299, 3, 2, 2, 2, 1435, 1436, 5, 306, 154, 2, 1436, 1437,
	7, 79, 2, 2, 1437, 301, 3, 2, 2, 2, 1438, 1440, 5, 300, 151, 2, 1439, 1438,
	3, 2, 2, 2, 1439, 1440, 3, 2, 2, 2, 1440, 1441, 3, 2, 2, 2, 1441, 1442,
	7, 92, 2, 2, 1442, 1443, 7, 147, 2, 2, 1443, 1445, 7, 3, 2, 2, 1444, 1446,
	5, 296, 149, 2, 1445, 1444, 3, 2, 2, 2, 1446, 1447, 3, 2, 2, 2, 1447, 1445,
	3, 2, 2, 2, 1447, 1448, 3, 2, 2, 2, 1448, 1450, 3, 2, 2, 2, 1449, 1451,
	5, 298, 150, 2, 1450, 1449, 3, 2, 2, 2, 1450, 1451, 3, 2, 2, 2, 1451, 1452,
	3, 2, 2, 2, 1452, 1453, 7, 4, 2, 2, 1453, 303, 3, 2, 2, 2, 1454, 1459,
	7, 114, 2, 2, 1455, 1460, 5, 288, 145, 2, 1456, 1457, 5, 302, 152, 2, 1457,
	1458, 8, 153, 1, 2, 1458, 1460, 3, 2, 2, 2, 1459, 1455, 3, 2, 2, 2, 1459,
	1456, 3, 2, 2, 2, 1460, 305, 3, 2, 2, 2, 1461, 1462, 5, 304, 153, 2, 1462,
	1463, 8, 154, 1, 2, 1463, 1466, 3, 2, 2, 2, 1464, 1466, 5, 286, 144, 2,
	1465, 1461, 3, 2, 2, 2, 1465, 1464, 3, 2, 2, 2, 1466, 307, 3, 2, 2, 2,
	1467, 1474, 7, 96, 2, 2, 1468, 1469, 5, 306, 154, 2, 1469, 1470, 8, 155,
	1, 2, 1470, 1475, 3, 2, 2, 2, 1471, 1472, 5, 338, 170, 2, 1472, 1473, 8,
	155, 1, 2, 1473, 1475, 3, 2, 2, 2, 1474, 1468, 3, 2, 2, 2, 1474, 1471,
	3, 2, 2, 2, 1475, 309, 3, 2, 2, 2, 1476, 1477, 7, 143, 2, 2, 1477, 1478,
	5, 308, 155, 2, 1478, 1479, 8, 156, 1, 2, 1479, 311, 3, 2, 2, 2, 1480,
	1481, 7, 117, 2, 2, 1481, 1482, 7, 143, 2, 2, 1482, 1483, 5, 308, 155,
	2, 1483, 1484, 8, 157, 1, 2, 1484, 313, 3, 2, 2, 2, 1485, 1486, 7, 89,
	2, 2, 1486, 1487, 7, 143, 2, 2, 1487, 1488, 5, 308, 155, 2, 1488, 1489,
	8, 158, 1, 2, 1489, 315, 3, 2, 2, 2, 1490, 1491, 7, 142, 2, 2, 1491, 317,
	3, 2, 2, 2, 1492, 1493, 5, 316, 159, 2, 1493, 319, 3, 2, 2, 2, 1494, 1504,
	7, 149, 2, 2, 1495, 1499, 7, 136, 2, 2, 1496, 1498, 5, 306, 154, 2, 1497,
	1496, 3, 2, 2, 2, 1498, 1501, 3, 2, 2, 2, 1499, 1497, 3, 2, 2, 2, 1499,
	1500, 3, 2, 2, 2, 1500, 1502, 3, 2, 2, 2, 1501, 1499, 3, 2, 2, 2, 1502,
	1504, 7, 137, 2, 2, 1503, 1494, 3, 2, 2, 2, 1503, 1495, 3, 2, 2, 2, 1504,
	321, 3, 2, 2, 2, 1505, 1507, 7, 137, 2, 2, 1506, 1508, 7, 150, 2, 2, 1507,
	1506, 3, 2, 2, 2, 1507, 1508, 3, 2, 2, 2, 1508, 1512, 3, 2, 2, 2, 1509,
	1511, 5, 320, 161, 2, 1510, 1509, 3, 2, 2, 2, 1511, 1514, 3, 2, 2, 2, 1512,
	1510, 3, 2, 2, 2, 1512, 1513, 3, 2, 2, 2, 1513, 1515, 3, 2, 2, 2, 1514,
	1512, 3, 2, 2, 2, 1515, 1516, 7, 147, 2, 2, 1516, 323, 3, 2, 2, 2, 1517,
	1518, 5, 312, 157, 2, 1518, 1519, 8, 163, 1, 2, 1519, 1527, 3, 2, 2, 2,
	1520, 1521, 5, 314, 158, 2, 1521, 1522, 8, 163, 1, 2, 1522, 1527, 3, 2,
	2, 2, 1523, 1524, 5, 310, 156, 2, 1524, 1525, 8, 163, 1, 2, 1525, 1527,
	3, 2, 2, 2, 1526, 1517, 3, 2, 2, 2, 1526, 1520, 3, 2, 2, 2, 1526, 1523,
	3, 2, 2, 2, 1527, 1530, 3, 2, 2, 2, 1528, 1531, 6, 163, 4, 3, 1529, 1531,
	7, 147, 2, 2, 1530, 1528, 3, 2, 2, 2, 1530, 1529, 3, 2, 2, 2, 1531, 325,
	3, 2, 2, 2, 1532, 1533, 5, 194, 98, 2, 1533, 1534, 7, 144, 2, 2, 1534,
	1535, 7, 111, 2, 2, 1535, 1536, 7, 147, 2, 2, 1536, 327, 3, 2, 2, 2, 1537,
	1541, 5, 318, 160, 2, 1538, 1541, 5, 324, 163, 2, 1539, 1541, 5, 326, 164,
	2, 1540, 1537, 3, 2, 2, 2, 1540, 1538, 3, 2, 2, 2, 1540, 1539, 3, 2, 2,
	2, 1541, 329, 3, 2, 2, 2, 1542, 1546, 5, 34, 18, 2, 1543, 1546, 5, 38,
	20, 2, 1544, 1546, 5, 184, 93, 2, 1545, 1542, 3, 2, 2, 2, 1545, 1543, 3,
	2, 2, 2, 1545, 1544, 3, 2, 2, 2, 1546, 331, 3, 2, 2, 2, 1547, 1548, 5,
	184, 93, 2, 1548, 333, 3, 2, 2, 2, 1549, 1550, 7, 143, 2, 2, 1550, 335,
	3, 2, 2, 2, 1551, 1552, 5, 306, 154, 2, 1552, 337, 3, 2, 2, 2, 1553, 1555,
	5, 336, 169, 2, 1554, 1553, 3, 2, 2, 2, 1554, 1555, 3, 2, 2, 2, 1555, 1556,
	3, 2, 2, 2, 1556, 1561, 7, 78, 2, 2, 1557, 1558, 7, 83, 2, 2, 1558, 1559,
	5, 330, 166, 2, 1559, 1560, 7, 84, 2, 2, 1560, 1562, 3, 2, 2, 2, 1561,
	1557, 3, 2, 2, 2, 1561, 1562, 3, 2, 2, 2, 1562, 1563, 3, 2, 2, 2, 1563,
	1565, 7, 93, 2, 2, 1564, 1566, 5, 334, 168, 2, 1565, 1564, 3, 2, 2, 2,
	1565, 1566, 3, 2, 2, 2, 1566, 1567, 3, 2, 2, 2, 1567, 1568, 7, 92, 2, 2,
	1568, 1569, 7, 147, 2, 2, 1569, 1572, 7, 3, 2, 2, 1570, 1573, 5, 328, 165,
	2, 1571, 1573, 5, 322, 162, 2, 1572, 1570, 3, 2, 2, 2, 1572, 1571, 3, 2,
	2, 2, 1573, 1574, 3, 2, 2, 2, 1574, 1572, 3, 2, 2, 2, 1574, 1575, 3, 2,
	2, 2, 1575, 1576, 3, 2, 2, 2, 1576, 1577, 7, 4, 2, 2, 1577, 1578, 7, 94,
	2, 2, 1578, 1579, 7, 147, 2, 2, 1579, 339, 3, 2, 2, 2, 1580, 1581, 7, 3,
	2, 2, 1581, 1582, 5, 338, 170, 2, 1582, 1583, 7, 4, 2, 2, 1583, 341, 3,
	2, 2, 2, 1584, 1585, 5, 10, 6, 2, 1585, 1586, 7, 33, 2, 2, 1586, 1587,
	5, 184, 93, 2, 1587, 343, 3, 2, 2, 2, 1588, 1593, 5, 342, 172, 2, 1589,
	1590, 7, 40, 2, 2, 1590, 1592, 5, 342, 172, 2, 1591, 1589, 3, 2, 2, 2,
	1592, 1595, 3, 2, 2, 2, 1593, 1591, 3, 2, 2, 2, 1593, 1594, 3, 2, 2, 2,
	1594, 345, 3, 2, 2, 2, 1595, 1593, 3, 2, 2, 2, 1596, 1597, 7, 38, 2, 2,
	1597, 347, 3, 2, 2, 2, 1598, 1599, 7, 12, 2, 2, 1599, 1600, 5, 10, 6, 2,
	1600, 1601, 7, 52, 2, 2, 1601, 1602, 5, 344, 173, 2, 1602, 1605, 7, 53,
	2, 2, 1603, 1604, 7, 35, 2, 2, 1604, 1606, 5, 332, 167, 2, 1605, 1603,
	3, 2, 2, 2, 1605, 1606, 3, 2, 2, 2, 1606, 1615, 3, 2, 2, 2, 1607, 1609,
	5, 28, 15, 2, 1608, 1607, 3, 2, 2, 2, 1608, 1609, 3, 2, 2, 2, 1609, 1610,
	3, 2, 2, 2, 1610, 1611, 7, 43, 2, 2, 1611, 1616, 5, 340, 171, 2, 1612,
	1613, 5, 346, 174, 2, 1613, 1614, 8, 175, 1, 2, 1614, 1616, 3, 2, 2, 2,
	1615, 1608, 3, 2, 2, 2, 1615, 1612, 3, 2, 2, 2, 1616, 349, 3, 2, 2, 2,
	1617, 1618, 7, 10, 2, 2, 1618, 1620, 5, 10, 6, 2, 1619, 1621, 5, 28, 15,
	2, 1620, 1619, 3, 2, 2, 2, 1620, 1621, 3, 2, 2, 2, 1621, 1622, 3, 2, 2,
	2, 1622, 1646, 7, 43, 2, 2, 1623, 1625, 5, 48, 25, 2, 1624, 1623, 3, 2,
	2, 2, 1625, 1628, 3, 2, 2, 2, 1626, 1624, 3, 2, 2, 2, 1626, 1627, 3, 2,
	2, 2, 1627, 1631, 3, 2, 2, 2, 1628, 1626, 3, 2, 2, 2, 1629, 1632, 5, 32,
	17, 2, 1630, 1632, 5, 42, 22, 2, 1631, 1629, 3, 2, 2, 2, 1631, 1630, 3,
	2, 2, 2, 1632, 1647, 3, 2, 2, 2, 1633, 1637, 7, 3, 2, 2, 1634, 1636, 5,
	48, 25, 2, 1635, 1634, 3, 2, 2, 2, 1636, 1639, 3, 2, 2, 2, 1637, 1635,
	3, 2, 2, 2, 1637, 1638, 3, 2, 2, 2, 1638, 1642, 3, 2, 2, 2, 1639, 1637,
	3, 2, 2, 2, 1640, 1643, 5, 32, 17, 2, 1641, 1643, 5, 42, 22, 2, 1642, 1640,
	3, 2, 2, 2, 1642, 1641, 3, 2, 2, 2, 1643, 1644, 3, 2, 2, 2, 1644, 1645,
	7, 4, 2, 2, 1645, 1647, 3, 2, 2, 2, 1646, 1626, 3, 2, 2, 2, 1646, 1633,
	3, 2, 2, 2, 1647, 351, 3, 2, 2, 2, 1648, 1664, 7, 3, 2, 2, 1649, 1665,
	5, 350, 176, 2, 1650, 1665, 5, 48, 25, 2, 1651, 1665, 5, 178, 90, 2, 1652,
	1665, 5, 180, 91, 2, 1653, 1665, 5, 84, 43, 2, 1654, 1665, 5, 138, 70,
	2, 1655, 1665, 5, 154, 78, 2, 1656, 1665, 5, 152, 77, 2, 1657, 1665, 5,
	182, 92, 2, 1658, 1665, 7, 62, 2, 2, 1659, 1665, 5, 68, 35, 2, 1660, 1661,
	5, 348, 175, 2, 1661, 1662, 8, 177, 1, 2, 1662, 1665, 3, 2, 2, 2, 1663,
	1665, 5, 66, 34, 2, 1664, 1649, 3, 2, 2, 2, 1664, 1650, 3, 2, 2, 2, 1664,
	1651, 3, 2, 2, 2, 1664, 1652, 3, 2, 2, 2, 1664, 1653, 3, 2, 2, 2, 1664,
	1654, 3, 2, 2, 2, 1664, 1655, 3, 2, 2, 2, 1664, 1656, 3, 2, 2, 2, 1664,
	1657, 3, 2, 2, 2, 1664, 1658, 3, 2, 2, 2, 1664, 1659, 3, 2, 2, 2, 1664,
	1660, 3, 2, 2, 2, 1664, 1663, 3, 2, 2, 2, 1665, 1666, 3, 2, 2, 2, 1666,
	1664, 3, 2, 2, 2, 1666, 1667, 3, 2, 2, 2, 1667, 1670, 3, 2, 2, 2, 1668,
	1671, 6, 177, 5, 3, 1669, 1671, 7, 4, 2, 2, 1670, 1668, 3, 2, 2, 2, 1670,
	1669, 3, 2, 2, 2, 1671, 353, 3, 2, 2, 2, 1672, 1674, 7, 62, 2, 2, 1673,
	1672, 3, 2, 2, 2, 1674, 1677, 3, 2, 2, 2, 1675, 1673, 3, 2, 2, 2, 1675,
	1676, 3, 2, 2, 2, 1676, 1678, 3, 2, 2, 2, 1677, 1675, 3, 2, 2, 2, 1678,
	1679, 5, 76, 39, 2, 1679, 1680, 7, 43, 2, 2, 1680, 1681, 5, 352, 177, 2,
	1681, 355, 3, 2, 2, 2, 1682, 1683, 7, 39, 2, 2, 1683, 1684, 7, 64, 2, 2,
	1684, 357, 3, 2, 2, 2, 1685, 1686, 7, 13, 2, 2, 1686, 1696, 7, 148, 2,
	2, 1687, 1688, 7, 14, 2, 2, 1688, 1693, 7, 64, 2, 2, 1689, 1690, 7, 44,
	2, 2, 1690, 1692, 7, 64, 2, 2, 1691, 1689, 3, 2, 2, 2, 1692, 1695, 3, 2,
	2, 2, 1693, 1691, 3, 2, 2, 2, 1693, 1694, 3, 2, 2, 2, 1694, 1697, 3, 2,
	2, 2, 1695, 1693, 3, 2, 2, 2, 1696, 1687, 3, 2, 2, 2, 1696, 1697, 3, 2,
	2, 2, 1697, 1701, 3, 2, 2, 2, 1698, 1700, 7, 65, 2, 2, 1699, 1698, 3, 2,
	2, 2, 1700, 1703, 3, 2, 2, 2, 1701, 1699, 3, 2, 2, 2, 1701, 1702, 3, 2,
	2, 2, 1702, 1705, 3, 2, 2, 2, 1703, 1701, 3, 2, 2, 2, 1704, 1706, 5, 356,
	179, 2, 1705, 1704, 3, 2, 2, 2, 1705, 1706, 3, 2, 2, 2, 1706, 1714, 3,
	2, 2, 2, 1707, 1709, 7, 62, 2, 2, 1708, 1707, 3, 2, 2, 2, 1709, 1712, 3,
	2, 2, 2, 1710, 1708, 3, 2, 2, 2, 1710, 1711, 3, 2, 2, 2, 1711, 1715, 3,
	2, 2, 2, 1712, 1710, 3, 2, 2, 2, 1713, 1715, 7, 61, 2, 2, 1714, 1710, 3,
	2, 2, 2, 1714, 1713, 3, 2, 2, 2, 1715, 359, 3, 2, 2, 2, 1716, 1718, 5,
	358, 180, 2, 1717, 1716, 3, 2, 2, 2, 1718, 1719, 3, 2, 2, 2, 1719, 1717,
	3, 2, 2, 2, 1719, 1720, 3, 2, 2, 2, 1720, 361, 3, 2, 2, 2, 1721, 1723,
	5, 360, 181, 2, 1722, 1721, 3, 2, 2, 2, 1722, 1723, 3, 2, 2, 2, 1723, 1725,
	3, 2, 2, 2, 1724, 1726, 5, 354, 178, 2, 1725, 1724, 3, 2, 2, 2, 1726, 1727,
	3, 2, 2, 2, 1727, 1725, 3, 2, 2, 2, 1727, 1728, 3, 2, 2, 2, 1728, 1729,
	3, 2, 2, 2, 1729, 1730, 7, 2, 2, 3, 1730, 363, 3, 2, 2, 2, 193, 370, 377,
	386, 400, 413, 424, 434, 442, 449, 457, 467, 471, 476, 480, 485, 489, 496,
	503, 514, 522, 524, 527, 530, 534, 540, 548, 554, 559, 562, 564, 574, 576,
	581, 586, 591, 601, 607, 616, 618, 621, 632, 637, 640, 649, 653, 660, 665,
	674, 693, 696, 704, 709, 717, 726, 732, 734, 741, 753, 755, 761, 763, 771,
	780, 784, 793, 800, 807, 816, 826, 839, 846, 849, 856, 866, 875, 878, 885,
	892, 908, 911, 915, 918, 921, 928, 937, 940, 943, 951, 955, 957, 961, 967,
	969, 977, 985, 997, 1003, 1006, 1027, 1038, 1042, 1047, 1050, 1058, 1062,
	1068, 1076, 1080, 1084, 1090, 1101, 1107, 1113, 1120, 1128, 1139, 1149,
	1156, 1166, 1183, 1188, 1192, 1197, 1203, 1211, 1217, 1221, 1237, 1246,
	1266, 1272, 1292, 1298, 1306, 1309, 1320, 1330, 1341, 1349, 1357, 1365,
	1373, 1381, 1389, 1397, 1402, 1419, 1427, 1433, 1439, 1447, 1450, 1459,
	1465, 1474, 1499, 1503, 1507, 1512, 1526, 1530, 1540, 1545, 1554, 1561,
	1565, 1572, 1574, 1593, 1605, 1608, 1615, 1620, 1626, 1631, 1637, 1642,
	1646, 1664, 1666, 1670, 1675, 1693, 1696, 1701, 1705, 1710, 1714, 1719,
	1722, 1727,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "", "", "", "", "'!wrap'", "'!table'", "'!type'", "'!alias'", "'!union'",
	"'!view'", "", "", "", "", "", "", "", "", "", "", "", "", "'..'", "",
	"", "", "", "'<->'", "", "", "", "", "", "'.. * <- *'", "", "", "", "",
	"", "", "", "", "", "'@'", "", "", "", "", "", "", "", "", "'#'", "'|'",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "'=>'", "'->'", "'=='", "", "", "", "'<'", "'>'", "'{:}'", "",
	"", "'?.'", "", "'**'", "", "", "", "", "", "", "", "", "'%'", "'-'", "",
	"", "", "", "'||'", "'&&'", "", "'by'", "'and'", "", "'*'", "'as'", "'via'",
	"'if'", "'then'", "'else'", "'let'", "'true'", "'false'", "'null'", "",
	"", "", "'asc'", "'desc'", "'rank'", "", "'any'", "", "'snapshot'", "'where'",
	"'count'", "'flatten'", "'first'",
}
var symbolicNames = []string{
	"", "INDENT", "DEDENT", "NativeDataTypes", "HTTP_VERBS", "WRAP", "TABLE",
	"TYPE", "ALIAS", "UNION", "VIEW", "IMPORT", "AS", "RETURN", "IF", "FOR_EACH",
	"FOR", "UNTIL", "ELSE", "LOOP", "ALT", "WHILE", "WHATEVER", "DOTDOT", "SEQUENCE_OF",
	"SET_OF", "ONE_OF", "MIXIN", "DISTANCE", "DOT_ARROW", "NAME_SEP", "LESS_COLON",
	"ARROW_LEFT", "ARROW_RIGHT", "COLLECTOR", "PLUS", "ABSTRACT", "TILDE",
	"COMMA", "EQ", "FORWARD_SLASH", "COLON", "DOT", "QN", "AT", "AMP", "SQ_OPEN",
	"SQ_CLOSE", "CURLY_OPEN", "CURLY_CLOSE", "OPEN_PAREN", "CLOSE_PAREN", "EMPTY_COMMENT",
	"HASH", "PIPE", "EMPTY_LINE", "INDENTED_COMMENT", "DIGITS", "QSTRING",
	"NEWLINE", "SYSL_COMMENT", "TEXT_LINE", "Name", "WS", "ErrorChar", "PREDICATE_VALUE",
	"SKIP_WS_ARG", "TEXT_VALUE", "NEWLINE_2", "TEXT", "POP_WS", "VAR_NAME",
	"E_NativeDataTypes", "E_INDENTED_COMMENT", "E_WHATEVER", "E_EQ_RIGHT",
	"E_ARROW_RIGHT", "E_DOUBLE_EQ", "E_REL", "E_SQ_OPEN", "E_SQ_CLOSE", "E_ANGLE_OPEN",
	"E_ANGLE_CLOSE", "E_EMPTY_TUPLE", "E_CURLY_OPEN", "E_CURLY_CLOSE", "E_NULLSAFE_DOT",
	"E_TABLE_OF", "E_POW", "E_COALESCE", "E_COLON", "E_OPEN_PAREN", "E_CLOSE_PAREN",
	"E_COMMA", "E_EQ", "E_PLUS", "E_DIVIDE", "E_MOD", "E_MINUS", "E_QN", "E_TILDE",
	"E_NOT", "E_XOR", "E_LOGIC_OR", "E_DOUBLE_AMP", "E_AMP", "E_BY", "E_AND",
	"E_BITOR", "E_STAR", "E_AS", "E_VIA", "E_IF", "E_THEN", "E_ELSE", "E_LET",
	"E_TRUE", "E_FALSE", "E_NULL", "E_BUTNOT", "E_SEQUENCE_OF", "E_SET_OF",
	"E_ASC", "E_DESC", "E_RELOPS_RANK", "E_RELOPS_AGG", "E_RELOPS_ANY", "E_RELOPS_SINGLE_NULL",
	"E_RELOPS_SNAPSHOT", "E_RELOPS_WHERE", "E_RELOPS_COUNT", "E_RELOPS_FLATTEN",
	"E_RELOPS_FIRST", "E_FUNC", "E_RAW_TEXT_END", "E_RAW_TEXT_START", "E_STRING_DBL",
	"E_STRING_SINGLE", "E_DECIMAL", "E_DIGITS", "E_DOT_NAME_NL", "E_Name",
	"E_DOT", "E_WS", "E_EMPTY_LINE", "E_NL", "IMPORT_PATH", "TMPL_TEXT", "TMPL_DEBUG",
}

var ruleNames = []string{
	"modifier", "size_spec", "modifier_list", "modifiers", "name_str", "reference",
	"doc_string", "quoted_string", "array_of_strings", "array_of_arrays", "nvp",
	"attributes", "entry", "attribs_or_modifiers", "user_defined_type", "types",
	"set_of", "set_type", "sequence_of", "sequence_type", "collection_type",
	"multi_line_docstring", "annotation_value", "annotation", "annotations",
	"field_type", "array_size", "inplace_tuple", "field", "inplace_table",
	"table_stmts", "table_def", "table", "union", "package_name", "sub_package",
	"app_name", "name_with_attribs", "model_name", "inplace_table_def", "table_refs",
	"facade", "documentation_stmts", "var_in_curly", "query_var", "query_param",
	"http_path_part", "http_path_var_with_type", "http_path_static", "http_path_suffix",
	"http_path", "endpoint_name", "ret_stmt", "target", "target_endpoint",
	"call_arg", "call_args", "call_stmt", "if_stmt", "else_stmt", "if_else",
	"for_stmt", "http_method_comment", "group_stmt", "one_of_case_label", "one_of_cases",
	"one_of_stmt", "text_stmt", "mixin", "param", "param_list", "params", "statements",
	"method_def", "shortcut", "simple_endpoint", "rest_endpoint", "collector_query_var",
	"collector_query_param", "collector_call_stmt", "collector_http_stmt_part",
	"collector_http_stmt_suffix", "collector_http_stmt", "publisher", "subscriber",
	"collector_pubsub_call", "collector_action_stmt", "collector_stmts", "collector",
	"event", "subscribe", "view_type_spec", "literal", "expr_table_of_op",
	"func_arg", "func_args", "expr_func", "rank_expr", "rank_expr_list", "expr_rank_func",
	"expr_agg_func", "e_scope_var", "first_func_target", "expr_first_func",
	"e_single_arg_func", "expr_single_arg_func", "expr_any_func", "expr_single_or_null",
	"expr_snapshot", "expr_count", "expr_navigate_attr", "expr_navigate", "matching_rhs",
	"squiggly_args", "expr_matching", "relop", "list_item", "expr_list", "expr_set",
	"empty_tuple", "atom_dot_relop", "atomT_implied_dot", "atomT_name", "atomT_paren",
	"expr_atom_list", "atomT", "atom", "powerT", "power", "unaryTerm", "termT",
	"term", "binexprT", "binexpr", "e_compare_ops", "expr_rel", "expr_bitand",
	"expr_bitxor", "expr_bitor", "expr_and", "expr_or", "expr_but_not", "expr_coalesce",
	"if_one_liner", "else_block_stmt", "control_item", "if_controls", "cond_block",
	"final_else", "ifvar", "if_multiple_lines", "expr_if_else", "expr", "expr_assign",
	"expr_simple_assign", "expr_let_statement", "expr_table_of_statement",
	"expr_dot_assign", "expr_statement_no_nl", "template_expression", "template_statement",
	"expr_statement", "expr_inject_stmt", "expr_stmt", "transform_return_type",
	"view_return_type", "transform_scope_var", "transform_arg", "transform",
	"expr_block", "view_param", "view_params", "abstract_view", "view", "alias",
	"app_decl", "application", "import_mode", "import_stmt", "imports_decl",
	"sysl_file",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type SyslParser struct {
	*antlr.BaseParser
}

func NewSyslParser(input antlr.TokenStream) *SyslParser {
	this := new(SyslParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "SyslParser.g4"

	return this
}

// SyslParser tokens.
const (
	SyslParserEOF                  = antlr.TokenEOF
	SyslParserINDENT               = 1
	SyslParserDEDENT               = 2
	SyslParserNativeDataTypes      = 3
	SyslParserHTTP_VERBS           = 4
	SyslParserWRAP                 = 5
	SyslParserTABLE                = 6
	SyslParserTYPE                 = 7
	SyslParserALIAS                = 8
	SyslParserUNION                = 9
	SyslParserVIEW                 = 10
	SyslParserIMPORT               = 11
	SyslParserAS                   = 12
	SyslParserRETURN               = 13
	SyslParserIF                   = 14
	SyslParserFOR_EACH             = 15
	SyslParserFOR                  = 16
	SyslParserUNTIL                = 17
	SyslParserELSE                 = 18
	SyslParserLOOP                 = 19
	SyslParserALT                  = 20
	SyslParserWHILE                = 21
	SyslParserWHATEVER             = 22
	SyslParserDOTDOT               = 23
	SyslParserSEQUENCE_OF          = 24
	SyslParserSET_OF               = 25
	SyslParserONE_OF               = 26
	SyslParserMIXIN                = 27
	SyslParserDISTANCE             = 28
	SyslParserDOT_ARROW            = 29
	SyslParserNAME_SEP             = 30
	SyslParserLESS_COLON           = 31
	SyslParserARROW_LEFT           = 32
	SyslParserARROW_RIGHT          = 33
	SyslParserCOLLECTOR            = 34
	SyslParserPLUS                 = 35
	SyslParserABSTRACT             = 36
	SyslParserTILDE                = 37
	SyslParserCOMMA                = 38
	SyslParserEQ                   = 39
	SyslParserFORWARD_SLASH        = 40
	SyslParserCOLON                = 41
	SyslParserDOT                  = 42
	SyslParserQN                   = 43
	SyslParserAT                   = 44
	SyslParserAMP                  = 45
	SyslParserSQ_OPEN              = 46
	SyslParserSQ_CLOSE             = 47
	SyslParserCURLY_OPEN           = 48
	SyslParserCURLY_CLOSE          = 49
	SyslParserOPEN_PAREN           = 50
	SyslParserCLOSE_PAREN          = 51
	SyslParserEMPTY_COMMENT        = 52
	SyslParserHASH                 = 53
	SyslParserPIPE                 = 54
	SyslParserEMPTY_LINE           = 55
	SyslParserINDENTED_COMMENT     = 56
	SyslParserDIGITS               = 57
	SyslParserQSTRING              = 58
	SyslParserNEWLINE              = 59
	SyslParserSYSL_COMMENT         = 60
	SyslParserTEXT_LINE            = 61
	SyslParserName                 = 62
	SyslParserWS                   = 63
	SyslParserErrorChar            = 64
	SyslParserPREDICATE_VALUE      = 65
	SyslParserSKIP_WS_ARG          = 66
	SyslParserTEXT_VALUE           = 67
	SyslParserNEWLINE_2            = 68
	SyslParserTEXT                 = 69
	SyslParserPOP_WS               = 70
	SyslParserVAR_NAME             = 71
	SyslParserE_NativeDataTypes    = 72
	SyslParserE_INDENTED_COMMENT   = 73
	SyslParserE_WHATEVER           = 74
	SyslParserE_EQ_RIGHT           = 75
	SyslParserE_ARROW_RIGHT        = 76
	SyslParserE_DOUBLE_EQ          = 77
	SyslParserE_REL                = 78
	SyslParserE_SQ_OPEN            = 79
	SyslParserE_SQ_CLOSE           = 80
	SyslParserE_ANGLE_OPEN         = 81
	SyslParserE_ANGLE_CLOSE        = 82
	SyslParserE_EMPTY_TUPLE        = 83
	SyslParserE_CURLY_OPEN         = 84
	SyslParserE_CURLY_CLOSE        = 85
	SyslParserE_NULLSAFE_DOT       = 86
	SyslParserE_TABLE_OF           = 87
	SyslParserE_POW                = 88
	SyslParserE_COALESCE           = 89
	SyslParserE_COLON              = 90
	SyslParserE_OPEN_PAREN         = 91
	SyslParserE_CLOSE_PAREN        = 92
	SyslParserE_COMMA              = 93
	SyslParserE_EQ                 = 94
	SyslParserE_PLUS               = 95
	SyslParserE_DIVIDE             = 96
	SyslParserE_MOD                = 97
	SyslParserE_MINUS              = 98
	SyslParserE_QN                 = 99
	SyslParserE_TILDE              = 100
	SyslParserE_NOT                = 101
	SyslParserE_XOR                = 102
	SyslParserE_LOGIC_OR           = 103
	SyslParserE_DOUBLE_AMP         = 104
	SyslParserE_AMP                = 105
	SyslParserE_BY                 = 106
	SyslParserE_AND                = 107
	SyslParserE_BITOR              = 108
	SyslParserE_STAR               = 109
	SyslParserE_AS                 = 110
	SyslParserE_VIA                = 111
	SyslParserE_IF                 = 112
	SyslParserE_THEN               = 113
	SyslParserE_ELSE               = 114
	SyslParserE_LET                = 115
	SyslParserE_TRUE               = 116
	SyslParserE_FALSE              = 117
	SyslParserE_NULL               = 118
	SyslParserE_BUTNOT             = 119
	SyslParserE_SEQUENCE_OF        = 120
	SyslParserE_SET_OF             = 121
	SyslParserE_ASC                = 122
	SyslParserE_DESC               = 123
	SyslParserE_RELOPS_RANK        = 124
	SyslParserE_RELOPS_AGG         = 125
	SyslParserE_RELOPS_ANY         = 126
	SyslParserE_RELOPS_SINGLE_NULL = 127
	SyslParserE_RELOPS_SNAPSHOT    = 128
	SyslParserE_RELOPS_WHERE       = 129
	SyslParserE_RELOPS_COUNT       = 130
	SyslParserE_RELOPS_FLATTEN     = 131
	SyslParserE_RELOPS_FIRST       = 132
	SyslParserE_FUNC               = 133
	SyslParserE_RAW_TEXT_END       = 134
	SyslParserE_RAW_TEXT_START     = 135
	SyslParserE_STRING_DBL         = 136
	SyslParserE_STRING_SINGLE      = 137
	SyslParserE_DECIMAL            = 138
	SyslParserE_DIGITS             = 139
	SyslParserE_DOT_NAME_NL        = 140
	SyslParserE_Name               = 141
	SyslParserE_DOT                = 142
	SyslParserE_WS                 = 143
	SyslParserE_EMPTY_LINE         = 144
	SyslParserE_NL                 = 145
	SyslParserIMPORT_PATH          = 146
	SyslParserTMPL_TEXT            = 147
	SyslParserTMPL_DEBUG           = 148
)

// SyslParser rules.
const (
	SyslParserRULE_modifier                   = 0
	SyslParserRULE_size_spec                  = 1
	SyslParserRULE_modifier_list              = 2
	SyslParserRULE_modifiers                  = 3
	SyslParserRULE_name_str                   = 4
	SyslParserRULE_reference                  = 5
	SyslParserRULE_doc_string                 = 6
	SyslParserRULE_quoted_string              = 7
	SyslParserRULE_array_of_strings           = 8
	SyslParserRULE_array_of_arrays            = 9
	SyslParserRULE_nvp                        = 10
	SyslParserRULE_attributes                 = 11
	SyslParserRULE_entry                      = 12
	SyslParserRULE_attribs_or_modifiers       = 13
	SyslParserRULE_user_defined_type          = 14
	SyslParserRULE_types                      = 15
	SyslParserRULE_set_of                     = 16
	SyslParserRULE_set_type                   = 17
	SyslParserRULE_sequence_of                = 18
	SyslParserRULE_sequence_type              = 19
	SyslParserRULE_collection_type            = 20
	SyslParserRULE_multi_line_docstring       = 21
	SyslParserRULE_annotation_value           = 22
	SyslParserRULE_annotation                 = 23
	SyslParserRULE_annotations                = 24
	SyslParserRULE_field_type                 = 25
	SyslParserRULE_array_size                 = 26
	SyslParserRULE_inplace_tuple              = 27
	SyslParserRULE_field                      = 28
	SyslParserRULE_inplace_table              = 29
	SyslParserRULE_table_stmts                = 30
	SyslParserRULE_table_def                  = 31
	SyslParserRULE_table                      = 32
	SyslParserRULE_union                      = 33
	SyslParserRULE_package_name               = 34
	SyslParserRULE_sub_package                = 35
	SyslParserRULE_app_name                   = 36
	SyslParserRULE_name_with_attribs          = 37
	SyslParserRULE_model_name                 = 38
	SyslParserRULE_inplace_table_def          = 39
	SyslParserRULE_table_refs                 = 40
	SyslParserRULE_facade                     = 41
	SyslParserRULE_documentation_stmts        = 42
	SyslParserRULE_var_in_curly               = 43
	SyslParserRULE_query_var                  = 44
	SyslParserRULE_query_param                = 45
	SyslParserRULE_http_path_part             = 46
	SyslParserRULE_http_path_var_with_type    = 47
	SyslParserRULE_http_path_static           = 48
	SyslParserRULE_http_path_suffix           = 49
	SyslParserRULE_http_path                  = 50
	SyslParserRULE_endpoint_name              = 51
	SyslParserRULE_ret_stmt                   = 52
	SyslParserRULE_target                     = 53
	SyslParserRULE_target_endpoint            = 54
	SyslParserRULE_call_arg                   = 55
	SyslParserRULE_call_args                  = 56
	SyslParserRULE_call_stmt                  = 57
	SyslParserRULE_if_stmt                    = 58
	SyslParserRULE_else_stmt                  = 59
	SyslParserRULE_if_else                    = 60
	SyslParserRULE_for_stmt                   = 61
	SyslParserRULE_http_method_comment        = 62
	SyslParserRULE_group_stmt                 = 63
	SyslParserRULE_one_of_case_label          = 64
	SyslParserRULE_one_of_cases               = 65
	SyslParserRULE_one_of_stmt                = 66
	SyslParserRULE_text_stmt                  = 67
	SyslParserRULE_mixin                      = 68
	SyslParserRULE_param                      = 69
	SyslParserRULE_param_list                 = 70
	SyslParserRULE_params                     = 71
	SyslParserRULE_statements                 = 72
	SyslParserRULE_method_def                 = 73
	SyslParserRULE_shortcut                   = 74
	SyslParserRULE_simple_endpoint            = 75
	SyslParserRULE_rest_endpoint              = 76
	SyslParserRULE_collector_query_var        = 77
	SyslParserRULE_collector_query_param      = 78
	SyslParserRULE_collector_call_stmt        = 79
	SyslParserRULE_collector_http_stmt_part   = 80
	SyslParserRULE_collector_http_stmt_suffix = 81
	SyslParserRULE_collector_http_stmt        = 82
	SyslParserRULE_publisher                  = 83
	SyslParserRULE_subscriber                 = 84
	SyslParserRULE_collector_pubsub_call      = 85
	SyslParserRULE_collector_action_stmt      = 86
	SyslParserRULE_collector_stmts            = 87
	SyslParserRULE_collector                  = 88
	SyslParserRULE_event                      = 89
	SyslParserRULE_subscribe                  = 90
	SyslParserRULE_view_type_spec             = 91
	SyslParserRULE_literal                    = 92
	SyslParserRULE_expr_table_of_op           = 93
	SyslParserRULE_func_arg                   = 94
	SyslParserRULE_func_args                  = 95
	SyslParserRULE_expr_func                  = 96
	SyslParserRULE_rank_expr                  = 97
	SyslParserRULE_rank_expr_list             = 98
	SyslParserRULE_expr_rank_func             = 99
	SyslParserRULE_expr_agg_func              = 100
	SyslParserRULE_e_scope_var                = 101
	SyslParserRULE_first_func_target          = 102
	SyslParserRULE_expr_first_func            = 103
	SyslParserRULE_e_single_arg_func          = 104
	SyslParserRULE_expr_single_arg_func       = 105
	SyslParserRULE_expr_any_func              = 106
	SyslParserRULE_expr_single_or_null        = 107
	SyslParserRULE_expr_snapshot              = 108
	SyslParserRULE_expr_count                 = 109
	SyslParserRULE_expr_navigate_attr         = 110
	SyslParserRULE_expr_navigate              = 111
	SyslParserRULE_matching_rhs               = 112
	SyslParserRULE_squiggly_args              = 113
	SyslParserRULE_expr_matching              = 114
	SyslParserRULE_relop                      = 115
	SyslParserRULE_list_item                  = 116
	SyslParserRULE_expr_list                  = 117
	SyslParserRULE_expr_set                   = 118
	SyslParserRULE_empty_tuple                = 119
	SyslParserRULE_atom_dot_relop             = 120
	SyslParserRULE_atomT_implied_dot          = 121
	SyslParserRULE_atomT_name                 = 122
	SyslParserRULE_atomT_paren                = 123
	SyslParserRULE_expr_atom_list             = 124
	SyslParserRULE_atomT                      = 125
	SyslParserRULE_atom                       = 126
	SyslParserRULE_powerT                     = 127
	SyslParserRULE_power                      = 128
	SyslParserRULE_unaryTerm                  = 129
	SyslParserRULE_termT                      = 130
	SyslParserRULE_term                       = 131
	SyslParserRULE_binexprT                   = 132
	SyslParserRULE_binexpr                    = 133
	SyslParserRULE_e_compare_ops              = 134
	SyslParserRULE_expr_rel                   = 135
	SyslParserRULE_expr_bitand                = 136
	SyslParserRULE_expr_bitxor                = 137
	SyslParserRULE_expr_bitor                 = 138
	SyslParserRULE_expr_and                   = 139
	SyslParserRULE_expr_or                    = 140
	SyslParserRULE_expr_but_not               = 141
	SyslParserRULE_expr_coalesce              = 142
	SyslParserRULE_if_one_liner               = 143
	SyslParserRULE_else_block_stmt            = 144
	SyslParserRULE_control_item               = 145
	SyslParserRULE_if_controls                = 146
	SyslParserRULE_cond_block                 = 147
	SyslParserRULE_final_else                 = 148
	SyslParserRULE_ifvar                      = 149
	SyslParserRULE_if_multiple_lines          = 150
	SyslParserRULE_expr_if_else               = 151
	SyslParserRULE_expr                       = 152
	SyslParserRULE_expr_assign                = 153
	SyslParserRULE_expr_simple_assign         = 154
	SyslParserRULE_expr_let_statement         = 155
	SyslParserRULE_expr_table_of_statement    = 156
	SyslParserRULE_expr_dot_assign            = 157
	SyslParserRULE_expr_statement_no_nl       = 158
	SyslParserRULE_template_expression        = 159
	SyslParserRULE_template_statement         = 160
	SyslParserRULE_expr_statement             = 161
	SyslParserRULE_expr_inject_stmt           = 162
	SyslParserRULE_expr_stmt                  = 163
	SyslParserRULE_transform_return_type      = 164
	SyslParserRULE_view_return_type           = 165
	SyslParserRULE_transform_scope_var        = 166
	SyslParserRULE_transform_arg              = 167
	SyslParserRULE_transform                  = 168
	SyslParserRULE_expr_block                 = 169
	SyslParserRULE_view_param                 = 170
	SyslParserRULE_view_params                = 171
	SyslParserRULE_abstract_view              = 172
	SyslParserRULE_view                       = 173
	SyslParserRULE_alias                      = 174
	SyslParserRULE_app_decl                   = 175
	SyslParserRULE_application                = 176
	SyslParserRULE_import_mode                = 177
	SyslParserRULE_import_stmt                = 178
	SyslParserRULE_imports_decl               = 179
	SyslParserRULE_sysl_file                  = 180
)

// IModifierContext is an interface to support dynamic dispatch.
type IModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifierContext differentiates from other interfaces.
	IsModifierContext()
}

type ModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierContext() *ModifierContext {
	var p = new(ModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_modifier
	return p
}

func (*ModifierContext) IsModifierContext() {}

func NewModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierContext {
	var p = new(ModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_modifier

	return p
}

func (s *ModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierContext) TILDE() antlr.TerminalNode {
	return s.GetToken(SyslParserTILDE, 0)
}

func (s *ModifierContext) AllName() []antlr.TerminalNode {
	return s.GetTokens(SyslParserName)
}

func (s *ModifierContext) Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserName, i)
}

func (s *ModifierContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(SyslParserPLUS)
}

func (s *ModifierContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserPLUS, i)
}

func (s *ModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterModifier(s)
	}
}

func (s *ModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitModifier(s)
	}
}

func (p *SyslParser) Modifier() (localctx IModifierContext) {
	localctx = NewModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SyslParserRULE_modifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(362)
		p.Match(SyslParserTILDE)
	}
	{
		p.SetState(363)
		p.Match(SyslParserName)
	}
	p.SetState(368)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserPLUS {
		{
			p.SetState(364)
			p.Match(SyslParserPLUS)
		}
		{
			p.SetState(365)
			p.Match(SyslParserName)
		}

		p.SetState(370)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISize_specContext is an interface to support dynamic dispatch.
type ISize_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSize_specContext differentiates from other interfaces.
	IsSize_specContext()
}

type Size_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySize_specContext() *Size_specContext {
	var p = new(Size_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_size_spec
	return p
}

func (*Size_specContext) IsSize_specContext() {}

func NewSize_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Size_specContext {
	var p = new(Size_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_size_spec

	return p
}

func (s *Size_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Size_specContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *Size_specContext) AllDIGITS() []antlr.TerminalNode {
	return s.GetTokens(SyslParserDIGITS)
}

func (s *Size_specContext) DIGITS(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserDIGITS, i)
}

func (s *Size_specContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *Size_specContext) DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserDOT, 0)
}

func (s *Size_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Size_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Size_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSize_spec(s)
	}
}

func (s *Size_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSize_spec(s)
	}
}

func (p *SyslParser) Size_spec() (localctx ISize_specContext) {
	localctx = NewSize_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SyslParserRULE_size_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(371)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(372)
		p.Match(SyslParserDIGITS)
	}
	p.SetState(375)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserDOT {
		{
			p.SetState(373)
			p.Match(SyslParserDOT)
		}
		{
			p.SetState(374)
			p.Match(SyslParserDIGITS)
		}

	}
	{
		p.SetState(377)
		p.Match(SyslParserCLOSE_PAREN)
	}

	return localctx
}

// IModifier_listContext is an interface to support dynamic dispatch.
type IModifier_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifier_listContext differentiates from other interfaces.
	IsModifier_listContext()
}

type Modifier_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifier_listContext() *Modifier_listContext {
	var p = new(Modifier_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_modifier_list
	return p
}

func (*Modifier_listContext) IsModifier_listContext() {}

func NewModifier_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Modifier_listContext {
	var p = new(Modifier_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_modifier_list

	return p
}

func (s *Modifier_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Modifier_listContext) AllModifier() []IModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModifierContext)(nil)).Elem())
	var tst = make([]IModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModifierContext)
		}
	}

	return tst
}

func (s *Modifier_listContext) Modifier(i int) IModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *Modifier_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Modifier_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Modifier_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Modifier_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Modifier_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterModifier_list(s)
	}
}

func (s *Modifier_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitModifier_list(s)
	}
}

func (p *SyslParser) Modifier_list() (localctx IModifier_listContext) {
	localctx = NewModifier_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SyslParserRULE_modifier_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(379)
		p.Modifier()
	}
	p.SetState(384)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(380)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(381)
			p.Modifier()
		}

		p.SetState(386)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IModifiersContext is an interface to support dynamic dispatch.
type IModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifiersContext differentiates from other interfaces.
	IsModifiersContext()
}

type ModifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifiersContext() *ModifiersContext {
	var p = new(ModifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_modifiers
	return p
}

func (*ModifiersContext) IsModifiersContext() {}

func NewModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifiersContext {
	var p = new(ModifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_modifiers

	return p
}

func (s *ModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifiersContext) SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_OPEN, 0)
}

func (s *ModifiersContext) Modifier_list() IModifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifier_listContext)
}

func (s *ModifiersContext) SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_CLOSE, 0)
}

func (s *ModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterModifiers(s)
	}
}

func (s *ModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitModifiers(s)
	}
}

func (p *SyslParser) Modifiers() (localctx IModifiersContext) {
	localctx = NewModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SyslParserRULE_modifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(387)
		p.Match(SyslParserSQ_OPEN)
	}
	{
		p.SetState(388)
		p.Modifier_list()
	}
	{
		p.SetState(389)
		p.Match(SyslParserSQ_CLOSE)
	}

	return localctx
}

// IName_strContext is an interface to support dynamic dispatch.
type IName_strContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_strContext differentiates from other interfaces.
	IsName_strContext()
}

type Name_strContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_strContext() *Name_strContext {
	var p = new(Name_strContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_name_str
	return p
}

func (*Name_strContext) IsName_strContext() {}

func NewName_strContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_strContext {
	var p = new(Name_strContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_name_str

	return p
}

func (s *Name_strContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_strContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Name_strContext) TEXT_LINE() antlr.TerminalNode {
	return s.GetToken(SyslParserTEXT_LINE, 0)
}

func (s *Name_strContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Name_strContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_strContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_strContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterName_str(s)
	}
}

func (s *Name_strContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitName_str(s)
	}
}

func (p *SyslParser) Name_str() (localctx IName_strContext) {
	localctx = NewName_strContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SyslParserRULE_name_str)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(391)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserTEXT_LINE || _la == SyslParserName || _la == SyslParserE_Name) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IReferenceContext is an interface to support dynamic dispatch.
type IReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceContext differentiates from other interfaces.
	IsReferenceContext()
}

type ReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceContext() *ReferenceContext {
	var p = new(ReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_reference
	return p
}

func (*ReferenceContext) IsReferenceContext() {}

func NewReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceContext {
	var p = new(ReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_reference

	return p
}

func (s *ReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *ReferenceContext) AllName_str() []IName_strContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IName_strContext)(nil)).Elem())
	var tst = make([]IName_strContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IName_strContext)
		}
	}

	return tst
}

func (s *ReferenceContext) Name_str(i int) IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *ReferenceContext) AllE_DOT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_DOT)
}

func (s *ReferenceContext) E_DOT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, i)
}

func (s *ReferenceContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserDOT)
}

func (s *ReferenceContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserDOT, i)
}

func (s *ReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterReference(s)
	}
}

func (s *ReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitReference(s)
	}
}

func (p *SyslParser) Reference() (localctx IReferenceContext) {
	localctx = NewReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SyslParserRULE_reference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(393)
		p.App_name()
	}
	p.SetState(396)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(394)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SyslParserDOT || _la == SyslParserE_DOT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
			{
				p.SetState(395)
				p.Name_str()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(398)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())
	}

	return localctx
}

// IDoc_stringContext is an interface to support dynamic dispatch.
type IDoc_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDoc_stringContext differentiates from other interfaces.
	IsDoc_stringContext()
}

type Doc_stringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoc_stringContext() *Doc_stringContext {
	var p = new(Doc_stringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_doc_string
	return p
}

func (*Doc_stringContext) IsDoc_stringContext() {}

func NewDoc_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Doc_stringContext {
	var p = new(Doc_stringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_doc_string

	return p
}

func (s *Doc_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Doc_stringContext) PIPE() antlr.TerminalNode {
	return s.GetToken(SyslParserPIPE, 0)
}

func (s *Doc_stringContext) TEXT() antlr.TerminalNode {
	return s.GetToken(SyslParserTEXT, 0)
}

func (s *Doc_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Doc_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Doc_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterDoc_string(s)
	}
}

func (s *Doc_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitDoc_string(s)
	}
}

func (p *SyslParser) Doc_string() (localctx IDoc_stringContext) {
	localctx = NewDoc_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SyslParserRULE_doc_string)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(400)
		p.Match(SyslParserPIPE)
	}
	{
		p.SetState(401)
		p.Match(SyslParserTEXT)
	}

	return localctx
}

// IQuoted_stringContext is an interface to support dynamic dispatch.
type IQuoted_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuoted_stringContext differentiates from other interfaces.
	IsQuoted_stringContext()
}

type Quoted_stringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuoted_stringContext() *Quoted_stringContext {
	var p = new(Quoted_stringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_quoted_string
	return p
}

func (*Quoted_stringContext) IsQuoted_stringContext() {}

func NewQuoted_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Quoted_stringContext {
	var p = new(Quoted_stringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_quoted_string

	return p
}

func (s *Quoted_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Quoted_stringContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Quoted_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quoted_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Quoted_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterQuoted_string(s)
	}
}

func (s *Quoted_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitQuoted_string(s)
	}
}

func (p *SyslParser) Quoted_string() (localctx IQuoted_stringContext) {
	localctx = NewQuoted_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SyslParserRULE_quoted_string)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(403)
		p.Match(SyslParserQSTRING)
	}

	return localctx
}

// IArray_of_stringsContext is an interface to support dynamic dispatch.
type IArray_of_stringsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_of_stringsContext differentiates from other interfaces.
	IsArray_of_stringsContext()
}

type Array_of_stringsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_of_stringsContext() *Array_of_stringsContext {
	var p = new(Array_of_stringsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_array_of_strings
	return p
}

func (*Array_of_stringsContext) IsArray_of_stringsContext() {}

func NewArray_of_stringsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_of_stringsContext {
	var p = new(Array_of_stringsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_array_of_strings

	return p
}

func (s *Array_of_stringsContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_of_stringsContext) SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_OPEN, 0)
}

func (s *Array_of_stringsContext) AllQuoted_string() []IQuoted_stringContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem())
	var tst = make([]IQuoted_stringContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQuoted_stringContext)
		}
	}

	return tst
}

func (s *Array_of_stringsContext) Quoted_string(i int) IQuoted_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *Array_of_stringsContext) SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_CLOSE, 0)
}

func (s *Array_of_stringsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Array_of_stringsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Array_of_stringsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_of_stringsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_of_stringsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterArray_of_strings(s)
	}
}

func (s *Array_of_stringsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitArray_of_strings(s)
	}
}

func (p *SyslParser) Array_of_strings() (localctx IArray_of_stringsContext) {
	localctx = NewArray_of_stringsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SyslParserRULE_array_of_strings)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(405)
		p.Match(SyslParserSQ_OPEN)
	}
	{
		p.SetState(406)
		p.Quoted_string()
	}
	p.SetState(411)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(407)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(408)
			p.Quoted_string()
		}

		p.SetState(413)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(414)
		p.Match(SyslParserSQ_CLOSE)
	}

	return localctx
}

// IArray_of_arraysContext is an interface to support dynamic dispatch.
type IArray_of_arraysContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_of_arraysContext differentiates from other interfaces.
	IsArray_of_arraysContext()
}

type Array_of_arraysContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_of_arraysContext() *Array_of_arraysContext {
	var p = new(Array_of_arraysContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_array_of_arrays
	return p
}

func (*Array_of_arraysContext) IsArray_of_arraysContext() {}

func NewArray_of_arraysContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_of_arraysContext {
	var p = new(Array_of_arraysContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_array_of_arrays

	return p
}

func (s *Array_of_arraysContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_of_arraysContext) SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_OPEN, 0)
}

func (s *Array_of_arraysContext) AllArray_of_strings() []IArray_of_stringsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArray_of_stringsContext)(nil)).Elem())
	var tst = make([]IArray_of_stringsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArray_of_stringsContext)
		}
	}

	return tst
}

func (s *Array_of_arraysContext) Array_of_strings(i int) IArray_of_stringsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_of_stringsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArray_of_stringsContext)
}

func (s *Array_of_arraysContext) SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_CLOSE, 0)
}

func (s *Array_of_arraysContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Array_of_arraysContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Array_of_arraysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_of_arraysContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_of_arraysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterArray_of_arrays(s)
	}
}

func (s *Array_of_arraysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitArray_of_arrays(s)
	}
}

func (p *SyslParser) Array_of_arrays() (localctx IArray_of_arraysContext) {
	localctx = NewArray_of_arraysContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SyslParserRULE_array_of_arrays)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(416)
		p.Match(SyslParserSQ_OPEN)
	}
	{
		p.SetState(417)
		p.Array_of_strings()
	}
	p.SetState(422)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(418)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(419)
			p.Array_of_strings()
		}

		p.SetState(424)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(425)
		p.Match(SyslParserSQ_CLOSE)
	}

	return localctx
}

// INvpContext is an interface to support dynamic dispatch.
type INvpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNvpContext differentiates from other interfaces.
	IsNvpContext()
}

type NvpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNvpContext() *NvpContext {
	var p = new(NvpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_nvp
	return p
}

func (*NvpContext) IsNvpContext() {}

func NewNvpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NvpContext {
	var p = new(NvpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_nvp

	return p
}

func (s *NvpContext) GetParser() antlr.Parser { return s.parser }

func (s *NvpContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *NvpContext) EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserEQ, 0)
}

func (s *NvpContext) Quoted_string() IQuoted_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *NvpContext) Array_of_strings() IArray_of_stringsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_of_stringsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_of_stringsContext)
}

func (s *NvpContext) Array_of_arrays() IArray_of_arraysContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_of_arraysContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_of_arraysContext)
}

func (s *NvpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NvpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NvpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterNvp(s)
	}
}

func (s *NvpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitNvp(s)
	}
}

func (p *SyslParser) Nvp() (localctx INvpContext) {
	localctx = NewNvpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SyslParserRULE_nvp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(427)
		p.Match(SyslParserName)
	}
	{
		p.SetState(428)
		p.Match(SyslParserEQ)
	}
	p.SetState(432)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(429)
			p.Quoted_string()
		}

	case 2:
		{
			p.SetState(430)
			p.Array_of_strings()
		}

	case 3:
		{
			p.SetState(431)
			p.Array_of_arrays()
		}

	}

	return localctx
}

// IAttributesContext is an interface to support dynamic dispatch.
type IAttributesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributesContext differentiates from other interfaces.
	IsAttributesContext()
}

type AttributesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributesContext() *AttributesContext {
	var p = new(AttributesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_attributes
	return p
}

func (*AttributesContext) IsAttributesContext() {}

func NewAttributesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributesContext {
	var p = new(AttributesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_attributes

	return p
}

func (s *AttributesContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributesContext) SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_OPEN, 0)
}

func (s *AttributesContext) AllNvp() []INvpContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INvpContext)(nil)).Elem())
	var tst = make([]INvpContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INvpContext)
		}
	}

	return tst
}

func (s *AttributesContext) Nvp(i int) INvpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INvpContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INvpContext)
}

func (s *AttributesContext) SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_CLOSE, 0)
}

func (s *AttributesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *AttributesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *AttributesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAttributes(s)
	}
}

func (s *AttributesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAttributes(s)
	}
}

func (p *SyslParser) Attributes() (localctx IAttributesContext) {
	localctx = NewAttributesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SyslParserRULE_attributes)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(434)
		p.Match(SyslParserSQ_OPEN)
	}
	{
		p.SetState(435)
		p.Nvp()
	}
	p.SetState(440)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(436)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(437)
			p.Nvp()
		}

		p.SetState(442)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(443)
		p.Match(SyslParserSQ_CLOSE)
	}

	return localctx
}

// IEntryContext is an interface to support dynamic dispatch.
type IEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntryContext differentiates from other interfaces.
	IsEntryContext()
}

type EntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntryContext() *EntryContext {
	var p = new(EntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_entry
	return p
}

func (*EntryContext) IsEntryContext() {}

func NewEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EntryContext {
	var p = new(EntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_entry

	return p
}

func (s *EntryContext) GetParser() antlr.Parser { return s.parser }

func (s *EntryContext) Nvp() INvpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INvpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INvpContext)
}

func (s *EntryContext) Modifier() IModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *EntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterEntry(s)
	}
}

func (s *EntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitEntry(s)
	}
}

func (p *SyslParser) Entry() (localctx IEntryContext) {
	localctx = NewEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SyslParserRULE_entry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(447)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(445)
			p.Nvp()
		}

	case SyslParserTILDE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(446)
			p.Modifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAttribs_or_modifiersContext is an interface to support dynamic dispatch.
type IAttribs_or_modifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribs_or_modifiersContext differentiates from other interfaces.
	IsAttribs_or_modifiersContext()
}

type Attribs_or_modifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribs_or_modifiersContext() *Attribs_or_modifiersContext {
	var p = new(Attribs_or_modifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_attribs_or_modifiers
	return p
}

func (*Attribs_or_modifiersContext) IsAttribs_or_modifiersContext() {}

func NewAttribs_or_modifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribs_or_modifiersContext {
	var p = new(Attribs_or_modifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_attribs_or_modifiers

	return p
}

func (s *Attribs_or_modifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribs_or_modifiersContext) SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_OPEN, 0)
}

func (s *Attribs_or_modifiersContext) AllEntry() []IEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEntryContext)(nil)).Elem())
	var tst = make([]IEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEntryContext)
		}
	}

	return tst
}

func (s *Attribs_or_modifiersContext) Entry(i int) IEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEntryContext)
}

func (s *Attribs_or_modifiersContext) SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_CLOSE, 0)
}

func (s *Attribs_or_modifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Attribs_or_modifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Attribs_or_modifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribs_or_modifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribs_or_modifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAttribs_or_modifiers(s)
	}
}

func (s *Attribs_or_modifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAttribs_or_modifiers(s)
	}
}

func (p *SyslParser) Attribs_or_modifiers() (localctx IAttribs_or_modifiersContext) {
	localctx = NewAttribs_or_modifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SyslParserRULE_attribs_or_modifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(449)
		p.Match(SyslParserSQ_OPEN)
	}
	{
		p.SetState(450)
		p.Entry()
	}
	p.SetState(455)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(451)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(452)
			p.Entry()
		}

		p.SetState(457)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(458)
		p.Match(SyslParserSQ_CLOSE)
	}

	return localctx
}

// IUser_defined_typeContext is an interface to support dynamic dispatch.
type IUser_defined_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUser_defined_typeContext differentiates from other interfaces.
	IsUser_defined_typeContext()
}

type User_defined_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUser_defined_typeContext() *User_defined_typeContext {
	var p = new(User_defined_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_user_defined_type
	return p
}

func (*User_defined_typeContext) IsUser_defined_typeContext() {}

func NewUser_defined_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *User_defined_typeContext {
	var p = new(User_defined_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_user_defined_type

	return p
}

func (s *User_defined_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *User_defined_typeContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *User_defined_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *User_defined_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *User_defined_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterUser_defined_type(s)
	}
}

func (s *User_defined_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitUser_defined_type(s)
	}
}

func (p *SyslParser) User_defined_type() (localctx IUser_defined_typeContext) {
	localctx = NewUser_defined_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SyslParserRULE_user_defined_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(460)
		p.Name_str()
	}

	return localctx
}

// ITypesContext is an interface to support dynamic dispatch.
type ITypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypesContext differentiates from other interfaces.
	IsTypesContext()
}

type TypesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypesContext() *TypesContext {
	var p = new(TypesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_types
	return p
}

func (*TypesContext) IsTypesContext() {}

func NewTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypesContext {
	var p = new(TypesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_types

	return p
}

func (s *TypesContext) GetParser() antlr.Parser { return s.parser }

func (s *TypesContext) User_defined_type() IUser_defined_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUser_defined_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUser_defined_typeContext)
}

func (s *TypesContext) Reference() IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *TypesContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *TypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTypes(s)
	}
}

func (s *TypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTypes(s)
	}
}

func (p *SyslParser) Types() (localctx ITypesContext) {
	localctx = NewTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SyslParserRULE_types)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(465)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(462)
			p.User_defined_type()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(463)
			p.Reference()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(464)
			p.Match(SyslParserNativeDataTypes)
		}

	}

	return localctx
}

// ISet_ofContext is an interface to support dynamic dispatch.
type ISet_ofContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_ofContext differentiates from other interfaces.
	IsSet_ofContext()
}

type Set_ofContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_ofContext() *Set_ofContext {
	var p = new(Set_ofContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_set_of
	return p
}

func (*Set_ofContext) IsSet_ofContext() {}

func NewSet_ofContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_ofContext {
	var p = new(Set_ofContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_set_of

	return p
}

func (s *Set_ofContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_ofContext) SET_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserSET_OF, 0)
}

func (s *Set_ofContext) E_SET_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SET_OF, 0)
}

func (s *Set_ofContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_ofContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_ofContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSet_of(s)
	}
}

func (s *Set_ofContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSet_of(s)
	}
}

func (p *SyslParser) Set_of() (localctx ISet_ofContext) {
	localctx = NewSet_ofContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SyslParserRULE_set_of)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(469)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserSET_OF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(467)
			p.Match(SyslParserSET_OF)
		}

	case SyslParserE_SET_OF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(468)
			p.Match(SyslParserE_SET_OF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISet_typeContext is an interface to support dynamic dispatch.
type ISet_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_typeContext differentiates from other interfaces.
	IsSet_typeContext()
}

type Set_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_typeContext() *Set_typeContext {
	var p = new(Set_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_set_type
	return p
}

func (*Set_typeContext) IsSet_typeContext() {}

func NewSet_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_typeContext {
	var p = new(Set_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_set_type

	return p
}

func (s *Set_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_typeContext) Set_of() ISet_ofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_ofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_ofContext)
}

func (s *Set_typeContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *Set_typeContext) Size_spec() ISize_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISize_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISize_specContext)
}

func (s *Set_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSet_type(s)
	}
}

func (s *Set_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSet_type(s)
	}
}

func (p *SyslParser) Set_type() (localctx ISet_typeContext) {
	localctx = NewSet_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SyslParserRULE_set_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(471)
		p.Set_of()
	}
	{
		p.SetState(472)
		p.Types()
	}
	p.SetState(474)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(473)
			p.Size_spec()
		}

	}

	return localctx
}

// ISequence_ofContext is an interface to support dynamic dispatch.
type ISequence_ofContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_ofContext differentiates from other interfaces.
	IsSequence_ofContext()
}

type Sequence_ofContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_ofContext() *Sequence_ofContext {
	var p = new(Sequence_ofContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_sequence_of
	return p
}

func (*Sequence_ofContext) IsSequence_ofContext() {}

func NewSequence_ofContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_ofContext {
	var p = new(Sequence_ofContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_sequence_of

	return p
}

func (s *Sequence_ofContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_ofContext) SEQUENCE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserSEQUENCE_OF, 0)
}

func (s *Sequence_ofContext) E_SEQUENCE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SEQUENCE_OF, 0)
}

func (s *Sequence_ofContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_ofContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_ofContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSequence_of(s)
	}
}

func (s *Sequence_ofContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSequence_of(s)
	}
}

func (p *SyslParser) Sequence_of() (localctx ISequence_ofContext) {
	localctx = NewSequence_ofContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SyslParserRULE_sequence_of)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(478)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserSEQUENCE_OF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(476)
			p.Match(SyslParserSEQUENCE_OF)
		}

	case SyslParserE_SEQUENCE_OF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(477)
			p.Match(SyslParserE_SEQUENCE_OF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISequence_typeContext is an interface to support dynamic dispatch.
type ISequence_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_typeContext differentiates from other interfaces.
	IsSequence_typeContext()
}

type Sequence_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_typeContext() *Sequence_typeContext {
	var p = new(Sequence_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_sequence_type
	return p
}

func (*Sequence_typeContext) IsSequence_typeContext() {}

func NewSequence_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_typeContext {
	var p = new(Sequence_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_sequence_type

	return p
}

func (s *Sequence_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_typeContext) Sequence_of() ISequence_ofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_ofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_ofContext)
}

func (s *Sequence_typeContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *Sequence_typeContext) Size_spec() ISize_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISize_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISize_specContext)
}

func (s *Sequence_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSequence_type(s)
	}
}

func (s *Sequence_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSequence_type(s)
	}
}

func (p *SyslParser) Sequence_type() (localctx ISequence_typeContext) {
	localctx = NewSequence_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SyslParserRULE_sequence_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(480)
		p.Sequence_of()
	}
	{
		p.SetState(481)
		p.Types()
	}
	p.SetState(483)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(482)
			p.Size_spec()
		}

	}

	return localctx
}

// ICollection_typeContext is an interface to support dynamic dispatch.
type ICollection_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollection_typeContext differentiates from other interfaces.
	IsCollection_typeContext()
}

type Collection_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollection_typeContext() *Collection_typeContext {
	var p = new(Collection_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collection_type
	return p
}

func (*Collection_typeContext) IsCollection_typeContext() {}

func NewCollection_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collection_typeContext {
	var p = new(Collection_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collection_type

	return p
}

func (s *Collection_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Collection_typeContext) Set_type() ISet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_typeContext)
}

func (s *Collection_typeContext) Sequence_type() ISequence_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_typeContext)
}

func (s *Collection_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collection_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collection_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollection_type(s)
	}
}

func (s *Collection_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollection_type(s)
	}
}

func (p *SyslParser) Collection_type() (localctx ICollection_typeContext) {
	localctx = NewCollection_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SyslParserRULE_collection_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(487)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserSET_OF, SyslParserE_SET_OF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(485)
			p.Set_type()
		}

	case SyslParserSEQUENCE_OF, SyslParserE_SEQUENCE_OF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(486)
			p.Sequence_type()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMulti_line_docstringContext is an interface to support dynamic dispatch.
type IMulti_line_docstringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMulti_line_docstringContext differentiates from other interfaces.
	IsMulti_line_docstringContext()
}

type Multi_line_docstringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMulti_line_docstringContext() *Multi_line_docstringContext {
	var p = new(Multi_line_docstringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_multi_line_docstring
	return p
}

func (*Multi_line_docstringContext) IsMulti_line_docstringContext() {}

func NewMulti_line_docstringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multi_line_docstringContext {
	var p = new(Multi_line_docstringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_multi_line_docstring

	return p
}

func (s *Multi_line_docstringContext) GetParser() antlr.Parser { return s.parser }

func (s *Multi_line_docstringContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Multi_line_docstringContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Multi_line_docstringContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Multi_line_docstringContext) AllDoc_string() []IDoc_stringContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDoc_stringContext)(nil)).Elem())
	var tst = make([]IDoc_stringContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDoc_stringContext)
		}
	}

	return tst
}

func (s *Multi_line_docstringContext) Doc_string(i int) IDoc_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDoc_stringContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDoc_stringContext)
}

func (s *Multi_line_docstringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multi_line_docstringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multi_line_docstringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterMulti_line_docstring(s)
	}
}

func (s *Multi_line_docstringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitMulti_line_docstring(s)
	}
}

func (p *SyslParser) Multi_line_docstring() (localctx IMulti_line_docstringContext) {
	localctx = NewMulti_line_docstringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SyslParserRULE_multi_line_docstring)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(489)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(490)
		p.Match(SyslParserINDENT)
	}
	p.SetState(492)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserPIPE {
		{
			p.SetState(491)
			p.Doc_string()
		}

		p.SetState(494)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(496)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IAnnotation_valueContext is an interface to support dynamic dispatch.
type IAnnotation_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotation_valueContext differentiates from other interfaces.
	IsAnnotation_valueContext()
}

type Annotation_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotation_valueContext() *Annotation_valueContext {
	var p = new(Annotation_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_annotation_value
	return p
}

func (*Annotation_valueContext) IsAnnotation_valueContext() {}

func NewAnnotation_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Annotation_valueContext {
	var p = new(Annotation_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_annotation_value

	return p
}

func (s *Annotation_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Annotation_valueContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Annotation_valueContext) Array_of_strings() IArray_of_stringsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_of_stringsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_of_stringsContext)
}

func (s *Annotation_valueContext) Multi_line_docstring() IMulti_line_docstringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_line_docstringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_line_docstringContext)
}

func (s *Annotation_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Annotation_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Annotation_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAnnotation_value(s)
	}
}

func (s *Annotation_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAnnotation_value(s)
	}
}

func (p *SyslParser) Annotation_value() (localctx IAnnotation_valueContext) {
	localctx = NewAnnotation_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SyslParserRULE_annotation_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(501)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserQSTRING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(498)
			p.Match(SyslParserQSTRING)
		}

	case SyslParserSQ_OPEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(499)
			p.Array_of_strings()
		}

	case SyslParserCOLON:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(500)
			p.Multi_line_docstring()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_annotation
	return p
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) AT() antlr.TerminalNode {
	return s.GetToken(SyslParserAT, 0)
}

func (s *AnnotationContext) VAR_NAME() antlr.TerminalNode {
	return s.GetToken(SyslParserVAR_NAME, 0)
}

func (s *AnnotationContext) EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserEQ, 0)
}

func (s *AnnotationContext) Annotation_value() IAnnotation_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotation_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotation_valueContext)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAnnotation(s)
	}
}

func (s *AnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAnnotation(s)
	}
}

func (p *SyslParser) Annotation() (localctx IAnnotationContext) {
	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SyslParserRULE_annotation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(503)
		p.Match(SyslParserAT)
	}
	{
		p.SetState(504)
		p.Match(SyslParserVAR_NAME)
	}
	{
		p.SetState(505)
		p.Match(SyslParserEQ)
	}
	{
		p.SetState(506)
		p.Annotation_value()
	}

	return localctx
}

// IAnnotationsContext is an interface to support dynamic dispatch.
type IAnnotationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationsContext differentiates from other interfaces.
	IsAnnotationsContext()
}

type AnnotationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationsContext() *AnnotationsContext {
	var p = new(AnnotationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_annotations
	return p
}

func (*AnnotationsContext) IsAnnotationsContext() {}

func NewAnnotationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationsContext {
	var p = new(AnnotationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_annotations

	return p
}

func (s *AnnotationsContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationsContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *AnnotationsContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *AnnotationsContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *AnnotationsContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AnnotationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAnnotations(s)
	}
}

func (s *AnnotationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAnnotations(s)
	}
}

func (p *SyslParser) Annotations() (localctx IAnnotationsContext) {
	localctx = NewAnnotationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SyslParserRULE_annotations)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(508)
		p.Match(SyslParserINDENT)
	}
	p.SetState(510)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserAT {
		{
			p.SetState(509)
			p.Annotation()
		}

		p.SetState(512)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(514)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IField_typeContext is an interface to support dynamic dispatch.
type IField_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsField_typeContext differentiates from other interfaces.
	IsField_typeContext()
}

type Field_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyField_typeContext() *Field_typeContext {
	var p = new(Field_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_field_type
	return p
}

func (*Field_typeContext) IsField_typeContext() {}

func NewField_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Field_typeContext {
	var p = new(Field_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_field_type

	return p
}

func (s *Field_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Field_typeContext) Collection_type() ICollection_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollection_typeContext)
}

func (s *Field_typeContext) QN() antlr.TerminalNode {
	return s.GetToken(SyslParserQN, 0)
}

func (s *Field_typeContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Field_typeContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Field_typeContext) Annotations() IAnnotationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsContext)
}

func (s *Field_typeContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *Field_typeContext) Array_size() IArray_sizeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_sizeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_sizeContext)
}

func (s *Field_typeContext) Size_spec() ISize_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISize_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISize_specContext)
}

func (s *Field_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Field_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Field_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterField_type(s)
	}
}

func (s *Field_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitField_type(s)
	}
}

func (p *SyslParser) Field_type() (localctx IField_typeContext) {
	localctx = NewField_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SyslParserRULE_field_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(522)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserSEQUENCE_OF, SyslParserSET_OF, SyslParserE_SEQUENCE_OF, SyslParserE_SET_OF:
		{
			p.SetState(516)
			p.Collection_type()
		}

	case SyslParserNativeDataTypes, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(517)
			p.Types()
		}
		p.SetState(520)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(518)
				p.Array_size()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(519)
				p.Size_spec()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(525)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQN {
		{
			p.SetState(524)
			p.Match(SyslParserQN)
		}

	}
	p.SetState(528)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(527)
			p.Attribs_or_modifiers()
		}

	}
	p.SetState(532)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserCOLON {
		{
			p.SetState(530)
			p.Match(SyslParserCOLON)
		}
		{
			p.SetState(531)
			p.Annotations()
		}

	}

	return localctx
}

// IArray_sizeContext is an interface to support dynamic dispatch.
type IArray_sizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_sizeContext differentiates from other interfaces.
	IsArray_sizeContext()
}

type Array_sizeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_sizeContext() *Array_sizeContext {
	var p = new(Array_sizeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_array_size
	return p
}

func (*Array_sizeContext) IsArray_sizeContext() {}

func NewArray_sizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_sizeContext {
	var p = new(Array_sizeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_array_size

	return p
}

func (s *Array_sizeContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_sizeContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *Array_sizeContext) AllDIGITS() []antlr.TerminalNode {
	return s.GetTokens(SyslParserDIGITS)
}

func (s *Array_sizeContext) DIGITS(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserDIGITS, i)
}

func (s *Array_sizeContext) DOTDOT() antlr.TerminalNode {
	return s.GetToken(SyslParserDOTDOT, 0)
}

func (s *Array_sizeContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *Array_sizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_sizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_sizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterArray_size(s)
	}
}

func (s *Array_sizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitArray_size(s)
	}
}

func (p *SyslParser) Array_size() (localctx IArray_sizeContext) {
	localctx = NewArray_sizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SyslParserRULE_array_size)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(534)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(535)
		p.Match(SyslParserDIGITS)
	}
	{
		p.SetState(536)
		p.Match(SyslParserDOTDOT)
	}
	p.SetState(538)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserDIGITS {
		{
			p.SetState(537)
			p.Match(SyslParserDIGITS)
		}

	}
	{
		p.SetState(540)
		p.Match(SyslParserCLOSE_PAREN)
	}

	return localctx
}

// IInplace_tupleContext is an interface to support dynamic dispatch.
type IInplace_tupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInplace_tupleContext differentiates from other interfaces.
	IsInplace_tupleContext()
}

type Inplace_tupleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInplace_tupleContext() *Inplace_tupleContext {
	var p = new(Inplace_tupleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_inplace_tuple
	return p
}

func (*Inplace_tupleContext) IsInplace_tupleContext() {}

func NewInplace_tupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inplace_tupleContext {
	var p = new(Inplace_tupleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_inplace_tuple

	return p
}

func (s *Inplace_tupleContext) GetParser() antlr.Parser { return s.parser }

func (s *Inplace_tupleContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Inplace_tupleContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Inplace_tupleContext) AllField() []IFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFieldContext)(nil)).Elem())
	var tst = make([]IFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFieldContext)
		}
	}

	return tst
}

func (s *Inplace_tupleContext) Field(i int) IFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFieldContext)
}

func (s *Inplace_tupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inplace_tupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inplace_tupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterInplace_tuple(s)
	}
}

func (s *Inplace_tupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitInplace_tuple(s)
	}
}

func (p *SyslParser) Inplace_tuple() (localctx IInplace_tupleContext) {
	localctx = NewInplace_tupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SyslParserRULE_inplace_tuple)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(542)
		p.Match(SyslParserINDENT)
	}
	p.SetState(544)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserTEXT_LINE || _la == SyslParserName || _la == SyslParserE_Name {
		{
			p.SetState(543)
			p.Field()
		}

		p.SetState(546)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(548)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IFieldContext is an interface to support dynamic dispatch.
type IFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldContext differentiates from other interfaces.
	IsFieldContext()
}

type FieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldContext() *FieldContext {
	var p = new(FieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_field
	return p
}

func (*FieldContext) IsFieldContext() {}

func NewFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldContext {
	var p = new(FieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_field

	return p
}

func (s *FieldContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *FieldContext) LESS_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserLESS_COLON, 0)
}

func (s *FieldContext) Field_type() IField_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IField_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IField_typeContext)
}

func (s *FieldContext) Inplace_tuple() IInplace_tupleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInplace_tupleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInplace_tupleContext)
}

func (s *FieldContext) Array_size() IArray_sizeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_sizeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_sizeContext)
}

func (s *FieldContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *FieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterField(s)
	}
}

func (s *FieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitField(s)
	}
}

func (p *SyslParser) Field() (localctx IFieldContext) {
	localctx = NewFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SyslParserRULE_field)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(550)
		p.Name_str()
	}
	p.SetState(562)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserLESS_COLON || _la == SyslParserOPEN_PAREN {
		p.SetState(552)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserOPEN_PAREN {
			{
				p.SetState(551)
				p.Array_size()
			}

		}
		{
			p.SetState(554)
			p.Match(SyslParserLESS_COLON)
		}
		p.SetState(557)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserNativeDataTypes, SyslParserSEQUENCE_OF, SyslParserSET_OF, SyslParserTEXT_LINE, SyslParserName, SyslParserE_SEQUENCE_OF, SyslParserE_SET_OF, SyslParserE_Name:
			{
				p.SetState(555)
				p.Field_type()
			}

		case SyslParserINDENT:
			{
				p.SetState(556)
				p.Inplace_tuple()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(560)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserQSTRING {
			{
				p.SetState(559)
				p.Match(SyslParserQSTRING)
			}

		}

	}

	return localctx
}

// IInplace_tableContext is an interface to support dynamic dispatch.
type IInplace_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInplace_tableContext differentiates from other interfaces.
	IsInplace_tableContext()
}

type Inplace_tableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInplace_tableContext() *Inplace_tableContext {
	var p = new(Inplace_tableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_inplace_table
	return p
}

func (*Inplace_tableContext) IsInplace_tableContext() {}

func NewInplace_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inplace_tableContext {
	var p = new(Inplace_tableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_inplace_table

	return p
}

func (s *Inplace_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *Inplace_tableContext) Table() ITableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *Inplace_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inplace_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inplace_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterInplace_table(s)
	}
}

func (s *Inplace_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitInplace_table(s)
	}
}

func (p *SyslParser) Inplace_table() (localctx IInplace_tableContext) {
	localctx = NewInplace_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SyslParserRULE_inplace_table)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(564)
		p.Table()
	}

	return localctx
}

// ITable_stmtsContext is an interface to support dynamic dispatch.
type ITable_stmtsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_stmtsContext differentiates from other interfaces.
	IsTable_stmtsContext()
}

type Table_stmtsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_stmtsContext() *Table_stmtsContext {
	var p = new(Table_stmtsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_table_stmts
	return p
}

func (*Table_stmtsContext) IsTable_stmtsContext() {}

func NewTable_stmtsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_stmtsContext {
	var p = new(Table_stmtsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_table_stmts

	return p
}

func (s *Table_stmtsContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_stmtsContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Table_stmtsContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Table_stmtsContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *Table_stmtsContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *Table_stmtsContext) AllField() []IFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFieldContext)(nil)).Elem())
	var tst = make([]IFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFieldContext)
		}
	}

	return tst
}

func (s *Table_stmtsContext) Field(i int) IFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFieldContext)
}

func (s *Table_stmtsContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *Table_stmtsContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *Table_stmtsContext) AllInplace_table() []IInplace_tableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInplace_tableContext)(nil)).Elem())
	var tst = make([]IInplace_tableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInplace_tableContext)
		}
	}

	return tst
}

func (s *Table_stmtsContext) Inplace_table(i int) IInplace_tableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInplace_tableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInplace_tableContext)
}

func (s *Table_stmtsContext) AllWHATEVER() []antlr.TerminalNode {
	return s.GetTokens(SyslParserWHATEVER)
}

func (s *Table_stmtsContext) WHATEVER(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, i)
}

func (s *Table_stmtsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_stmtsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_stmtsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTable_stmts(s)
	}
}

func (s *Table_stmtsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTable_stmts(s)
	}
}

func (p *SyslParser) Table_stmts() (localctx ITable_stmtsContext) {
	localctx = NewTable_stmtsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SyslParserRULE_table_stmts)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(566)
		p.Match(SyslParserINDENT)
	}
	p.SetState(572)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserTABLE)|(1<<SyslParserTYPE)|(1<<SyslParserWHATEVER))) != 0) || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SyslParserAT-44))|(1<<(SyslParserSYSL_COMMENT-44))|(1<<(SyslParserTEXT_LINE-44))|(1<<(SyslParserName-44)))) != 0) || _la == SyslParserE_Name {
		p.SetState(572)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(567)
				p.Match(SyslParserSYSL_COMMENT)
			}

		case 2:
			{
				p.SetState(568)
				p.Field()
			}

		case 3:
			{
				p.SetState(569)
				p.Annotation()
			}

		case 4:
			{
				p.SetState(570)
				p.Inplace_table()
			}

		case 5:
			{
				p.SetState(571)
				p.Match(SyslParserWHATEVER)
			}

		}

		p.SetState(574)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(576)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// ITable_defContext is an interface to support dynamic dispatch.
type ITable_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_defContext differentiates from other interfaces.
	IsTable_defContext()
}

type Table_defContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_defContext() *Table_defContext {
	var p = new(Table_defContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_table_def
	return p
}

func (*Table_defContext) IsTable_defContext() {}

func NewTable_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_defContext {
	var p = new(Table_defContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_table_def

	return p
}

func (s *Table_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_defContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Table_defContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *Table_defContext) Table_stmts() ITable_stmtsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_stmtsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_stmtsContext)
}

func (s *Table_defContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Table_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_defContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTable_def(s)
	}
}

func (s *Table_defContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTable_def(s)
	}
}

func (p *SyslParser) Table_def() (localctx ITable_defContext) {
	localctx = NewTable_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SyslParserRULE_table_def)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(579)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(578)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(581)
		p.Match(SyslParserCOLON)
	}
	p.SetState(584)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(582)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(583)
			p.Table_stmts()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITableContext is an interface to support dynamic dispatch.
type ITableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableContext differentiates from other interfaces.
	IsTableContext()
}

type TableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableContext() *TableContext {
	var p = new(TableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_table
	return p
}

func (*TableContext) IsTableContext() {}

func NewTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableContext {
	var p = new(TableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_table

	return p
}

func (s *TableContext) GetParser() antlr.Parser { return s.parser }

func (s *TableContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *TableContext) Table_def() ITable_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_defContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_defContext)
}

func (s *TableContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SyslParserTYPE, 0)
}

func (s *TableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SyslParserTABLE, 0)
}

func (s *TableContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *TableContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *TableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTable(s)
	}
}

func (s *TableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTable(s)
	}
}

func (p *SyslParser) Table() (localctx ITableContext) {
	localctx = NewTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SyslParserRULE_table)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(589)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserSYSL_COMMENT {
		{
			p.SetState(586)
			p.Match(SyslParserSYSL_COMMENT)
		}

		p.SetState(591)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(592)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserTABLE || _la == SyslParserTYPE) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(593)
		p.Name_str()
	}
	{
		p.SetState(594)
		p.Table_def()
	}

	return localctx
}

// IUnionContext is an interface to support dynamic dispatch.
type IUnionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnionContext differentiates from other interfaces.
	IsUnionContext()
}

type UnionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionContext() *UnionContext {
	var p = new(UnionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_union
	return p
}

func (*UnionContext) IsUnionContext() {}

func NewUnionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionContext {
	var p = new(UnionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_union

	return p
}

func (s *UnionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionContext) UNION() antlr.TerminalNode {
	return s.GetToken(SyslParserUNION, 0)
}

func (s *UnionContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *UnionContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *UnionContext) AllWHATEVER() []antlr.TerminalNode {
	return s.GetTokens(SyslParserWHATEVER)
}

func (s *UnionContext) WHATEVER(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, i)
}

func (s *UnionContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *UnionContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *UnionContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *UnionContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *UnionContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *UnionContext) AllUser_defined_type() []IUser_defined_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUser_defined_typeContext)(nil)).Elem())
	var tst = make([]IUser_defined_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUser_defined_typeContext)
		}
	}

	return tst
}

func (s *UnionContext) User_defined_type(i int) IUser_defined_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUser_defined_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUser_defined_typeContext)
}

func (s *UnionContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *UnionContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *UnionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterUnion(s)
	}
}

func (s *UnionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitUnion(s)
	}
}

func (p *SyslParser) Union() (localctx IUnionContext) {
	localctx = NewUnionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SyslParserRULE_union)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(599)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserSYSL_COMMENT {
		{
			p.SetState(596)
			p.Match(SyslParserSYSL_COMMENT)
		}

		p.SetState(601)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(602)
		p.Match(SyslParserUNION)
	}
	{
		p.SetState(603)
		p.Name_str()
	}
	p.SetState(605)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(604)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(607)
		p.Match(SyslParserCOLON)
	}
	p.SetState(619)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(608)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(609)
			p.Match(SyslParserINDENT)
		}
		p.SetState(614)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SyslParserWHATEVER || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SyslParserAT-44))|(1<<(SyslParserSYSL_COMMENT-44))|(1<<(SyslParserTEXT_LINE-44))|(1<<(SyslParserName-44)))) != 0) || _la == SyslParserE_Name {
			p.SetState(614)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case SyslParserSYSL_COMMENT:
				{
					p.SetState(610)
					p.Match(SyslParserSYSL_COMMENT)
				}

			case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
				{
					p.SetState(611)
					p.User_defined_type()
				}

			case SyslParserAT:
				{
					p.SetState(612)
					p.Annotation()
				}

			case SyslParserWHATEVER:
				{
					p.SetState(613)
					p.Match(SyslParserWHATEVER)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(616)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(618)
			p.Match(SyslParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPackage_nameContext is an interface to support dynamic dispatch.
type IPackage_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_nameContext differentiates from other interfaces.
	IsPackage_nameContext()
}

type Package_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_nameContext() *Package_nameContext {
	var p = new(Package_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_package_name
	return p
}

func (*Package_nameContext) IsPackage_nameContext() {}

func NewPackage_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_nameContext {
	var p = new(Package_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_package_name

	return p
}

func (s *Package_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_nameContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Package_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterPackage_name(s)
	}
}

func (s *Package_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitPackage_name(s)
	}
}

func (p *SyslParser) Package_name() (localctx IPackage_nameContext) {
	localctx = NewPackage_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SyslParserRULE_package_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(621)
		p.Name_str()
	}

	return localctx
}

// ISub_packageContext is an interface to support dynamic dispatch.
type ISub_packageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSub_packageContext differentiates from other interfaces.
	IsSub_packageContext()
}

type Sub_packageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySub_packageContext() *Sub_packageContext {
	var p = new(Sub_packageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_sub_package
	return p
}

func (*Sub_packageContext) IsSub_packageContext() {}

func NewSub_packageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sub_packageContext {
	var p = new(Sub_packageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_sub_package

	return p
}

func (s *Sub_packageContext) GetParser() antlr.Parser { return s.parser }

func (s *Sub_packageContext) NAME_SEP() antlr.TerminalNode {
	return s.GetToken(SyslParserNAME_SEP, 0)
}

func (s *Sub_packageContext) Package_name() IPackage_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_nameContext)
}

func (s *Sub_packageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sub_packageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sub_packageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSub_package(s)
	}
}

func (s *Sub_packageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSub_package(s)
	}
}

func (p *SyslParser) Sub_package() (localctx ISub_packageContext) {
	localctx = NewSub_packageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SyslParserRULE_sub_package)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(623)
		p.Match(SyslParserNAME_SEP)
	}
	{
		p.SetState(624)
		p.Package_name()
	}

	return localctx
}

// IApp_nameContext is an interface to support dynamic dispatch.
type IApp_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsApp_nameContext differentiates from other interfaces.
	IsApp_nameContext()
}

type App_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyApp_nameContext() *App_nameContext {
	var p = new(App_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_app_name
	return p
}

func (*App_nameContext) IsApp_nameContext() {}

func NewApp_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *App_nameContext {
	var p = new(App_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_app_name

	return p
}

func (s *App_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *App_nameContext) Package_name() IPackage_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_nameContext)
}

func (s *App_nameContext) AllSub_package() []ISub_packageContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISub_packageContext)(nil)).Elem())
	var tst = make([]ISub_packageContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISub_packageContext)
		}
	}

	return tst
}

func (s *App_nameContext) Sub_package(i int) ISub_packageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISub_packageContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISub_packageContext)
}

func (s *App_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *App_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *App_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterApp_name(s)
	}
}

func (s *App_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitApp_name(s)
	}
}

func (p *SyslParser) App_name() (localctx IApp_nameContext) {
	localctx = NewApp_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SyslParserRULE_app_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(626)
		p.Package_name()
	}
	p.SetState(630)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(627)
				p.Sub_package()
			}

		}
		p.SetState(632)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext())
	}

	return localctx
}

// IName_with_attribsContext is an interface to support dynamic dispatch.
type IName_with_attribsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_with_attribsContext differentiates from other interfaces.
	IsName_with_attribsContext()
}

type Name_with_attribsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_with_attribsContext() *Name_with_attribsContext {
	var p = new(Name_with_attribsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_name_with_attribs
	return p
}

func (*Name_with_attribsContext) IsName_with_attribsContext() {}

func NewName_with_attribsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_with_attribsContext {
	var p = new(Name_with_attribsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_name_with_attribs

	return p
}

func (s *Name_with_attribsContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_with_attribsContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *Name_with_attribsContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Name_with_attribsContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Name_with_attribsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_with_attribsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_with_attribsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterName_with_attribs(s)
	}
}

func (s *Name_with_attribsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitName_with_attribs(s)
	}
}

func (p *SyslParser) Name_with_attribs() (localctx IName_with_attribsContext) {
	localctx = NewName_with_attribsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SyslParserRULE_name_with_attribs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(633)
		p.App_name()
	}
	p.SetState(635)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQSTRING {
		{
			p.SetState(634)
			p.Match(SyslParserQSTRING)
		}

	}
	p.SetState(638)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(637)
			p.Attribs_or_modifiers()
		}

	}

	return localctx
}

// IModel_nameContext is an interface to support dynamic dispatch.
type IModel_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModel_nameContext differentiates from other interfaces.
	IsModel_nameContext()
}

type Model_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModel_nameContext() *Model_nameContext {
	var p = new(Model_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_model_name
	return p
}

func (*Model_nameContext) IsModel_nameContext() {}

func NewModel_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Model_nameContext {
	var p = new(Model_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_model_name

	return p
}

func (s *Model_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Model_nameContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Model_nameContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Model_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Model_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Model_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterModel_name(s)
	}
}

func (s *Model_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitModel_name(s)
	}
}

func (p *SyslParser) Model_name() (localctx IModel_nameContext) {
	localctx = NewModel_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SyslParserRULE_model_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(640)
		p.Match(SyslParserName)
	}
	{
		p.SetState(641)
		p.Match(SyslParserCOLON)
	}

	return localctx
}

// IInplace_table_defContext is an interface to support dynamic dispatch.
type IInplace_table_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInplace_table_defContext differentiates from other interfaces.
	IsInplace_table_defContext()
}

type Inplace_table_defContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInplace_table_defContext() *Inplace_table_defContext {
	var p = new(Inplace_table_defContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_inplace_table_def
	return p
}

func (*Inplace_table_defContext) IsInplace_table_defContext() {}

func NewInplace_table_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inplace_table_defContext {
	var p = new(Inplace_table_defContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_inplace_table_def

	return p
}

func (s *Inplace_table_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Inplace_table_defContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Inplace_table_defContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Inplace_table_defContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Inplace_table_defContext) AllName() []antlr.TerminalNode {
	return s.GetTokens(SyslParserName)
}

func (s *Inplace_table_defContext) Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserName, i)
}

func (s *Inplace_table_defContext) AllAttribs_or_modifiers() []IAttribs_or_modifiersContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem())
	var tst = make([]IAttribs_or_modifiersContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribs_or_modifiersContext)
		}
	}

	return tst
}

func (s *Inplace_table_defContext) Attribs_or_modifiers(i int) IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Inplace_table_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inplace_table_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inplace_table_defContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterInplace_table_def(s)
	}
}

func (s *Inplace_table_defContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitInplace_table_def(s)
	}
}

func (p *SyslParser) Inplace_table_def() (localctx IInplace_table_defContext) {
	localctx = NewInplace_table_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SyslParserRULE_inplace_table_def)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(643)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(644)
		p.Match(SyslParserINDENT)
	}
	p.SetState(649)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserName {
		{
			p.SetState(645)
			p.Match(SyslParserName)
		}
		p.SetState(647)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserSQ_OPEN {
			{
				p.SetState(646)
				p.Attribs_or_modifiers()
			}

		}

		p.SetState(651)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(653)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// ITable_refsContext is an interface to support dynamic dispatch.
type ITable_refsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_refsContext differentiates from other interfaces.
	IsTable_refsContext()
}

type Table_refsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_refsContext() *Table_refsContext {
	var p = new(Table_refsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_table_refs
	return p
}

func (*Table_refsContext) IsTable_refsContext() {}

func NewTable_refsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_refsContext {
	var p = new(Table_refsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_table_refs

	return p
}

func (s *Table_refsContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_refsContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Table_refsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SyslParserTABLE, 0)
}

func (s *Table_refsContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SyslParserTYPE, 0)
}

func (s *Table_refsContext) UNION() antlr.TerminalNode {
	return s.GetToken(SyslParserUNION, 0)
}

func (s *Table_refsContext) Inplace_table_def() IInplace_table_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInplace_table_defContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInplace_table_defContext)
}

func (s *Table_refsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_refsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_refsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTable_refs(s)
	}
}

func (s *Table_refsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTable_refs(s)
	}
}

func (p *SyslParser) Table_refs() (localctx ITable_refsContext) {
	localctx = NewTable_refsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SyslParserRULE_table_refs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(655)
	_la = p.GetTokenStream().LA(1)

	if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserTABLE)|(1<<SyslParserTYPE)|(1<<SyslParserUNION))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(656)
		p.Match(SyslParserName)
	}
	p.SetState(658)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserCOLON {
		{
			p.SetState(657)
			p.Inplace_table_def()
		}

	}

	return localctx
}

// IFacadeContext is an interface to support dynamic dispatch.
type IFacadeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFacadeContext differentiates from other interfaces.
	IsFacadeContext()
}

type FacadeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFacadeContext() *FacadeContext {
	var p = new(FacadeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_facade
	return p
}

func (*FacadeContext) IsFacadeContext() {}

func NewFacadeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FacadeContext {
	var p = new(FacadeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_facade

	return p
}

func (s *FacadeContext) GetParser() antlr.Parser { return s.parser }

func (s *FacadeContext) WRAP() antlr.TerminalNode {
	return s.GetToken(SyslParserWRAP, 0)
}

func (s *FacadeContext) Model_name() IModel_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModel_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModel_nameContext)
}

func (s *FacadeContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *FacadeContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *FacadeContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *FacadeContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *FacadeContext) AllTable_refs() []ITable_refsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITable_refsContext)(nil)).Elem())
	var tst = make([]ITable_refsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITable_refsContext)
		}
	}

	return tst
}

func (s *FacadeContext) Table_refs(i int) ITable_refsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_refsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITable_refsContext)
}

func (s *FacadeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FacadeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FacadeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFacade(s)
	}
}

func (s *FacadeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFacade(s)
	}
}

func (p *SyslParser) Facade() (localctx IFacadeContext) {
	localctx = NewFacadeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SyslParserRULE_facade)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(663)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserSYSL_COMMENT {
		{
			p.SetState(660)
			p.Match(SyslParserSYSL_COMMENT)
		}

		p.SetState(665)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(666)
		p.Match(SyslParserWRAP)
	}
	{
		p.SetState(667)
		p.Model_name()
	}
	{
		p.SetState(668)
		p.Match(SyslParserINDENT)
	}
	p.SetState(670)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserTABLE)|(1<<SyslParserTYPE)|(1<<SyslParserUNION))) != 0) {
		{
			p.SetState(669)
			p.Table_refs()
		}

		p.SetState(672)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(674)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IDocumentation_stmtsContext is an interface to support dynamic dispatch.
type IDocumentation_stmtsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDocumentation_stmtsContext differentiates from other interfaces.
	IsDocumentation_stmtsContext()
}

type Documentation_stmtsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDocumentation_stmtsContext() *Documentation_stmtsContext {
	var p = new(Documentation_stmtsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_documentation_stmts
	return p
}

func (*Documentation_stmtsContext) IsDocumentation_stmtsContext() {}

func NewDocumentation_stmtsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Documentation_stmtsContext {
	var p = new(Documentation_stmtsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_documentation_stmts

	return p
}

func (s *Documentation_stmtsContext) GetParser() antlr.Parser { return s.parser }

func (s *Documentation_stmtsContext) AT() antlr.TerminalNode {
	return s.GetToken(SyslParserAT, 0)
}

func (s *Documentation_stmtsContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Documentation_stmtsContext) EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserEQ, 0)
}

func (s *Documentation_stmtsContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Documentation_stmtsContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(SyslParserNEWLINE, 0)
}

func (s *Documentation_stmtsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Documentation_stmtsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Documentation_stmtsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterDocumentation_stmts(s)
	}
}

func (s *Documentation_stmtsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitDocumentation_stmts(s)
	}
}

func (p *SyslParser) Documentation_stmts() (localctx IDocumentation_stmtsContext) {
	localctx = NewDocumentation_stmtsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SyslParserRULE_documentation_stmts)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(676)
		p.Match(SyslParserAT)
	}
	{
		p.SetState(677)
		p.Match(SyslParserName)
	}
	{
		p.SetState(678)
		p.Match(SyslParserEQ)
	}
	{
		p.SetState(679)
		p.Match(SyslParserQSTRING)
	}
	{
		p.SetState(680)
		p.Match(SyslParserNEWLINE)
	}

	return localctx
}

// IVar_in_curlyContext is an interface to support dynamic dispatch.
type IVar_in_curlyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVar_in_curlyContext differentiates from other interfaces.
	IsVar_in_curlyContext()
}

type Var_in_curlyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVar_in_curlyContext() *Var_in_curlyContext {
	var p = new(Var_in_curlyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_var_in_curly
	return p
}

func (*Var_in_curlyContext) IsVar_in_curlyContext() {}

func NewVar_in_curlyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Var_in_curlyContext {
	var p = new(Var_in_curlyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_var_in_curly

	return p
}

func (s *Var_in_curlyContext) GetParser() antlr.Parser { return s.parser }

func (s *Var_in_curlyContext) CURLY_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_OPEN, 0)
}

func (s *Var_in_curlyContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Var_in_curlyContext) CURLY_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_CLOSE, 0)
}

func (s *Var_in_curlyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Var_in_curlyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Var_in_curlyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterVar_in_curly(s)
	}
}

func (s *Var_in_curlyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitVar_in_curly(s)
	}
}

func (p *SyslParser) Var_in_curly() (localctx IVar_in_curlyContext) {
	localctx = NewVar_in_curlyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SyslParserRULE_var_in_curly)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(682)
		p.Match(SyslParserCURLY_OPEN)
	}
	{
		p.SetState(683)
		p.Match(SyslParserName)
	}
	{
		p.SetState(684)
		p.Match(SyslParserCURLY_CLOSE)
	}

	return localctx
}

// IQuery_varContext is an interface to support dynamic dispatch.
type IQuery_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuery_varContext differentiates from other interfaces.
	IsQuery_varContext()
}

type Query_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_varContext() *Query_varContext {
	var p = new(Query_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_query_var
	return p
}

func (*Query_varContext) IsQuery_varContext() {}

func NewQuery_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_varContext {
	var p = new(Query_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_query_var

	return p
}

func (s *Query_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_varContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Query_varContext) EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserEQ, 0)
}

func (s *Query_varContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Query_varContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Query_varContext) Var_in_curly() IVar_in_curlyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVar_in_curlyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVar_in_curlyContext)
}

func (s *Query_varContext) QN() antlr.TerminalNode {
	return s.GetToken(SyslParserQN, 0)
}

func (s *Query_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Query_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterQuery_var(s)
	}
}

func (s *Query_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitQuery_var(s)
	}
}

func (p *SyslParser) Query_var() (localctx IQuery_varContext) {
	localctx = NewQuery_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SyslParserRULE_query_var)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(686)
		p.Match(SyslParserName)
	}
	{
		p.SetState(687)
		p.Match(SyslParserEQ)
	}
	p.SetState(691)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserNativeDataTypes:
		{
			p.SetState(688)
			p.Match(SyslParserNativeDataTypes)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(689)
			p.Name_str()
		}

	case SyslParserCURLY_OPEN:
		{
			p.SetState(690)
			p.Var_in_curly()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(694)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQN {
		{
			p.SetState(693)
			p.Match(SyslParserQN)
		}

	}

	return localctx
}

// IQuery_paramContext is an interface to support dynamic dispatch.
type IQuery_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuery_paramContext differentiates from other interfaces.
	IsQuery_paramContext()
}

type Query_paramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_paramContext() *Query_paramContext {
	var p = new(Query_paramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_query_param
	return p
}

func (*Query_paramContext) IsQuery_paramContext() {}

func NewQuery_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_paramContext {
	var p = new(Query_paramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_query_param

	return p
}

func (s *Query_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_paramContext) QN() antlr.TerminalNode {
	return s.GetToken(SyslParserQN, 0)
}

func (s *Query_paramContext) AllQuery_var() []IQuery_varContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQuery_varContext)(nil)).Elem())
	var tst = make([]IQuery_varContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQuery_varContext)
		}
	}

	return tst
}

func (s *Query_paramContext) Query_var(i int) IQuery_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuery_varContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQuery_varContext)
}

func (s *Query_paramContext) AllAMP() []antlr.TerminalNode {
	return s.GetTokens(SyslParserAMP)
}

func (s *Query_paramContext) AMP(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserAMP, i)
}

func (s *Query_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Query_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterQuery_param(s)
	}
}

func (s *Query_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitQuery_param(s)
	}
}

func (p *SyslParser) Query_param() (localctx IQuery_paramContext) {
	localctx = NewQuery_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SyslParserRULE_query_param)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(696)
		p.Match(SyslParserQN)
	}
	{
		p.SetState(697)
		p.Query_var()
	}
	p.SetState(702)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserAMP {
		{
			p.SetState(698)
			p.Match(SyslParserAMP)
		}
		{
			p.SetState(699)
			p.Query_var()
		}

		p.SetState(704)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IHttp_path_partContext is an interface to support dynamic dispatch.
type IHttp_path_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_path_partContext differentiates from other interfaces.
	IsHttp_path_partContext()
}

type Http_path_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_path_partContext() *Http_path_partContext {
	var p = new(Http_path_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path_part
	return p
}

func (*Http_path_partContext) IsHttp_path_partContext() {}

func NewHttp_path_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_path_partContext {
	var p = new(Http_path_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path_part

	return p
}

func (s *Http_path_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_path_partContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Http_path_partContext) DIGITS() antlr.TerminalNode {
	return s.GetToken(SyslParserDIGITS, 0)
}

func (s *Http_path_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_path_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_path_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path_part(s)
	}
}

func (s *Http_path_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path_part(s)
	}
}

func (p *SyslParser) Http_path_part() (localctx IHttp_path_partContext) {
	localctx = NewHttp_path_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SyslParserRULE_http_path_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(707)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(705)
			p.Name_str()
		}

	case SyslParserDIGITS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(706)
			p.Match(SyslParserDIGITS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IHttp_path_var_with_typeContext is an interface to support dynamic dispatch.
type IHttp_path_var_with_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_path_var_with_typeContext differentiates from other interfaces.
	IsHttp_path_var_with_typeContext()
}

type Http_path_var_with_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_path_var_with_typeContext() *Http_path_var_with_typeContext {
	var p = new(Http_path_var_with_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path_var_with_type
	return p
}

func (*Http_path_var_with_typeContext) IsHttp_path_var_with_typeContext() {}

func NewHttp_path_var_with_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_path_var_with_typeContext {
	var p = new(Http_path_var_with_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path_var_with_type

	return p
}

func (s *Http_path_var_with_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_path_var_with_typeContext) CURLY_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_OPEN, 0)
}

func (s *Http_path_var_with_typeContext) Http_path_part() IHttp_path_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_partContext)
}

func (s *Http_path_var_with_typeContext) LESS_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserLESS_COLON, 0)
}

func (s *Http_path_var_with_typeContext) CURLY_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_CLOSE, 0)
}

func (s *Http_path_var_with_typeContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Http_path_var_with_typeContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Http_path_var_with_typeContext) Reference() IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *Http_path_var_with_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_path_var_with_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_path_var_with_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path_var_with_type(s)
	}
}

func (s *Http_path_var_with_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path_var_with_type(s)
	}
}

func (p *SyslParser) Http_path_var_with_type() (localctx IHttp_path_var_with_typeContext) {
	localctx = NewHttp_path_var_with_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SyslParserRULE_http_path_var_with_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(709)
		p.Match(SyslParserCURLY_OPEN)
	}
	{
		p.SetState(710)
		p.Http_path_part()
	}
	{
		p.SetState(711)
		p.Match(SyslParserLESS_COLON)
	}
	p.SetState(715)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(712)
			p.Match(SyslParserNativeDataTypes)
		}

	case 2:
		{
			p.SetState(713)
			p.Name_str()
		}

	case 3:
		{
			p.SetState(714)
			p.Reference()
		}

	}
	{
		p.SetState(717)
		p.Match(SyslParserCURLY_CLOSE)
	}

	return localctx
}

// IHttp_path_staticContext is an interface to support dynamic dispatch.
type IHttp_path_staticContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_path_staticContext differentiates from other interfaces.
	IsHttp_path_staticContext()
}

type Http_path_staticContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_path_staticContext() *Http_path_staticContext {
	var p = new(Http_path_staticContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path_static
	return p
}

func (*Http_path_staticContext) IsHttp_path_staticContext() {}

func NewHttp_path_staticContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_path_staticContext {
	var p = new(Http_path_staticContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path_static

	return p
}

func (s *Http_path_staticContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_path_staticContext) Http_path_part() IHttp_path_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_partContext)
}

func (s *Http_path_staticContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_path_staticContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_path_staticContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path_static(s)
	}
}

func (s *Http_path_staticContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path_static(s)
	}
}

func (p *SyslParser) Http_path_static() (localctx IHttp_path_staticContext) {
	localctx = NewHttp_path_staticContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SyslParserRULE_http_path_static)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(719)
		p.Http_path_part()
	}

	return localctx
}

// IHttp_path_suffixContext is an interface to support dynamic dispatch.
type IHttp_path_suffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_path_suffixContext differentiates from other interfaces.
	IsHttp_path_suffixContext()
}

type Http_path_suffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_path_suffixContext() *Http_path_suffixContext {
	var p = new(Http_path_suffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path_suffix
	return p
}

func (*Http_path_suffixContext) IsHttp_path_suffixContext() {}

func NewHttp_path_suffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_path_suffixContext {
	var p = new(Http_path_suffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path_suffix

	return p
}

func (s *Http_path_suffixContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_path_suffixContext) FORWARD_SLASH() antlr.TerminalNode {
	return s.GetToken(SyslParserFORWARD_SLASH, 0)
}

func (s *Http_path_suffixContext) Http_path_static() IHttp_path_staticContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_staticContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_staticContext)
}

func (s *Http_path_suffixContext) Http_path_var_with_type() IHttp_path_var_with_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_var_with_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_var_with_typeContext)
}

func (s *Http_path_suffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_path_suffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_path_suffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path_suffix(s)
	}
}

func (s *Http_path_suffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path_suffix(s)
	}
}

func (p *SyslParser) Http_path_suffix() (localctx IHttp_path_suffixContext) {
	localctx = NewHttp_path_suffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SyslParserRULE_http_path_suffix)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(721)
		p.Match(SyslParserFORWARD_SLASH)
	}
	p.SetState(724)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserDIGITS, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(722)
			p.Http_path_static()
		}

	case SyslParserCURLY_OPEN:
		{
			p.SetState(723)
			p.Http_path_var_with_type()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IHttp_pathContext is an interface to support dynamic dispatch.
type IHttp_pathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_pathContext differentiates from other interfaces.
	IsHttp_pathContext()
}

type Http_pathContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_pathContext() *Http_pathContext {
	var p = new(Http_pathContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path
	return p
}

func (*Http_pathContext) IsHttp_pathContext() {}

func NewHttp_pathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_pathContext {
	var p = new(Http_pathContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path

	return p
}

func (s *Http_pathContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_pathContext) FORWARD_SLASH() antlr.TerminalNode {
	return s.GetToken(SyslParserFORWARD_SLASH, 0)
}

func (s *Http_pathContext) AllHttp_path_suffix() []IHttp_path_suffixContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHttp_path_suffixContext)(nil)).Elem())
	var tst = make([]IHttp_path_suffixContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHttp_path_suffixContext)
		}
	}

	return tst
}

func (s *Http_pathContext) Http_path_suffix(i int) IHttp_path_suffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_suffixContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_suffixContext)
}

func (s *Http_pathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_pathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_pathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path(s)
	}
}

func (s *Http_pathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path(s)
	}
}

func (p *SyslParser) Http_path() (localctx IHttp_pathContext) {
	localctx = NewHttp_pathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SyslParserRULE_http_path)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(732)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(726)
			p.Match(SyslParserFORWARD_SLASH)
		}

	case 2:
		p.SetState(728)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SyslParserFORWARD_SLASH {
			{
				p.SetState(727)
				p.Http_path_suffix()
			}

			p.SetState(730)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IEndpoint_nameContext is an interface to support dynamic dispatch.
type IEndpoint_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEndpoint_nameContext differentiates from other interfaces.
	IsEndpoint_nameContext()
}

type Endpoint_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndpoint_nameContext() *Endpoint_nameContext {
	var p = new(Endpoint_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_endpoint_name
	return p
}

func (*Endpoint_nameContext) IsEndpoint_nameContext() {}

func NewEndpoint_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Endpoint_nameContext {
	var p = new(Endpoint_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_endpoint_name

	return p
}

func (s *Endpoint_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Endpoint_nameContext) AllName_str() []IName_strContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IName_strContext)(nil)).Elem())
	var tst = make([]IName_strContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IName_strContext)
		}
	}

	return tst
}

func (s *Endpoint_nameContext) Name_str(i int) IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Endpoint_nameContext) AllFORWARD_SLASH() []antlr.TerminalNode {
	return s.GetTokens(SyslParserFORWARD_SLASH)
}

func (s *Endpoint_nameContext) FORWARD_SLASH(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserFORWARD_SLASH, i)
}

func (s *Endpoint_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Endpoint_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Endpoint_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterEndpoint_name(s)
	}
}

func (s *Endpoint_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitEndpoint_name(s)
	}
}

func (p *SyslParser) Endpoint_name() (localctx IEndpoint_nameContext) {
	localctx = NewEndpoint_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SyslParserRULE_endpoint_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(734)
		p.Name_str()
	}
	p.SetState(739)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserFORWARD_SLASH {
		{
			p.SetState(735)
			p.Match(SyslParserFORWARD_SLASH)
		}
		{
			p.SetState(736)
			p.Name_str()
		}

		p.SetState(741)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IRet_stmtContext is an interface to support dynamic dispatch.
type IRet_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRet_stmtContext differentiates from other interfaces.
	IsRet_stmtContext()
}

type Ret_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRet_stmtContext() *Ret_stmtContext {
	var p = new(Ret_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_ret_stmt
	return p
}

func (*Ret_stmtContext) IsRet_stmtContext() {}

func NewRet_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ret_stmtContext {
	var p = new(Ret_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_ret_stmt

	return p
}

func (s *Ret_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Ret_stmtContext) RETURN() antlr.TerminalNode {
	return s.GetToken(SyslParserRETURN, 0)
}

func (s *Ret_stmtContext) TEXT() antlr.TerminalNode {
	return s.GetToken(SyslParserTEXT, 0)
}

func (s *Ret_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ret_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ret_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRet_stmt(s)
	}
}

func (s *Ret_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRet_stmt(s)
	}
}

func (p *SyslParser) Ret_stmt() (localctx IRet_stmtContext) {
	localctx = NewRet_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SyslParserRULE_ret_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(742)
		p.Match(SyslParserRETURN)
	}
	{
		p.SetState(743)
		p.Match(SyslParserTEXT)
	}

	return localctx
}

// ITargetContext is an interface to support dynamic dispatch.
type ITargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTargetContext differentiates from other interfaces.
	IsTargetContext()
}

type TargetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetContext() *TargetContext {
	var p = new(TargetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_target
	return p
}

func (*TargetContext) IsTargetContext() {}

func NewTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetContext {
	var p = new(TargetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_target

	return p
}

func (s *TargetContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *TargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTarget(s)
	}
}

func (s *TargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTarget(s)
	}
}

func (p *SyslParser) Target() (localctx ITargetContext) {
	localctx = NewTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SyslParserRULE_target)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(745)
		p.App_name()
	}

	return localctx
}

// ITarget_endpointContext is an interface to support dynamic dispatch.
type ITarget_endpointContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTarget_endpointContext differentiates from other interfaces.
	IsTarget_endpointContext()
}

type Target_endpointContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTarget_endpointContext() *Target_endpointContext {
	var p = new(Target_endpointContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_target_endpoint
	return p
}

func (*Target_endpointContext) IsTarget_endpointContext() {}

func NewTarget_endpointContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Target_endpointContext {
	var p = new(Target_endpointContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_target_endpoint

	return p
}

func (s *Target_endpointContext) GetParser() antlr.Parser { return s.parser }

func (s *Target_endpointContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Target_endpointContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Target_endpointContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Target_endpointContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTarget_endpoint(s)
	}
}

func (s *Target_endpointContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTarget_endpoint(s)
	}
}

func (p *SyslParser) Target_endpoint() (localctx ITarget_endpointContext) {
	localctx = NewTarget_endpointContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, SyslParserRULE_target_endpoint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(747)
		p.Name_str()
	}

	return localctx
}

// ICall_argContext is an interface to support dynamic dispatch.
type ICall_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCall_argContext differentiates from other interfaces.
	IsCall_argContext()
}

type Call_argContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCall_argContext() *Call_argContext {
	var p = new(Call_argContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_call_arg
	return p
}

func (*Call_argContext) IsCall_argContext() {}

func NewCall_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Call_argContext {
	var p = new(Call_argContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_call_arg

	return p
}

func (s *Call_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Call_argContext) AllQSTRING() []antlr.TerminalNode {
	return s.GetTokens(SyslParserQSTRING)
}

func (s *Call_argContext) QSTRING(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, i)
}

func (s *Call_argContext) AllName_str() []IName_strContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IName_strContext)(nil)).Elem())
	var tst = make([]IName_strContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IName_strContext)
		}
	}

	return tst
}

func (s *Call_argContext) Name_str(i int) IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Call_argContext) LESS_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserLESS_COLON, 0)
}

func (s *Call_argContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Call_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Call_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Call_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCall_arg(s)
	}
}

func (s *Call_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCall_arg(s)
	}
}

func (p *SyslParser) Call_arg() (localctx ICall_argContext) {
	localctx = NewCall_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SyslParserRULE_call_arg)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(761)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(751)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la-58)&-(0x1f+1)) == 0 && ((1<<uint((_la-58)))&((1<<(SyslParserQSTRING-58))|(1<<(SyslParserTEXT_LINE-58))|(1<<(SyslParserName-58)))) != 0) || _la == SyslParserE_Name {
			p.SetState(751)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case SyslParserQSTRING:
				{
					p.SetState(749)
					p.Match(SyslParserQSTRING)
				}

			case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
				{
					p.SetState(750)
					p.Name_str()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(753)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(755)
			p.Name_str()
		}
		{
			p.SetState(756)
			p.Match(SyslParserLESS_COLON)
		}
		p.SetState(759)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
			{
				p.SetState(757)
				p.Name_str()
			}

		case SyslParserNativeDataTypes:
			{
				p.SetState(758)
				p.Match(SyslParserNativeDataTypes)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// ICall_argsContext is an interface to support dynamic dispatch.
type ICall_argsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCall_argsContext differentiates from other interfaces.
	IsCall_argsContext()
}

type Call_argsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCall_argsContext() *Call_argsContext {
	var p = new(Call_argsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_call_args
	return p
}

func (*Call_argsContext) IsCall_argsContext() {}

func NewCall_argsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Call_argsContext {
	var p = new(Call_argsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_call_args

	return p
}

func (s *Call_argsContext) GetParser() antlr.Parser { return s.parser }

func (s *Call_argsContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *Call_argsContext) AllCall_arg() []ICall_argContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICall_argContext)(nil)).Elem())
	var tst = make([]ICall_argContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICall_argContext)
		}
	}

	return tst
}

func (s *Call_argsContext) Call_arg(i int) ICall_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_argContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICall_argContext)
}

func (s *Call_argsContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *Call_argsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Call_argsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Call_argsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Call_argsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Call_argsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCall_args(s)
	}
}

func (s *Call_argsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCall_args(s)
	}
}

func (p *SyslParser) Call_args() (localctx ICall_argsContext) {
	localctx = NewCall_argsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, SyslParserRULE_call_args)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(763)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(764)
		p.Call_arg()
	}
	p.SetState(769)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(765)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(766)
			p.Call_arg()
		}

		p.SetState(771)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(772)
		p.Match(SyslParserCLOSE_PAREN)
	}

	return localctx
}

// ICall_stmtContext is an interface to support dynamic dispatch.
type ICall_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCall_stmtContext differentiates from other interfaces.
	IsCall_stmtContext()
}

type Call_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCall_stmtContext() *Call_stmtContext {
	var p = new(Call_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_call_stmt
	return p
}

func (*Call_stmtContext) IsCall_stmtContext() {}

func NewCall_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Call_stmtContext {
	var p = new(Call_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_call_stmt

	return p
}

func (s *Call_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Call_stmtContext) Target_endpoint() ITarget_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITarget_endpointContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITarget_endpointContext)
}

func (s *Call_stmtContext) DOT_ARROW() antlr.TerminalNode {
	return s.GetToken(SyslParserDOT_ARROW, 0)
}

func (s *Call_stmtContext) Target() ITargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITargetContext)
}

func (s *Call_stmtContext) ARROW_LEFT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_LEFT, 0)
}

func (s *Call_stmtContext) Call_args() ICall_argsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_argsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICall_argsContext)
}

func (s *Call_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Call_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Call_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCall_stmt(s)
	}
}

func (s *Call_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCall_stmt(s)
	}
}

func (p *SyslParser) Call_stmt() (localctx ICall_stmtContext) {
	localctx = NewCall_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, SyslParserRULE_call_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(778)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserDOT_ARROW:
		{
			p.SetState(774)
			p.Match(SyslParserDOT_ARROW)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(775)
			p.Target()
		}
		{
			p.SetState(776)
			p.Match(SyslParserARROW_LEFT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(780)
		p.Target_endpoint()
	}
	p.SetState(782)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserOPEN_PAREN {
		{
			p.SetState(781)
			p.Call_args()
		}

	}

	return localctx
}

// IIf_stmtContext is an interface to support dynamic dispatch.
type IIf_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_stmtContext differentiates from other interfaces.
	IsIf_stmtContext()
}

type If_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_stmtContext() *If_stmtContext {
	var p = new(If_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_stmt
	return p
}

func (*If_stmtContext) IsIf_stmtContext() {}

func NewIf_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_stmtContext {
	var p = new(If_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_stmt

	return p
}

func (s *If_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(SyslParserIF, 0)
}

func (s *If_stmtContext) PREDICATE_VALUE() antlr.TerminalNode {
	return s.GetToken(SyslParserPREDICATE_VALUE, 0)
}

func (s *If_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *If_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *If_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *If_stmtContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *If_stmtContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *If_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_stmt(s)
	}
}

func (s *If_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_stmt(s)
	}
}

func (p *SyslParser) If_stmt() (localctx IIf_stmtContext) {
	localctx = NewIf_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, SyslParserRULE_if_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(784)
		p.Match(SyslParserIF)
	}
	{
		p.SetState(785)
		p.Match(SyslParserPREDICATE_VALUE)
	}
	{
		p.SetState(786)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(787)
		p.Match(SyslParserINDENT)
	}
	p.SetState(791)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SyslParserAT-44))|(1<<(SyslParserPIPE-44))|(1<<(SyslParserQSTRING-44))|(1<<(SyslParserSYSL_COMMENT-44))|(1<<(SyslParserTEXT_LINE-44))|(1<<(SyslParserName-44)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(788)
			p.Statements()
		}

		p.SetState(793)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(794)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IElse_stmtContext is an interface to support dynamic dispatch.
type IElse_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElse_stmtContext differentiates from other interfaces.
	IsElse_stmtContext()
}

type Else_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElse_stmtContext() *Else_stmtContext {
	var p = new(Else_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_else_stmt
	return p
}

func (*Else_stmtContext) IsElse_stmtContext() {}

func NewElse_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Else_stmtContext {
	var p = new(Else_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_else_stmt

	return p
}

func (s *Else_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Else_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SyslParserELSE, 0)
}

func (s *Else_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Else_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Else_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Else_stmtContext) PREDICATE_VALUE() antlr.TerminalNode {
	return s.GetToken(SyslParserPREDICATE_VALUE, 0)
}

func (s *Else_stmtContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *Else_stmtContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *Else_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Else_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Else_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterElse_stmt(s)
	}
}

func (s *Else_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitElse_stmt(s)
	}
}

func (p *SyslParser) Else_stmt() (localctx IElse_stmtContext) {
	localctx = NewElse_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SyslParserRULE_else_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(796)
		p.Match(SyslParserELSE)
	}
	p.SetState(798)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserPREDICATE_VALUE {
		{
			p.SetState(797)
			p.Match(SyslParserPREDICATE_VALUE)
		}

	}
	{
		p.SetState(800)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(801)
		p.Match(SyslParserINDENT)
	}
	p.SetState(805)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SyslParserAT-44))|(1<<(SyslParserPIPE-44))|(1<<(SyslParserQSTRING-44))|(1<<(SyslParserSYSL_COMMENT-44))|(1<<(SyslParserTEXT_LINE-44))|(1<<(SyslParserName-44)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(802)
			p.Statements()
		}

		p.SetState(807)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(808)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IIf_elseContext is an interface to support dynamic dispatch.
type IIf_elseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_elseContext differentiates from other interfaces.
	IsIf_elseContext()
}

type If_elseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_elseContext() *If_elseContext {
	var p = new(If_elseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_else
	return p
}

func (*If_elseContext) IsIf_elseContext() {}

func NewIf_elseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_elseContext {
	var p = new(If_elseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_else

	return p
}

func (s *If_elseContext) GetParser() antlr.Parser { return s.parser }

func (s *If_elseContext) If_stmt() IIf_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_stmtContext)
}

func (s *If_elseContext) AllElse_stmt() []IElse_stmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElse_stmtContext)(nil)).Elem())
	var tst = make([]IElse_stmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElse_stmtContext)
		}
	}

	return tst
}

func (s *If_elseContext) Else_stmt(i int) IElse_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElse_stmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElse_stmtContext)
}

func (s *If_elseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_elseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_elseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_else(s)
	}
}

func (s *If_elseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_else(s)
	}
}

func (p *SyslParser) If_else() (localctx IIf_elseContext) {
	localctx = NewIf_elseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SyslParserRULE_if_else)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(810)
		p.If_stmt()
	}
	p.SetState(814)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserELSE {
		{
			p.SetState(811)
			p.Else_stmt()
		}

		p.SetState(816)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFor_stmtContext is an interface to support dynamic dispatch.
type IFor_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_stmtContext differentiates from other interfaces.
	IsFor_stmtContext()
}

type For_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_stmtContext() *For_stmtContext {
	var p = new(For_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_for_stmt
	return p
}

func (*For_stmtContext) IsFor_stmtContext() {}

func NewFor_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_stmtContext {
	var p = new(For_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_for_stmt

	return p
}

func (s *For_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *For_stmtContext) PREDICATE_VALUE() antlr.TerminalNode {
	return s.GetToken(SyslParserPREDICATE_VALUE, 0)
}

func (s *For_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *For_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *For_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *For_stmtContext) ALT() antlr.TerminalNode {
	return s.GetToken(SyslParserALT, 0)
}

func (s *For_stmtContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(SyslParserUNTIL, 0)
}

func (s *For_stmtContext) FOR_EACH() antlr.TerminalNode {
	return s.GetToken(SyslParserFOR_EACH, 0)
}

func (s *For_stmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(SyslParserFOR, 0)
}

func (s *For_stmtContext) LOOP() antlr.TerminalNode {
	return s.GetToken(SyslParserLOOP, 0)
}

func (s *For_stmtContext) WHILE() antlr.TerminalNode {
	return s.GetToken(SyslParserWHILE, 0)
}

func (s *For_stmtContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *For_stmtContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *For_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFor_stmt(s)
	}
}

func (s *For_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFor_stmt(s)
	}
}

func (p *SyslParser) For_stmt() (localctx IFor_stmtContext) {
	localctx = NewFor_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SyslParserRULE_for_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(817)
	_la = p.GetTokenStream().LA(1)

	if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(818)
		p.Match(SyslParserPREDICATE_VALUE)
	}
	{
		p.SetState(819)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(820)
		p.Match(SyslParserINDENT)
	}
	p.SetState(824)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SyslParserAT-44))|(1<<(SyslParserPIPE-44))|(1<<(SyslParserQSTRING-44))|(1<<(SyslParserSYSL_COMMENT-44))|(1<<(SyslParserTEXT_LINE-44))|(1<<(SyslParserName-44)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(821)
			p.Statements()
		}

		p.SetState(826)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(827)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IHttp_method_commentContext is an interface to support dynamic dispatch.
type IHttp_method_commentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_method_commentContext differentiates from other interfaces.
	IsHttp_method_commentContext()
}

type Http_method_commentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_method_commentContext() *Http_method_commentContext {
	var p = new(Http_method_commentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_method_comment
	return p
}

func (*Http_method_commentContext) IsHttp_method_commentContext() {}

func NewHttp_method_commentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_method_commentContext {
	var p = new(Http_method_commentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_method_comment

	return p
}

func (s *Http_method_commentContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_method_commentContext) SYSL_COMMENT() antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, 0)
}

func (s *Http_method_commentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_method_commentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_method_commentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_method_comment(s)
	}
}

func (s *Http_method_commentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_method_comment(s)
	}
}

func (p *SyslParser) Http_method_comment() (localctx IHttp_method_commentContext) {
	localctx = NewHttp_method_commentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, SyslParserRULE_http_method_comment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(829)
		p.Match(SyslParserSYSL_COMMENT)
	}

	return localctx
}

// IGroup_stmtContext is an interface to support dynamic dispatch.
type IGroup_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroup_stmtContext differentiates from other interfaces.
	IsGroup_stmtContext()
}

type Group_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_stmtContext() *Group_stmtContext {
	var p = new(Group_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_group_stmt
	return p
}

func (*Group_stmtContext) IsGroup_stmtContext() {}

func NewGroup_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_stmtContext {
	var p = new(Group_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_group_stmt

	return p
}

func (s *Group_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_stmtContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Group_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Group_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Group_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Group_stmtContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *Group_stmtContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *Group_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Group_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterGroup_stmt(s)
	}
}

func (s *Group_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitGroup_stmt(s)
	}
}

func (p *SyslParser) Group_stmt() (localctx IGroup_stmtContext) {
	localctx = NewGroup_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, SyslParserRULE_group_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(831)
		p.Name_str()
	}
	{
		p.SetState(832)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(833)
		p.Match(SyslParserINDENT)
	}
	p.SetState(835)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SyslParserAT-44))|(1<<(SyslParserPIPE-44))|(1<<(SyslParserQSTRING-44))|(1<<(SyslParserSYSL_COMMENT-44))|(1<<(SyslParserTEXT_LINE-44))|(1<<(SyslParserName-44)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(834)
			p.Statements()
		}

		p.SetState(837)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(839)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IOne_of_case_labelContext is an interface to support dynamic dispatch.
type IOne_of_case_labelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOne_of_case_labelContext differentiates from other interfaces.
	IsOne_of_case_labelContext()
}

type One_of_case_labelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOne_of_case_labelContext() *One_of_case_labelContext {
	var p = new(One_of_case_labelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_one_of_case_label
	return p
}

func (*One_of_case_labelContext) IsOne_of_case_labelContext() {}

func NewOne_of_case_labelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *One_of_case_labelContext {
	var p = new(One_of_case_labelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_one_of_case_label

	return p
}

func (s *One_of_case_labelContext) GetParser() antlr.Parser { return s.parser }

func (s *One_of_case_labelContext) AllName() []antlr.TerminalNode {
	return s.GetTokens(SyslParserName)
}

func (s *One_of_case_labelContext) Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserName, i)
}

func (s *One_of_case_labelContext) AllTEXT_LINE() []antlr.TerminalNode {
	return s.GetTokens(SyslParserTEXT_LINE)
}

func (s *One_of_case_labelContext) TEXT_LINE(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserTEXT_LINE, i)
}

func (s *One_of_case_labelContext) AllQSTRING() []antlr.TerminalNode {
	return s.GetTokens(SyslParserQSTRING)
}

func (s *One_of_case_labelContext) QSTRING(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, i)
}

func (s *One_of_case_labelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *One_of_case_labelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *One_of_case_labelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterOne_of_case_label(s)
	}
}

func (s *One_of_case_labelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitOne_of_case_label(s)
	}
}

func (p *SyslParser) One_of_case_label() (localctx IOne_of_case_labelContext) {
	localctx = NewOne_of_case_labelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, SyslParserRULE_one_of_case_label)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(842)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-58)&-(0x1f+1)) == 0 && ((1<<uint((_la-58)))&((1<<(SyslParserQSTRING-58))|(1<<(SyslParserTEXT_LINE-58))|(1<<(SyslParserName-58)))) != 0) {
		p.SetState(841)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-58)&-(0x1f+1)) == 0 && ((1<<uint((_la-58)))&((1<<(SyslParserQSTRING-58))|(1<<(SyslParserTEXT_LINE-58))|(1<<(SyslParserName-58)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

		p.SetState(844)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOne_of_casesContext is an interface to support dynamic dispatch.
type IOne_of_casesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOne_of_casesContext differentiates from other interfaces.
	IsOne_of_casesContext()
}

type One_of_casesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOne_of_casesContext() *One_of_casesContext {
	var p = new(One_of_casesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_one_of_cases
	return p
}

func (*One_of_casesContext) IsOne_of_casesContext() {}

func NewOne_of_casesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *One_of_casesContext {
	var p = new(One_of_casesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_one_of_cases

	return p
}

func (s *One_of_casesContext) GetParser() antlr.Parser { return s.parser }

func (s *One_of_casesContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *One_of_casesContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *One_of_casesContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *One_of_casesContext) One_of_case_label() IOne_of_case_labelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOne_of_case_labelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOne_of_case_labelContext)
}

func (s *One_of_casesContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *One_of_casesContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *One_of_casesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *One_of_casesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *One_of_casesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterOne_of_cases(s)
	}
}

func (s *One_of_casesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitOne_of_cases(s)
	}
}

func (p *SyslParser) One_of_cases() (localctx IOne_of_casesContext) {
	localctx = NewOne_of_casesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, SyslParserRULE_one_of_cases)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(847)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-58)&-(0x1f+1)) == 0 && ((1<<uint((_la-58)))&((1<<(SyslParserQSTRING-58))|(1<<(SyslParserTEXT_LINE-58))|(1<<(SyslParserName-58)))) != 0 {
		{
			p.SetState(846)
			p.One_of_case_label()
		}

	}
	{
		p.SetState(849)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(850)
		p.Match(SyslParserINDENT)
	}
	p.SetState(852)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SyslParserAT-44))|(1<<(SyslParserPIPE-44))|(1<<(SyslParserQSTRING-44))|(1<<(SyslParserSYSL_COMMENT-44))|(1<<(SyslParserTEXT_LINE-44))|(1<<(SyslParserName-44)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(851)
			p.Statements()
		}

		p.SetState(854)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(856)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IOne_of_stmtContext is an interface to support dynamic dispatch.
type IOne_of_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOne_of_stmtContext differentiates from other interfaces.
	IsOne_of_stmtContext()
}

type One_of_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOne_of_stmtContext() *One_of_stmtContext {
	var p = new(One_of_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_one_of_stmt
	return p
}

func (*One_of_stmtContext) IsOne_of_stmtContext() {}

func NewOne_of_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *One_of_stmtContext {
	var p = new(One_of_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_one_of_stmt

	return p
}

func (s *One_of_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *One_of_stmtContext) ONE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserONE_OF, 0)
}

func (s *One_of_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *One_of_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *One_of_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *One_of_stmtContext) AllOne_of_cases() []IOne_of_casesContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOne_of_casesContext)(nil)).Elem())
	var tst = make([]IOne_of_casesContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOne_of_casesContext)
		}
	}

	return tst
}

func (s *One_of_stmtContext) One_of_cases(i int) IOne_of_casesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOne_of_casesContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOne_of_casesContext)
}

func (s *One_of_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *One_of_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *One_of_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterOne_of_stmt(s)
	}
}

func (s *One_of_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitOne_of_stmt(s)
	}
}

func (p *SyslParser) One_of_stmt() (localctx IOne_of_stmtContext) {
	localctx = NewOne_of_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, SyslParserRULE_one_of_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(858)
		p.Match(SyslParserONE_OF)
	}
	{
		p.SetState(859)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(860)
		p.Match(SyslParserINDENT)
	}
	p.SetState(862)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(SyslParserCOLON-41))|(1<<(SyslParserQSTRING-41))|(1<<(SyslParserTEXT_LINE-41))|(1<<(SyslParserName-41)))) != 0) {
		{
			p.SetState(861)
			p.One_of_cases()
		}

		p.SetState(864)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(866)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IText_stmtContext is an interface to support dynamic dispatch.
type IText_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_stmtContext differentiates from other interfaces.
	IsText_stmtContext()
}

type Text_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_stmtContext() *Text_stmtContext {
	var p = new(Text_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_text_stmt
	return p
}

func (*Text_stmtContext) IsText_stmtContext() {}

func NewText_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_stmtContext {
	var p = new(Text_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_text_stmt

	return p
}

func (s *Text_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_stmtContext) Doc_string() IDoc_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDoc_stringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDoc_stringContext)
}

func (s *Text_stmtContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Text_stmtContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *Text_stmtContext) ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_RIGHT, 0)
}

func (s *Text_stmtContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Text_stmtContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *Text_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterText_stmt(s)
	}
}

func (s *Text_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitText_stmt(s)
	}
}

func (p *SyslParser) Text_stmt() (localctx IText_stmtContext) {
	localctx = NewText_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, SyslParserRULE_text_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(876)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserPIPE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(868)
			p.Doc_string()
		}

	case SyslParserQSTRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(869)
			p.Match(SyslParserQSTRING)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(870)
			p.App_name()
		}
		p.SetState(873)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserARROW_RIGHT {
			{
				p.SetState(871)
				p.Match(SyslParserARROW_RIGHT)
			}
			{
				p.SetState(872)
				p.Name_str()
			}

		}

	case SyslParserWHATEVER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(875)
			p.Match(SyslParserWHATEVER)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMixinContext is an interface to support dynamic dispatch.
type IMixinContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMixinContext differentiates from other interfaces.
	IsMixinContext()
}

type MixinContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMixinContext() *MixinContext {
	var p = new(MixinContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_mixin
	return p
}

func (*MixinContext) IsMixinContext() {}

func NewMixinContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MixinContext {
	var p = new(MixinContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_mixin

	return p
}

func (s *MixinContext) GetParser() antlr.Parser { return s.parser }

func (s *MixinContext) MIXIN() antlr.TerminalNode {
	return s.GetToken(SyslParserMIXIN, 0)
}

func (s *MixinContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *MixinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MixinContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MixinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterMixin(s)
	}
}

func (s *MixinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitMixin(s)
	}
}

func (p *SyslParser) Mixin() (localctx IMixinContext) {
	localctx = NewMixinContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, SyslParserRULE_mixin)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(878)
		p.Match(SyslParserMIXIN)
	}
	{
		p.SetState(879)
		p.App_name()
	}

	return localctx
}

// IParamContext is an interface to support dynamic dispatch.
type IParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamContext differentiates from other interfaces.
	IsParamContext()
}

type ParamContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamContext() *ParamContext {
	var p = new(ParamContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_param
	return p
}

func (*ParamContext) IsParamContext() {}

func NewParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamContext {
	var p = new(ParamContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_param

	return p
}

func (s *ParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamContext) Reference() IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *ParamContext) Field() IFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldContext)
}

func (s *ParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterParam(s)
	}
}

func (s *ParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitParam(s)
	}
}

func (p *SyslParser) Param() (localctx IParamContext) {
	localctx = NewParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, SyslParserRULE_param)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(883)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(881)
			p.Reference()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(882)
			p.Field()
		}

	}

	return localctx
}

// IParam_listContext is an interface to support dynamic dispatch.
type IParam_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParam_listContext differentiates from other interfaces.
	IsParam_listContext()
}

type Param_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParam_listContext() *Param_listContext {
	var p = new(Param_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_param_list
	return p
}

func (*Param_listContext) IsParam_listContext() {}

func NewParam_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Param_listContext {
	var p = new(Param_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_param_list

	return p
}

func (s *Param_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Param_listContext) AllParam() []IParamContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParamContext)(nil)).Elem())
	var tst = make([]IParamContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParamContext)
		}
	}

	return tst
}

func (s *Param_listContext) Param(i int) IParamContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *Param_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Param_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Param_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Param_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Param_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterParam_list(s)
	}
}

func (s *Param_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitParam_list(s)
	}
}

func (p *SyslParser) Param_list() (localctx IParam_listContext) {
	localctx = NewParam_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, SyslParserRULE_param_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(885)
		p.Param()
	}
	p.SetState(890)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(886)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(887)
			p.Param()
		}

		p.SetState(892)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IParamsContext is an interface to support dynamic dispatch.
type IParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamsContext differentiates from other interfaces.
	IsParamsContext()
}

type ParamsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamsContext() *ParamsContext {
	var p = new(ParamsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_params
	return p
}

func (*ParamsContext) IsParamsContext() {}

func NewParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamsContext {
	var p = new(ParamsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_params

	return p
}

func (s *ParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamsContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *ParamsContext) Param_list() IParam_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParam_listContext)
}

func (s *ParamsContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *ParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterParams(s)
	}
}

func (s *ParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitParams(s)
	}
}

func (p *SyslParser) Params() (localctx IParamsContext) {
	localctx = NewParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, SyslParserRULE_params)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(893)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(894)
		p.Param_list()
	}
	{
		p.SetState(895)
		p.Match(SyslParserCLOSE_PAREN)
	}

	return localctx
}

// IStatementsContext is an interface to support dynamic dispatch.
type IStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementsContext differentiates from other interfaces.
	IsStatementsContext()
}

type StatementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsContext() *StatementsContext {
	var p = new(StatementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_statements
	return p
}

func (*StatementsContext) IsStatementsContext() {}

func NewStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsContext {
	var p = new(StatementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_statements

	return p
}

func (s *StatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsContext) If_else() IIf_elseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_elseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_elseContext)
}

func (s *StatementsContext) For_stmt() IFor_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_stmtContext)
}

func (s *StatementsContext) Ret_stmt() IRet_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRet_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRet_stmtContext)
}

func (s *StatementsContext) Call_stmt() ICall_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICall_stmtContext)
}

func (s *StatementsContext) One_of_stmt() IOne_of_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOne_of_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOne_of_stmtContext)
}

func (s *StatementsContext) Http_method_comment() IHttp_method_commentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_method_commentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_method_commentContext)
}

func (s *StatementsContext) Group_stmt() IGroup_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_stmtContext)
}

func (s *StatementsContext) Text_stmt() IText_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_stmtContext)
}

func (s *StatementsContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *StatementsContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *StatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterStatements(s)
	}
}

func (s *StatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitStatements(s)
	}
}

func (p *SyslParser) Statements() (localctx IStatementsContext) {
	localctx = NewStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, SyslParserRULE_statements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(906)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(897)
			p.If_else()
		}

	case 2:
		{
			p.SetState(898)
			p.For_stmt()
		}

	case 3:
		{
			p.SetState(899)
			p.Ret_stmt()
		}

	case 4:
		{
			p.SetState(900)
			p.Call_stmt()
		}

	case 5:
		{
			p.SetState(901)
			p.One_of_stmt()
		}

	case 6:
		{
			p.SetState(902)
			p.Http_method_comment()
		}

	case 7:
		{
			p.SetState(903)
			p.Group_stmt()
		}

	case 8:
		{
			p.SetState(904)
			p.Text_stmt()
		}

	case 9:
		{
			p.SetState(905)
			p.Annotation()
		}

	}
	p.SetState(909)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(908)
			p.Attribs_or_modifiers()
		}

	}

	return localctx
}

// IMethod_defContext is an interface to support dynamic dispatch.
type IMethod_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethod_defContext differentiates from other interfaces.
	IsMethod_defContext()
}

type Method_defContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethod_defContext() *Method_defContext {
	var p = new(Method_defContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_method_def
	return p
}

func (*Method_defContext) IsMethod_defContext() {}

func NewMethod_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Method_defContext {
	var p = new(Method_defContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_method_def

	return p
}

func (s *Method_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Method_defContext) HTTP_VERBS() antlr.TerminalNode {
	return s.GetToken(SyslParserHTTP_VERBS, 0)
}

func (s *Method_defContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Method_defContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Method_defContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Method_defContext) Params() IParamsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamsContext)
}

func (s *Method_defContext) Query_param() IQuery_paramContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuery_paramContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuery_paramContext)
}

func (s *Method_defContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Method_defContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *Method_defContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *Method_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Method_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Method_defContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterMethod_def(s)
	}
}

func (s *Method_defContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitMethod_def(s)
	}
}

func (p *SyslParser) Method_def() (localctx IMethod_defContext) {
	localctx = NewMethod_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, SyslParserRULE_method_def)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(911)
		p.Match(SyslParserHTTP_VERBS)
	}
	p.SetState(913)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserOPEN_PAREN {
		{
			p.SetState(912)
			p.Params()
		}

	}
	p.SetState(916)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQN {
		{
			p.SetState(915)
			p.Query_param()
		}

	}
	p.SetState(919)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(918)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(921)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(922)
		p.Match(SyslParserINDENT)
	}
	p.SetState(924)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SyslParserAT-44))|(1<<(SyslParserPIPE-44))|(1<<(SyslParserQSTRING-44))|(1<<(SyslParserSYSL_COMMENT-44))|(1<<(SyslParserTEXT_LINE-44))|(1<<(SyslParserName-44)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(923)
			p.Statements()
		}

		p.SetState(926)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(928)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IShortcutContext is an interface to support dynamic dispatch.
type IShortcutContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShortcutContext differentiates from other interfaces.
	IsShortcutContext()
}

type ShortcutContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShortcutContext() *ShortcutContext {
	var p = new(ShortcutContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_shortcut
	return p
}

func (*ShortcutContext) IsShortcutContext() {}

func NewShortcutContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShortcutContext {
	var p = new(ShortcutContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_shortcut

	return p
}

func (s *ShortcutContext) GetParser() antlr.Parser { return s.parser }

func (s *ShortcutContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *ShortcutContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShortcutContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShortcutContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterShortcut(s)
	}
}

func (s *ShortcutContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitShortcut(s)
	}
}

func (p *SyslParser) Shortcut() (localctx IShortcutContext) {
	localctx = NewShortcutContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, SyslParserRULE_shortcut)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(930)
		p.Match(SyslParserWHATEVER)
	}

	return localctx
}

// ISimple_endpointContext is an interface to support dynamic dispatch.
type ISimple_endpointContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_endpointContext differentiates from other interfaces.
	IsSimple_endpointContext()
}

type Simple_endpointContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_endpointContext() *Simple_endpointContext {
	var p = new(Simple_endpointContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_simple_endpoint
	return p
}

func (*Simple_endpointContext) IsSimple_endpointContext() {}

func NewSimple_endpointContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_endpointContext {
	var p = new(Simple_endpointContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_simple_endpoint

	return p
}

func (s *Simple_endpointContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_endpointContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *Simple_endpointContext) Endpoint_name() IEndpoint_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndpoint_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndpoint_nameContext)
}

func (s *Simple_endpointContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Simple_endpointContext) Shortcut() IShortcutContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShortcutContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShortcutContext)
}

func (s *Simple_endpointContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Simple_endpointContext) Params() IParamsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamsContext)
}

func (s *Simple_endpointContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Simple_endpointContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Simple_endpointContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Simple_endpointContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *Simple_endpointContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *Simple_endpointContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_endpointContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_endpointContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSimple_endpoint(s)
	}
}

func (s *Simple_endpointContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSimple_endpoint(s)
	}
}

func (p *SyslParser) Simple_endpoint() (localctx ISimple_endpointContext) {
	localctx = NewSimple_endpointContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, SyslParserRULE_simple_endpoint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(955)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(932)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(933)
			p.Endpoint_name()
		}
		p.SetState(935)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserQSTRING {
			{
				p.SetState(934)
				p.Match(SyslParserQSTRING)
			}

		}
		p.SetState(938)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserOPEN_PAREN {
			{
				p.SetState(937)
				p.Params()
			}

		}
		p.SetState(941)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserSQ_OPEN {
			{
				p.SetState(940)
				p.Attribs_or_modifiers()
			}

		}
		{
			p.SetState(943)
			p.Match(SyslParserCOLON)
		}
		p.SetState(953)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserWHATEVER:
			{
				p.SetState(944)
				p.Shortcut()
			}

		case SyslParserINDENT:
			{
				p.SetState(945)
				p.Match(SyslParserINDENT)
			}
			p.SetState(947)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SyslParserAT-44))|(1<<(SyslParserPIPE-44))|(1<<(SyslParserQSTRING-44))|(1<<(SyslParserSYSL_COMMENT-44))|(1<<(SyslParserTEXT_LINE-44))|(1<<(SyslParserName-44)))) != 0) || _la == SyslParserE_Name {
				{
					p.SetState(946)
					p.Statements()
				}

				p.SetState(949)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(951)
				p.Match(SyslParserDEDENT)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRest_endpointContext is an interface to support dynamic dispatch.
type IRest_endpointContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRest_endpointContext differentiates from other interfaces.
	IsRest_endpointContext()
}

type Rest_endpointContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRest_endpointContext() *Rest_endpointContext {
	var p = new(Rest_endpointContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_rest_endpoint
	return p
}

func (*Rest_endpointContext) IsRest_endpointContext() {}

func NewRest_endpointContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rest_endpointContext {
	var p = new(Rest_endpointContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_rest_endpoint

	return p
}

func (s *Rest_endpointContext) GetParser() antlr.Parser { return s.parser }

func (s *Rest_endpointContext) Http_path() IHttp_pathContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_pathContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_pathContext)
}

func (s *Rest_endpointContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Rest_endpointContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Rest_endpointContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Rest_endpointContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Rest_endpointContext) AllMethod_def() []IMethod_defContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMethod_defContext)(nil)).Elem())
	var tst = make([]IMethod_defContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMethod_defContext)
		}
	}

	return tst
}

func (s *Rest_endpointContext) Method_def(i int) IMethod_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_defContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMethod_defContext)
}

func (s *Rest_endpointContext) AllRest_endpoint() []IRest_endpointContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRest_endpointContext)(nil)).Elem())
	var tst = make([]IRest_endpointContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRest_endpointContext)
		}
	}

	return tst
}

func (s *Rest_endpointContext) Rest_endpoint(i int) IRest_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRest_endpointContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRest_endpointContext)
}

func (s *Rest_endpointContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rest_endpointContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rest_endpointContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRest_endpoint(s)
	}
}

func (s *Rest_endpointContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRest_endpoint(s)
	}
}

func (p *SyslParser) Rest_endpoint() (localctx IRest_endpointContext) {
	localctx = NewRest_endpointContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, SyslParserRULE_rest_endpoint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(957)
		p.Http_path()
	}
	p.SetState(959)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(958)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(961)
		p.Match(SyslParserCOLON)
	}

	{
		p.SetState(962)
		p.Match(SyslParserINDENT)
	}
	p.SetState(965)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserHTTP_VERBS || _la == SyslParserFORWARD_SLASH {
		p.SetState(965)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserHTTP_VERBS:
			{
				p.SetState(963)
				p.Method_def()
			}

		case SyslParserFORWARD_SLASH:
			{
				p.SetState(964)
				p.Rest_endpoint()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(967)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(969)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// ICollector_query_varContext is an interface to support dynamic dispatch.
type ICollector_query_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_query_varContext differentiates from other interfaces.
	IsCollector_query_varContext()
}

type Collector_query_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_query_varContext() *Collector_query_varContext {
	var p = new(Collector_query_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_query_var
	return p
}

func (*Collector_query_varContext) IsCollector_query_varContext() {}

func NewCollector_query_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_query_varContext {
	var p = new(Collector_query_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_query_var

	return p
}

func (s *Collector_query_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_query_varContext) AllName_str() []IName_strContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IName_strContext)(nil)).Elem())
	var tst = make([]IName_strContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IName_strContext)
		}
	}

	return tst
}

func (s *Collector_query_varContext) Name_str(i int) IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Collector_query_varContext) EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserEQ, 0)
}

func (s *Collector_query_varContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Collector_query_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_query_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_query_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_query_var(s)
	}
}

func (s *Collector_query_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_query_var(s)
	}
}

func (p *SyslParser) Collector_query_var() (localctx ICollector_query_varContext) {
	localctx = NewCollector_query_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, SyslParserRULE_collector_query_var)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(971)
		p.Name_str()
	}
	{
		p.SetState(972)
		p.Match(SyslParserEQ)
	}
	p.SetState(975)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserNativeDataTypes:
		{
			p.SetState(973)
			p.Match(SyslParserNativeDataTypes)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(974)
			p.Name_str()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICollector_query_paramContext is an interface to support dynamic dispatch.
type ICollector_query_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_query_paramContext differentiates from other interfaces.
	IsCollector_query_paramContext()
}

type Collector_query_paramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_query_paramContext() *Collector_query_paramContext {
	var p = new(Collector_query_paramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_query_param
	return p
}

func (*Collector_query_paramContext) IsCollector_query_paramContext() {}

func NewCollector_query_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_query_paramContext {
	var p = new(Collector_query_paramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_query_param

	return p
}

func (s *Collector_query_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_query_paramContext) QN() antlr.TerminalNode {
	return s.GetToken(SyslParserQN, 0)
}

func (s *Collector_query_paramContext) AllCollector_query_var() []ICollector_query_varContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICollector_query_varContext)(nil)).Elem())
	var tst = make([]ICollector_query_varContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICollector_query_varContext)
		}
	}

	return tst
}

func (s *Collector_query_paramContext) Collector_query_var(i int) ICollector_query_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_query_varContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICollector_query_varContext)
}

func (s *Collector_query_paramContext) AllAMP() []antlr.TerminalNode {
	return s.GetTokens(SyslParserAMP)
}

func (s *Collector_query_paramContext) AMP(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserAMP, i)
}

func (s *Collector_query_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_query_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_query_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_query_param(s)
	}
}

func (s *Collector_query_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_query_param(s)
	}
}

func (p *SyslParser) Collector_query_param() (localctx ICollector_query_paramContext) {
	localctx = NewCollector_query_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, SyslParserRULE_collector_query_param)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(977)
		p.Match(SyslParserQN)
	}
	{
		p.SetState(978)
		p.Collector_query_var()
	}
	p.SetState(983)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserAMP {
		{
			p.SetState(979)
			p.Match(SyslParserAMP)
		}
		{
			p.SetState(980)
			p.Collector_query_var()
		}

		p.SetState(985)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICollector_call_stmtContext is an interface to support dynamic dispatch.
type ICollector_call_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_call_stmtContext differentiates from other interfaces.
	IsCollector_call_stmtContext()
}

type Collector_call_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_call_stmtContext() *Collector_call_stmtContext {
	var p = new(Collector_call_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_call_stmt
	return p
}

func (*Collector_call_stmtContext) IsCollector_call_stmtContext() {}

func NewCollector_call_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_call_stmtContext {
	var p = new(Collector_call_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_call_stmt

	return p
}

func (s *Collector_call_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_call_stmtContext) Target() ITargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITargetContext)
}

func (s *Collector_call_stmtContext) ARROW_LEFT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_LEFT, 0)
}

func (s *Collector_call_stmtContext) Target_endpoint() ITarget_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITarget_endpointContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITarget_endpointContext)
}

func (s *Collector_call_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_call_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_call_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_call_stmt(s)
	}
}

func (s *Collector_call_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_call_stmt(s)
	}
}

func (p *SyslParser) Collector_call_stmt() (localctx ICollector_call_stmtContext) {
	localctx = NewCollector_call_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, SyslParserRULE_collector_call_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(986)
		p.Target()
	}
	{
		p.SetState(987)
		p.Match(SyslParserARROW_LEFT)
	}
	{
		p.SetState(988)
		p.Target_endpoint()
	}

	return localctx
}

// ICollector_http_stmt_partContext is an interface to support dynamic dispatch.
type ICollector_http_stmt_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_http_stmt_partContext differentiates from other interfaces.
	IsCollector_http_stmt_partContext()
}

type Collector_http_stmt_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_http_stmt_partContext() *Collector_http_stmt_partContext {
	var p = new(Collector_http_stmt_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_http_stmt_part
	return p
}

func (*Collector_http_stmt_partContext) IsCollector_http_stmt_partContext() {}

func NewCollector_http_stmt_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_http_stmt_partContext {
	var p = new(Collector_http_stmt_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_http_stmt_part

	return p
}

func (s *Collector_http_stmt_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_http_stmt_partContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Collector_http_stmt_partContext) CURLY_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_OPEN, 0)
}

func (s *Collector_http_stmt_partContext) CURLY_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_CLOSE, 0)
}

func (s *Collector_http_stmt_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_http_stmt_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_http_stmt_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_http_stmt_part(s)
	}
}

func (s *Collector_http_stmt_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_http_stmt_part(s)
	}
}

func (p *SyslParser) Collector_http_stmt_part() (localctx ICollector_http_stmt_partContext) {
	localctx = NewCollector_http_stmt_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, SyslParserRULE_collector_http_stmt_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(995)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(990)
			p.Name_str()
		}

	case SyslParserCURLY_OPEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(991)
			p.Match(SyslParserCURLY_OPEN)
		}
		{
			p.SetState(992)
			p.Name_str()
		}
		{
			p.SetState(993)
			p.Match(SyslParserCURLY_CLOSE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICollector_http_stmt_suffixContext is an interface to support dynamic dispatch.
type ICollector_http_stmt_suffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_http_stmt_suffixContext differentiates from other interfaces.
	IsCollector_http_stmt_suffixContext()
}

type Collector_http_stmt_suffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_http_stmt_suffixContext() *Collector_http_stmt_suffixContext {
	var p = new(Collector_http_stmt_suffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_http_stmt_suffix
	return p
}

func (*Collector_http_stmt_suffixContext) IsCollector_http_stmt_suffixContext() {}

func NewCollector_http_stmt_suffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_http_stmt_suffixContext {
	var p = new(Collector_http_stmt_suffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_http_stmt_suffix

	return p
}

func (s *Collector_http_stmt_suffixContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_http_stmt_suffixContext) AllFORWARD_SLASH() []antlr.TerminalNode {
	return s.GetTokens(SyslParserFORWARD_SLASH)
}

func (s *Collector_http_stmt_suffixContext) FORWARD_SLASH(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserFORWARD_SLASH, i)
}

func (s *Collector_http_stmt_suffixContext) AllCollector_http_stmt_part() []ICollector_http_stmt_partContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICollector_http_stmt_partContext)(nil)).Elem())
	var tst = make([]ICollector_http_stmt_partContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICollector_http_stmt_partContext)
		}
	}

	return tst
}

func (s *Collector_http_stmt_suffixContext) Collector_http_stmt_part(i int) ICollector_http_stmt_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_http_stmt_partContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICollector_http_stmt_partContext)
}

func (s *Collector_http_stmt_suffixContext) Collector_query_param() ICollector_query_paramContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_query_paramContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_query_paramContext)
}

func (s *Collector_http_stmt_suffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_http_stmt_suffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_http_stmt_suffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_http_stmt_suffix(s)
	}
}

func (s *Collector_http_stmt_suffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_http_stmt_suffix(s)
	}
}

func (p *SyslParser) Collector_http_stmt_suffix() (localctx ICollector_http_stmt_suffixContext) {
	localctx = NewCollector_http_stmt_suffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, SyslParserRULE_collector_http_stmt_suffix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(999)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserFORWARD_SLASH {
		{
			p.SetState(997)
			p.Match(SyslParserFORWARD_SLASH)
		}
		{
			p.SetState(998)
			p.Collector_http_stmt_part()
		}

		p.SetState(1001)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1004)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQN {
		{
			p.SetState(1003)
			p.Collector_query_param()
		}

	}

	return localctx
}

// ICollector_http_stmtContext is an interface to support dynamic dispatch.
type ICollector_http_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_http_stmtContext differentiates from other interfaces.
	IsCollector_http_stmtContext()
}

type Collector_http_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_http_stmtContext() *Collector_http_stmtContext {
	var p = new(Collector_http_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_http_stmt
	return p
}

func (*Collector_http_stmtContext) IsCollector_http_stmtContext() {}

func NewCollector_http_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_http_stmtContext {
	var p = new(Collector_http_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_http_stmt

	return p
}

func (s *Collector_http_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_http_stmtContext) HTTP_VERBS() antlr.TerminalNode {
	return s.GetToken(SyslParserHTTP_VERBS, 0)
}

func (s *Collector_http_stmtContext) Collector_http_stmt_suffix() ICollector_http_stmt_suffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_http_stmt_suffixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_http_stmt_suffixContext)
}

func (s *Collector_http_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_http_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_http_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_http_stmt(s)
	}
}

func (s *Collector_http_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_http_stmt(s)
	}
}

func (p *SyslParser) Collector_http_stmt() (localctx ICollector_http_stmtContext) {
	localctx = NewCollector_http_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, SyslParserRULE_collector_http_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1006)
		p.Match(SyslParserHTTP_VERBS)
	}
	{
		p.SetState(1007)
		p.Collector_http_stmt_suffix()
	}

	return localctx
}

// IPublisherContext is an interface to support dynamic dispatch.
type IPublisherContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPublisherContext differentiates from other interfaces.
	IsPublisherContext()
}

type PublisherContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPublisherContext() *PublisherContext {
	var p = new(PublisherContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_publisher
	return p
}

func (*PublisherContext) IsPublisherContext() {}

func NewPublisherContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PublisherContext {
	var p = new(PublisherContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_publisher

	return p
}

func (s *PublisherContext) GetParser() antlr.Parser { return s.parser }

func (s *PublisherContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *PublisherContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PublisherContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PublisherContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterPublisher(s)
	}
}

func (s *PublisherContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitPublisher(s)
	}
}

func (p *SyslParser) Publisher() (localctx IPublisherContext) {
	localctx = NewPublisherContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, SyslParserRULE_publisher)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1009)
		p.App_name()
	}

	return localctx
}

// ISubscriberContext is an interface to support dynamic dispatch.
type ISubscriberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscriberContext differentiates from other interfaces.
	IsSubscriberContext()
}

type SubscriberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscriberContext() *SubscriberContext {
	var p = new(SubscriberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_subscriber
	return p
}

func (*SubscriberContext) IsSubscriberContext() {}

func NewSubscriberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscriberContext {
	var p = new(SubscriberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_subscriber

	return p
}

func (s *SubscriberContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscriberContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *SubscriberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubscriberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSubscriber(s)
	}
}

func (s *SubscriberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSubscriber(s)
	}
}

func (p *SyslParser) Subscriber() (localctx ISubscriberContext) {
	localctx = NewSubscriberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, SyslParserRULE_subscriber)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1011)
		p.App_name()
	}

	return localctx
}

// ICollector_pubsub_callContext is an interface to support dynamic dispatch.
type ICollector_pubsub_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_pubsub_callContext differentiates from other interfaces.
	IsCollector_pubsub_callContext()
}

type Collector_pubsub_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_pubsub_callContext() *Collector_pubsub_callContext {
	var p = new(Collector_pubsub_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_pubsub_call
	return p
}

func (*Collector_pubsub_callContext) IsCollector_pubsub_callContext() {}

func NewCollector_pubsub_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_pubsub_callContext {
	var p = new(Collector_pubsub_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_pubsub_call

	return p
}

func (s *Collector_pubsub_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_pubsub_callContext) Subscriber() ISubscriberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubscriberContext)
}

func (s *Collector_pubsub_callContext) ARROW_LEFT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_LEFT, 0)
}

func (s *Collector_pubsub_callContext) Publisher() IPublisherContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPublisherContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPublisherContext)
}

func (s *Collector_pubsub_callContext) ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_RIGHT, 0)
}

func (s *Collector_pubsub_callContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Collector_pubsub_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_pubsub_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_pubsub_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_pubsub_call(s)
	}
}

func (s *Collector_pubsub_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_pubsub_call(s)
	}
}

func (p *SyslParser) Collector_pubsub_call() (localctx ICollector_pubsub_callContext) {
	localctx = NewCollector_pubsub_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, SyslParserRULE_collector_pubsub_call)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1013)
		p.Subscriber()
	}
	{
		p.SetState(1014)
		p.Match(SyslParserARROW_LEFT)
	}
	{
		p.SetState(1015)
		p.Publisher()
	}
	{
		p.SetState(1016)
		p.Match(SyslParserARROW_RIGHT)
	}
	{
		p.SetState(1017)
		p.Name_str()
	}

	return localctx
}

// ICollector_action_stmtContext is an interface to support dynamic dispatch.
type ICollector_action_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_action_stmtContext differentiates from other interfaces.
	IsCollector_action_stmtContext()
}

type Collector_action_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_action_stmtContext() *Collector_action_stmtContext {
	var p = new(Collector_action_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_action_stmt
	return p
}

func (*Collector_action_stmtContext) IsCollector_action_stmtContext() {}

func NewCollector_action_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_action_stmtContext {
	var p = new(Collector_action_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_action_stmt

	return p
}

func (s *Collector_action_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_action_stmtContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Collector_action_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_action_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_action_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_action_stmt(s)
	}
}

func (s *Collector_action_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_action_stmt(s)
	}
}

func (p *SyslParser) Collector_action_stmt() (localctx ICollector_action_stmtContext) {
	localctx = NewCollector_action_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, SyslParserRULE_collector_action_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1019)
		p.Name_str()
	}

	return localctx
}

// ICollector_stmtsContext is an interface to support dynamic dispatch.
type ICollector_stmtsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_stmtsContext differentiates from other interfaces.
	IsCollector_stmtsContext()
}

type Collector_stmtsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_stmtsContext() *Collector_stmtsContext {
	var p = new(Collector_stmtsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_stmts
	return p
}

func (*Collector_stmtsContext) IsCollector_stmtsContext() {}

func NewCollector_stmtsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_stmtsContext {
	var p = new(Collector_stmtsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_stmts

	return p
}

func (s *Collector_stmtsContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_stmtsContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Collector_stmtsContext) Collector_action_stmt() ICollector_action_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_action_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_action_stmtContext)
}

func (s *Collector_stmtsContext) Collector_call_stmt() ICollector_call_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_call_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_call_stmtContext)
}

func (s *Collector_stmtsContext) Collector_http_stmt() ICollector_http_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_http_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_http_stmtContext)
}

func (s *Collector_stmtsContext) Collector_pubsub_call() ICollector_pubsub_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_pubsub_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_pubsub_callContext)
}

func (s *Collector_stmtsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_stmtsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_stmtsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_stmts(s)
	}
}

func (s *Collector_stmtsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_stmts(s)
	}
}

func (p *SyslParser) Collector_stmts() (localctx ICollector_stmtsContext) {
	localctx = NewCollector_stmtsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, SyslParserRULE_collector_stmts)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1025)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1021)
			p.Collector_action_stmt()
		}

	case 2:
		{
			p.SetState(1022)
			p.Collector_call_stmt()
		}

	case 3:
		{
			p.SetState(1023)
			p.Collector_http_stmt()
		}

	case 4:
		{
			p.SetState(1024)
			p.Collector_pubsub_call()
		}

	}
	{
		p.SetState(1027)
		p.Attribs_or_modifiers()
	}

	return localctx
}

// ICollectorContext is an interface to support dynamic dispatch.
type ICollectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollectorContext differentiates from other interfaces.
	IsCollectorContext()
}

type CollectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollectorContext() *CollectorContext {
	var p = new(CollectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector
	return p
}

func (*CollectorContext) IsCollectorContext() {}

func NewCollectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollectorContext {
	var p = new(CollectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector

	return p
}

func (s *CollectorContext) GetParser() antlr.Parser { return s.parser }

func (s *CollectorContext) COLLECTOR() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLLECTOR, 0)
}

func (s *CollectorContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *CollectorContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *CollectorContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *CollectorContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *CollectorContext) AllCollector_stmts() []ICollector_stmtsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICollector_stmtsContext)(nil)).Elem())
	var tst = make([]ICollector_stmtsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICollector_stmtsContext)
		}
	}

	return tst
}

func (s *CollectorContext) Collector_stmts(i int) ICollector_stmtsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_stmtsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICollector_stmtsContext)
}

func (s *CollectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector(s)
	}
}

func (s *CollectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector(s)
	}
}

func (p *SyslParser) Collector() (localctx ICollectorContext) {
	localctx = NewCollectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, SyslParserRULE_collector)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1029)
		p.Match(SyslParserCOLLECTOR)
	}
	{
		p.SetState(1030)
		p.Match(SyslParserCOLON)
	}
	p.SetState(1040)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(1031)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(1032)
			p.Match(SyslParserINDENT)
		}
		p.SetState(1034)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SyslParserHTTP_VERBS || _la == SyslParserTEXT_LINE || _la == SyslParserName || _la == SyslParserE_Name {
			{
				p.SetState(1033)
				p.Collector_stmts()
			}

			p.SetState(1036)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1038)
			p.Match(SyslParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEventContext is an interface to support dynamic dispatch.
type IEventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEventContext differentiates from other interfaces.
	IsEventContext()
}

type EventContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEventContext() *EventContext {
	var p = new(EventContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_event
	return p
}

func (*EventContext) IsEventContext() {}

func NewEventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventContext {
	var p = new(EventContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_event

	return p
}

func (s *EventContext) GetParser() antlr.Parser { return s.parser }

func (s *EventContext) DISTANCE() antlr.TerminalNode {
	return s.GetToken(SyslParserDISTANCE, 0)
}

func (s *EventContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *EventContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *EventContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *EventContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *EventContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *EventContext) Params() IParamsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamsContext)
}

func (s *EventContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *EventContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *EventContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *EventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterEvent(s)
	}
}

func (s *EventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitEvent(s)
	}
}

func (p *SyslParser) Event() (localctx IEventContext) {
	localctx = NewEventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, SyslParserRULE_event)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1042)
		p.Match(SyslParserDISTANCE)
	}
	{
		p.SetState(1043)
		p.Name_str()
	}
	p.SetState(1045)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserOPEN_PAREN {
		{
			p.SetState(1044)
			p.Params()
		}

	}
	p.SetState(1048)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(1047)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(1050)
		p.Match(SyslParserCOLON)
	}
	p.SetState(1060)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(1051)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(1052)
			p.Match(SyslParserINDENT)
		}
		p.SetState(1054)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SyslParserAT-44))|(1<<(SyslParserPIPE-44))|(1<<(SyslParserQSTRING-44))|(1<<(SyslParserSYSL_COMMENT-44))|(1<<(SyslParserTEXT_LINE-44))|(1<<(SyslParserName-44)))) != 0) || _la == SyslParserE_Name {
			{
				p.SetState(1053)
				p.Statements()
			}

			p.SetState(1056)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1058)
			p.Match(SyslParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISubscribeContext is an interface to support dynamic dispatch.
type ISubscribeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscribeContext differentiates from other interfaces.
	IsSubscribeContext()
}

type SubscribeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscribeContext() *SubscribeContext {
	var p = new(SubscribeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_subscribe
	return p
}

func (*SubscribeContext) IsSubscribeContext() {}

func NewSubscribeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscribeContext {
	var p = new(SubscribeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_subscribe

	return p
}

func (s *SubscribeContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscribeContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *SubscribeContext) ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_RIGHT, 0)
}

func (s *SubscribeContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *SubscribeContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *SubscribeContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *SubscribeContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *SubscribeContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *SubscribeContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *SubscribeContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *SubscribeContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *SubscribeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscribeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubscribeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSubscribe(s)
	}
}

func (s *SubscribeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSubscribe(s)
	}
}

func (p *SyslParser) Subscribe() (localctx ISubscribeContext) {
	localctx = NewSubscribeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, SyslParserRULE_subscribe)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1062)
		p.App_name()
	}
	{
		p.SetState(1063)
		p.Match(SyslParserARROW_RIGHT)
	}
	{
		p.SetState(1064)
		p.Name_str()
	}
	p.SetState(1066)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(1065)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(1068)
		p.Match(SyslParserCOLON)
	}
	p.SetState(1078)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(1069)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(1070)
			p.Match(SyslParserINDENT)
		}
		p.SetState(1072)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SyslParserAT-44))|(1<<(SyslParserPIPE-44))|(1<<(SyslParserQSTRING-44))|(1<<(SyslParserSYSL_COMMENT-44))|(1<<(SyslParserTEXT_LINE-44))|(1<<(SyslParserName-44)))) != 0) || _la == SyslParserE_Name {
			{
				p.SetState(1071)
				p.Statements()
			}

			p.SetState(1074)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1076)
			p.Match(SyslParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IView_type_specContext is an interface to support dynamic dispatch.
type IView_type_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsView_type_specContext differentiates from other interfaces.
	IsView_type_specContext()
}

type View_type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyView_type_specContext() *View_type_specContext {
	var p = new(View_type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view_type_spec
	return p
}

func (*View_type_specContext) IsView_type_specContext() {}

func NewView_type_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *View_type_specContext {
	var p = new(View_type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view_type_spec

	return p
}

func (s *View_type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *View_type_specContext) Collection_type() ICollection_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollection_typeContext)
}

func (s *View_type_specContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *View_type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *View_type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *View_type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView_type_spec(s)
	}
}

func (s *View_type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView_type_spec(s)
	}
}

func (p *SyslParser) View_type_spec() (localctx IView_type_specContext) {
	localctx = NewView_type_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, SyslParserRULE_view_type_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1082)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserSEQUENCE_OF, SyslParserSET_OF, SyslParserE_SEQUENCE_OF, SyslParserE_SET_OF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1080)
			p.Collection_type()
		}

	case SyslParserNativeDataTypes, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1081)
			p.Types()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) E_DIGITS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DIGITS, 0)
}

func (s *LiteralContext) E_DECIMAL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DECIMAL, 0)
}

func (s *LiteralContext) E_STRING_DBL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_STRING_DBL, 0)
}

func (s *LiteralContext) E_STRING_SINGLE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_STRING_SINGLE, 0)
}

func (s *LiteralContext) E_NULL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NULL, 0)
}

func (s *LiteralContext) E_TRUE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TRUE, 0)
}

func (s *LiteralContext) E_FALSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_FALSE, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *SyslParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, SyslParserRULE_literal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1084)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-116)&-(0x1f+1)) == 0 && ((1<<uint((_la-116)))&((1<<(SyslParserE_TRUE-116))|(1<<(SyslParserE_FALSE-116))|(1<<(SyslParserE_NULL-116))|(1<<(SyslParserE_STRING_DBL-116))|(1<<(SyslParserE_STRING_SINGLE-116))|(1<<(SyslParserE_DECIMAL-116))|(1<<(SyslParserE_DIGITS-116)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IExpr_table_of_opContext is an interface to support dynamic dispatch.
type IExpr_table_of_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_table_of_opContext differentiates from other interfaces.
	IsExpr_table_of_opContext()
}

type Expr_table_of_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_table_of_opContext() *Expr_table_of_opContext {
	var p = new(Expr_table_of_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_table_of_op
	return p
}

func (*Expr_table_of_opContext) IsExpr_table_of_opContext() {}

func NewExpr_table_of_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_table_of_opContext {
	var p = new(Expr_table_of_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_table_of_op

	return p
}

func (s *Expr_table_of_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_table_of_opContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_table_of_opContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *Expr_table_of_opContext) E_NULLSAFE_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NULLSAFE_DOT, 0)
}

func (s *Expr_table_of_opContext) E_TABLE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TABLE_OF, 0)
}

func (s *Expr_table_of_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_table_of_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_table_of_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_table_of_op(s)
	}
}

func (s *Expr_table_of_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_table_of_op(s)
	}
}

func (p *SyslParser) Expr_table_of_op() (localctx IExpr_table_of_opContext) {
	localctx = NewExpr_table_of_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, SyslParserRULE_expr_table_of_op)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1086)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserE_NULLSAFE_DOT || _la == SyslParserE_DOT) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(1088)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_TABLE_OF {
		{
			p.SetState(1087)
			p.Match(SyslParserE_TABLE_OF)
		}

	}
	{
		p.SetState(1090)
		p.Match(SyslParserE_Name)
	}

	return localctx
}

// IFunc_argContext is an interface to support dynamic dispatch.
type IFunc_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunc_argContext differentiates from other interfaces.
	IsFunc_argContext()
}

type Func_argContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_argContext() *Func_argContext {
	var p = new(Func_argContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_func_arg
	return p
}

func (*Func_argContext) IsFunc_argContext() {}

func NewFunc_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_argContext {
	var p = new(Func_argContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_func_arg

	return p
}

func (s *Func_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Func_argContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Func_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFunc_arg(s)
	}
}

func (s *Func_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFunc_arg(s)
	}
}

func (p *SyslParser) Func_arg() (localctx IFunc_argContext) {
	localctx = NewFunc_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, SyslParserRULE_func_arg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1092)
		p.Expr()
	}

	return localctx
}

// IFunc_argsContext is an interface to support dynamic dispatch.
type IFunc_argsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunc_argsContext differentiates from other interfaces.
	IsFunc_argsContext()
}

type Func_argsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_argsContext() *Func_argsContext {
	var p = new(Func_argsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_func_args
	return p
}

func (*Func_argsContext) IsFunc_argsContext() {}

func NewFunc_argsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_argsContext {
	var p = new(Func_argsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_func_args

	return p
}

func (s *Func_argsContext) GetParser() antlr.Parser { return s.parser }

func (s *Func_argsContext) AllFunc_arg() []IFunc_argContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunc_argContext)(nil)).Elem())
	var tst = make([]IFunc_argContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunc_argContext)
		}
	}

	return tst
}

func (s *Func_argsContext) Func_arg(i int) IFunc_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunc_argContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunc_argContext)
}

func (s *Func_argsContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *Func_argsContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *Func_argsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_argsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_argsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFunc_args(s)
	}
}

func (s *Func_argsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFunc_args(s)
	}
}

func (p *SyslParser) Func_args() (localctx IFunc_argsContext) {
	localctx = NewFunc_argsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, SyslParserRULE_func_args)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1094)
		p.Func_arg()
	}
	p.SetState(1099)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1095)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1096)
			p.Func_arg()
		}

		p.SetState(1101)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpr_funcContext is an interface to support dynamic dispatch.
type IExpr_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_funcContext differentiates from other interfaces.
	IsExpr_funcContext()
}

type Expr_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_funcContext() *Expr_funcContext {
	var p = new(Expr_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_func
	return p
}

func (*Expr_funcContext) IsExpr_funcContext() {}

func NewExpr_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_funcContext {
	var p = new(Expr_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_func

	return p
}

func (s *Expr_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_funcContext) E_FUNC() antlr.TerminalNode {
	return s.GetToken(SyslParserE_FUNC, 0)
}

func (s *Expr_funcContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_funcContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Expr_funcContext) Func_args() IFunc_argsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunc_argsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunc_argsContext)
}

func (s *Expr_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_func(s)
	}
}

func (s *Expr_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_func(s)
	}
}

func (p *SyslParser) Expr_func() (localctx IExpr_funcContext) {
	localctx = NewExpr_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, SyslParserRULE_expr_func)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1102)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserNativeDataTypes || _la == SyslParserE_FUNC || _la == SyslParserE_Name) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(1103)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1105)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserNativeDataTypes || (((_la-74)&-(0x1f+1)) == 0 && ((1<<uint((_la-74)))&((1<<(SyslParserE_WHATEVER-74))|(1<<(SyslParserE_ARROW_RIGHT-74))|(1<<(SyslParserE_SQ_OPEN-74))|(1<<(SyslParserE_EMPTY_TUPLE-74))|(1<<(SyslParserE_CURLY_OPEN-74))|(1<<(SyslParserE_NULLSAFE_DOT-74))|(1<<(SyslParserE_OPEN_PAREN-74))|(1<<(SyslParserE_PLUS-74))|(1<<(SyslParserE_MINUS-74))|(1<<(SyslParserE_QN-74))|(1<<(SyslParserE_TILDE-74))|(1<<(SyslParserE_NOT-74)))) != 0) || (((_la-112)&-(0x1f+1)) == 0 && ((1<<uint((_la-112)))&((1<<(SyslParserE_IF-112))|(1<<(SyslParserE_TRUE-112))|(1<<(SyslParserE_FALSE-112))|(1<<(SyslParserE_NULL-112))|(1<<(SyslParserE_FUNC-112))|(1<<(SyslParserE_STRING_DBL-112))|(1<<(SyslParserE_STRING_SINGLE-112))|(1<<(SyslParserE_DECIMAL-112))|(1<<(SyslParserE_DIGITS-112))|(1<<(SyslParserE_Name-112))|(1<<(SyslParserE_DOT-112)))) != 0) {
		{
			p.SetState(1104)
			p.Func_args()
		}

	}
	{
		p.SetState(1107)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IRank_exprContext is an interface to support dynamic dispatch.
type IRank_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRank_exprContext differentiates from other interfaces.
	IsRank_exprContext()
}

type Rank_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRank_exprContext() *Rank_exprContext {
	var p = new(Rank_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_rank_expr
	return p
}

func (*Rank_exprContext) IsRank_exprContext() {}

func NewRank_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rank_exprContext {
	var p = new(Rank_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_rank_expr

	return p
}

func (s *Rank_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Rank_exprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Rank_exprContext) E_ASC() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ASC, 0)
}

func (s *Rank_exprContext) E_DESC() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DESC, 0)
}

func (s *Rank_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rank_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rank_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRank_expr(s)
	}
}

func (s *Rank_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRank_expr(s)
	}
}

func (p *SyslParser) Rank_expr() (localctx IRank_exprContext) {
	localctx = NewRank_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, SyslParserRULE_rank_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1109)
		p.Expr()
	}
	p.SetState(1111)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_ASC || _la == SyslParserE_DESC {
		p.SetState(1110)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SyslParserE_ASC || _la == SyslParserE_DESC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}

	return localctx
}

// IRank_expr_listContext is an interface to support dynamic dispatch.
type IRank_expr_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRank_expr_listContext differentiates from other interfaces.
	IsRank_expr_listContext()
}

type Rank_expr_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRank_expr_listContext() *Rank_expr_listContext {
	var p = new(Rank_expr_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_rank_expr_list
	return p
}

func (*Rank_expr_listContext) IsRank_expr_listContext() {}

func NewRank_expr_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rank_expr_listContext {
	var p = new(Rank_expr_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_rank_expr_list

	return p
}

func (s *Rank_expr_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Rank_expr_listContext) AllRank_expr() []IRank_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRank_exprContext)(nil)).Elem())
	var tst = make([]IRank_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRank_exprContext)
		}
	}

	return tst
}

func (s *Rank_expr_listContext) Rank_expr(i int) IRank_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRank_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRank_exprContext)
}

func (s *Rank_expr_listContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *Rank_expr_listContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *Rank_expr_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rank_expr_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rank_expr_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRank_expr_list(s)
	}
}

func (s *Rank_expr_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRank_expr_list(s)
	}
}

func (p *SyslParser) Rank_expr_list() (localctx IRank_expr_listContext) {
	localctx = NewRank_expr_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, SyslParserRULE_rank_expr_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1113)
		p.Rank_expr()
	}
	p.SetState(1118)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1114)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1115)
			p.Rank_expr()
		}

		p.SetState(1120)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpr_rank_funcContext is an interface to support dynamic dispatch.
type IExpr_rank_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_rank_funcContext differentiates from other interfaces.
	IsExpr_rank_funcContext()
}

type Expr_rank_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_rank_funcContext() *Expr_rank_funcContext {
	var p = new(Expr_rank_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_rank_func
	return p
}

func (*Expr_rank_funcContext) IsExpr_rank_funcContext() {}

func NewExpr_rank_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_rank_funcContext {
	var p = new(Expr_rank_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_rank_func

	return p
}

func (s *Expr_rank_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_rank_funcContext) E_RELOPS_RANK() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_RANK, 0)
}

func (s *Expr_rank_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_rank_funcContext) Rank_expr_list() IRank_expr_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRank_expr_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRank_expr_listContext)
}

func (s *Expr_rank_funcContext) E_AS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_AS, 0)
}

func (s *Expr_rank_funcContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_rank_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_rank_funcContext) E_ANGLE_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_OPEN, 0)
}

func (s *Expr_rank_funcContext) View_type_spec() IView_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_type_specContext)
}

func (s *Expr_rank_funcContext) E_ANGLE_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_CLOSE, 0)
}

func (s *Expr_rank_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_rank_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_rank_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_rank_func(s)
	}
}

func (s *Expr_rank_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_rank_func(s)
	}
}

func (p *SyslParser) Expr_rank_func() (localctx IExpr_rank_funcContext) {
	localctx = NewExpr_rank_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, SyslParserRULE_expr_rank_func)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1121)
		p.Match(SyslParserE_RELOPS_RANK)
	}
	p.SetState(1126)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_ANGLE_OPEN {
		{
			p.SetState(1122)
			p.Match(SyslParserE_ANGLE_OPEN)
		}
		{
			p.SetState(1123)
			p.View_type_spec()
		}
		{
			p.SetState(1124)
			p.Match(SyslParserE_ANGLE_CLOSE)
		}

	}
	{
		p.SetState(1128)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	{
		p.SetState(1129)
		p.Rank_expr_list()
	}
	{
		p.SetState(1130)
		p.Match(SyslParserE_AS)
	}
	{
		p.SetState(1131)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1132)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IExpr_agg_funcContext is an interface to support dynamic dispatch.
type IExpr_agg_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_agg_funcContext differentiates from other interfaces.
	IsExpr_agg_funcContext()
}

type Expr_agg_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_agg_funcContext() *Expr_agg_funcContext {
	var p = new(Expr_agg_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_agg_func
	return p
}

func (*Expr_agg_funcContext) IsExpr_agg_funcContext() {}

func NewExpr_agg_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_agg_funcContext {
	var p = new(Expr_agg_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_agg_func

	return p
}

func (s *Expr_agg_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_agg_funcContext) E_RELOPS_AGG() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_AGG, 0)
}

func (s *Expr_agg_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_agg_funcContext) Func_args() IFunc_argsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunc_argsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunc_argsContext)
}

func (s *Expr_agg_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_agg_funcContext) E_scope_var() IE_scope_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_scope_varContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IE_scope_varContext)
}

func (s *Expr_agg_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_agg_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_agg_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_agg_func(s)
	}
}

func (s *Expr_agg_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_agg_func(s)
	}
}

func (p *SyslParser) Expr_agg_func() (localctx IExpr_agg_funcContext) {
	localctx = NewExpr_agg_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, SyslParserRULE_expr_agg_func)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1134)
		p.Match(SyslParserE_RELOPS_AGG)
	}
	{
		p.SetState(1135)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1137)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1136)
			p.E_scope_var()
		}

	}
	{
		p.SetState(1139)
		p.Func_args()
	}
	{
		p.SetState(1140)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IE_scope_varContext is an interface to support dynamic dispatch.
type IE_scope_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsE_scope_varContext differentiates from other interfaces.
	IsE_scope_varContext()
}

type E_scope_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyE_scope_varContext() *E_scope_varContext {
	var p = new(E_scope_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_e_scope_var
	return p
}

func (*E_scope_varContext) IsE_scope_varContext() {}

func NewE_scope_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *E_scope_varContext {
	var p = new(E_scope_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_e_scope_var

	return p
}

func (s *E_scope_varContext) GetParser() antlr.Parser { return s.parser }

func (s *E_scope_varContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *E_scope_varContext) E_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserE_COLON, 0)
}

func (s *E_scope_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *E_scope_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *E_scope_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterE_scope_var(s)
	}
}

func (s *E_scope_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitE_scope_var(s)
	}
}

func (p *SyslParser) E_scope_var() (localctx IE_scope_varContext) {
	localctx = NewE_scope_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, SyslParserRULE_e_scope_var)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1142)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1143)
		p.Match(SyslParserE_COLON)
	}

	return localctx
}

// IFirst_func_targetContext is an interface to support dynamic dispatch.
type IFirst_func_targetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFirst_func_targetContext differentiates from other interfaces.
	IsFirst_func_targetContext()
}

type First_func_targetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFirst_func_targetContext() *First_func_targetContext {
	var p = new(First_func_targetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_first_func_target
	return p
}

func (*First_func_targetContext) IsFirst_func_targetContext() {}

func NewFirst_func_targetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *First_func_targetContext {
	var p = new(First_func_targetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_first_func_target

	return p
}

func (s *First_func_targetContext) GetParser() antlr.Parser { return s.parser }

func (s *First_func_targetContext) E_NULL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NULL, 0)
}

func (s *First_func_targetContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *First_func_targetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *First_func_targetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *First_func_targetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFirst_func_target(s)
	}
}

func (s *First_func_targetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFirst_func_target(s)
	}
}

func (p *SyslParser) First_func_target() (localctx IFirst_func_targetContext) {
	localctx = NewFirst_func_targetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, SyslParserRULE_first_func_target)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1147)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1145)
			p.Match(SyslParserE_NULL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1146)
			p.Expr()
		}

	}

	return localctx
}

// IExpr_first_funcContext is an interface to support dynamic dispatch.
type IExpr_first_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_first_funcContext differentiates from other interfaces.
	IsExpr_first_funcContext()
}

type Expr_first_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_first_funcContext() *Expr_first_funcContext {
	var p = new(Expr_first_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_first_func
	return p
}

func (*Expr_first_funcContext) IsExpr_first_funcContext() {}

func NewExpr_first_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_first_funcContext {
	var p = new(Expr_first_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_first_func

	return p
}

func (s *Expr_first_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_first_funcContext) E_RELOPS_FIRST() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_FIRST, 0)
}

func (s *Expr_first_funcContext) First_func_target() IFirst_func_targetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFirst_func_targetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFirst_func_targetContext)
}

func (s *Expr_first_funcContext) E_BY() antlr.TerminalNode {
	return s.GetToken(SyslParserE_BY, 0)
}

func (s *Expr_first_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_first_funcContext) Rank_expr_list() IRank_expr_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRank_expr_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRank_expr_listContext)
}

func (s *Expr_first_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_first_funcContext) E_scope_var() IE_scope_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_scope_varContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IE_scope_varContext)
}

func (s *Expr_first_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_first_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_first_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_first_func(s)
	}
}

func (s *Expr_first_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_first_func(s)
	}
}

func (p *SyslParser) Expr_first_func() (localctx IExpr_first_funcContext) {
	localctx = NewExpr_first_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, SyslParserRULE_expr_first_func)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1149)
		p.Match(SyslParserE_RELOPS_FIRST)
	}
	{
		p.SetState(1150)
		p.First_func_target()
	}
	{
		p.SetState(1151)
		p.Match(SyslParserE_BY)
	}
	{
		p.SetState(1152)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1154)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1153)
			p.E_scope_var()
		}

	}
	{
		p.SetState(1156)
		p.Rank_expr_list()
	}
	{
		p.SetState(1157)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IE_single_arg_funcContext is an interface to support dynamic dispatch.
type IE_single_arg_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsE_single_arg_funcContext differentiates from other interfaces.
	IsE_single_arg_funcContext()
}

type E_single_arg_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyE_single_arg_funcContext() *E_single_arg_funcContext {
	var p = new(E_single_arg_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_e_single_arg_func
	return p
}

func (*E_single_arg_funcContext) IsE_single_arg_funcContext() {}

func NewE_single_arg_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *E_single_arg_funcContext {
	var p = new(E_single_arg_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_e_single_arg_func

	return p
}

func (s *E_single_arg_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *E_single_arg_funcContext) E_RELOPS_WHERE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_WHERE, 0)
}

func (s *E_single_arg_funcContext) E_RELOPS_FLATTEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_FLATTEN, 0)
}

func (s *E_single_arg_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *E_single_arg_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *E_single_arg_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterE_single_arg_func(s)
	}
}

func (s *E_single_arg_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitE_single_arg_func(s)
	}
}

func (p *SyslParser) E_single_arg_func() (localctx IE_single_arg_funcContext) {
	localctx = NewE_single_arg_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, SyslParserRULE_e_single_arg_func)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1159)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserE_RELOPS_WHERE || _la == SyslParserE_RELOPS_FLATTEN) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IExpr_single_arg_funcContext is an interface to support dynamic dispatch.
type IExpr_single_arg_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_single_arg_funcContext differentiates from other interfaces.
	IsExpr_single_arg_funcContext()
}

type Expr_single_arg_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_single_arg_funcContext() *Expr_single_arg_funcContext {
	var p = new(Expr_single_arg_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_single_arg_func
	return p
}

func (*Expr_single_arg_funcContext) IsExpr_single_arg_funcContext() {}

func NewExpr_single_arg_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_single_arg_funcContext {
	var p = new(Expr_single_arg_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_single_arg_func

	return p
}

func (s *Expr_single_arg_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_single_arg_funcContext) E_single_arg_func() IE_single_arg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_single_arg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IE_single_arg_funcContext)
}

func (s *Expr_single_arg_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_single_arg_funcContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_single_arg_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_single_arg_funcContext) E_scope_var() IE_scope_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_scope_varContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IE_scope_varContext)
}

func (s *Expr_single_arg_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_single_arg_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_single_arg_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_single_arg_func(s)
	}
}

func (s *Expr_single_arg_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_single_arg_func(s)
	}
}

func (p *SyslParser) Expr_single_arg_func() (localctx IExpr_single_arg_funcContext) {
	localctx = NewExpr_single_arg_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, SyslParserRULE_expr_single_arg_func)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1161)
		p.E_single_arg_func()
	}
	{
		p.SetState(1162)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1164)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1163)
			p.E_scope_var()
		}

	}
	{
		p.SetState(1166)
		p.Expr()
	}
	{
		p.SetState(1167)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IExpr_any_funcContext is an interface to support dynamic dispatch.
type IExpr_any_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_any_funcContext differentiates from other interfaces.
	IsExpr_any_funcContext()
}

type Expr_any_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_any_funcContext() *Expr_any_funcContext {
	var p = new(Expr_any_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_any_func
	return p
}

func (*Expr_any_funcContext) IsExpr_any_funcContext() {}

func NewExpr_any_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_any_funcContext {
	var p = new(Expr_any_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_any_func

	return p
}

func (s *Expr_any_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_any_funcContext) E_RELOPS_ANY() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_ANY, 0)
}

func (s *Expr_any_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_any_funcContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_any_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_any_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_any_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_any_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_any_func(s)
	}
}

func (s *Expr_any_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_any_func(s)
	}
}

func (p *SyslParser) Expr_any_func() (localctx IExpr_any_funcContext) {
	localctx = NewExpr_any_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, SyslParserRULE_expr_any_func)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1169)
		p.Match(SyslParserE_RELOPS_ANY)
	}
	{
		p.SetState(1170)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	{
		p.SetState(1171)
		p.Expr()
	}
	{
		p.SetState(1172)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IExpr_single_or_nullContext is an interface to support dynamic dispatch.
type IExpr_single_or_nullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_single_or_nullContext differentiates from other interfaces.
	IsExpr_single_or_nullContext()
}

type Expr_single_or_nullContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_single_or_nullContext() *Expr_single_or_nullContext {
	var p = new(Expr_single_or_nullContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_single_or_null
	return p
}

func (*Expr_single_or_nullContext) IsExpr_single_or_nullContext() {}

func NewExpr_single_or_nullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_single_or_nullContext {
	var p = new(Expr_single_or_nullContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_single_or_null

	return p
}

func (s *Expr_single_or_nullContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_single_or_nullContext) E_RELOPS_SINGLE_NULL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_SINGLE_NULL, 0)
}

func (s *Expr_single_or_nullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_single_or_nullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_single_or_nullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_single_or_null(s)
	}
}

func (s *Expr_single_or_nullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_single_or_null(s)
	}
}

func (p *SyslParser) Expr_single_or_null() (localctx IExpr_single_or_nullContext) {
	localctx = NewExpr_single_or_nullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, SyslParserRULE_expr_single_or_null)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1174)
		p.Match(SyslParserE_RELOPS_SINGLE_NULL)
	}

	return localctx
}

// IExpr_snapshotContext is an interface to support dynamic dispatch.
type IExpr_snapshotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_snapshotContext differentiates from other interfaces.
	IsExpr_snapshotContext()
}

type Expr_snapshotContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_snapshotContext() *Expr_snapshotContext {
	var p = new(Expr_snapshotContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_snapshot
	return p
}

func (*Expr_snapshotContext) IsExpr_snapshotContext() {}

func NewExpr_snapshotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_snapshotContext {
	var p = new(Expr_snapshotContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_snapshot

	return p
}

func (s *Expr_snapshotContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_snapshotContext) E_RELOPS_SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_SNAPSHOT, 0)
}

func (s *Expr_snapshotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_snapshotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_snapshotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_snapshot(s)
	}
}

func (s *Expr_snapshotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_snapshot(s)
	}
}

func (p *SyslParser) Expr_snapshot() (localctx IExpr_snapshotContext) {
	localctx = NewExpr_snapshotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, SyslParserRULE_expr_snapshot)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1176)
		p.Match(SyslParserE_RELOPS_SNAPSHOT)
	}

	return localctx
}

// IExpr_countContext is an interface to support dynamic dispatch.
type IExpr_countContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_countContext differentiates from other interfaces.
	IsExpr_countContext()
}

type Expr_countContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_countContext() *Expr_countContext {
	var p = new(Expr_countContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_count
	return p
}

func (*Expr_countContext) IsExpr_countContext() {}

func NewExpr_countContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_countContext {
	var p = new(Expr_countContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_count

	return p
}

func (s *Expr_countContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_countContext) E_RELOPS_COUNT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_COUNT, 0)
}

func (s *Expr_countContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_countContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_countContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_count(s)
	}
}

func (s *Expr_countContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_count(s)
	}
}

func (p *SyslParser) Expr_count() (localctx IExpr_countContext) {
	localctx = NewExpr_countContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, SyslParserRULE_expr_count)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1178)
		p.Match(SyslParserE_RELOPS_COUNT)
	}

	return localctx
}

// IExpr_navigate_attrContext is an interface to support dynamic dispatch.
type IExpr_navigate_attrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_navigate_attrContext differentiates from other interfaces.
	IsExpr_navigate_attrContext()
}

type Expr_navigate_attrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_navigate_attrContext() *Expr_navigate_attrContext {
	var p = new(Expr_navigate_attrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_navigate_attr
	return p
}

func (*Expr_navigate_attrContext) IsExpr_navigate_attrContext() {}

func NewExpr_navigate_attrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_navigate_attrContext {
	var p = new(Expr_navigate_attrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_navigate_attr

	return p
}

func (s *Expr_navigate_attrContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_navigate_attrContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_navigate_attrContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *Expr_navigate_attrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_navigate_attrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_navigate_attrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_navigate_attr(s)
	}
}

func (s *Expr_navigate_attrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_navigate_attr(s)
	}
}

func (p *SyslParser) Expr_navigate_attr() (localctx IExpr_navigate_attrContext) {
	localctx = NewExpr_navigate_attrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, SyslParserRULE_expr_navigate_attr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1181)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_DOT {
		{
			p.SetState(1180)
			p.Match(SyslParserE_DOT)
		}

	}
	{
		p.SetState(1183)
		p.Match(SyslParserE_Name)
	}

	return localctx
}

// IExpr_navigateContext is an interface to support dynamic dispatch.
type IExpr_navigateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_navigateContext differentiates from other interfaces.
	IsExpr_navigateContext()
}

type Expr_navigateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_navigateContext() *Expr_navigateContext {
	var p = new(Expr_navigateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_navigate
	return p
}

func (*Expr_navigateContext) IsExpr_navigateContext() {}

func NewExpr_navigateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_navigateContext {
	var p = new(Expr_navigateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_navigate

	return p
}

func (s *Expr_navigateContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_navigateContext) E_ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ARROW_RIGHT, 0)
}

func (s *Expr_navigateContext) Expr_navigate_attr() IExpr_navigate_attrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigate_attrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigate_attrContext)
}

func (s *Expr_navigateContext) E_QN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_QN, 0)
}

func (s *Expr_navigateContext) E_VIA() antlr.TerminalNode {
	return s.GetToken(SyslParserE_VIA, 0)
}

func (s *Expr_navigateContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_navigateContext) E_SET_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SET_OF, 0)
}

func (s *Expr_navigateContext) E_SEQUENCE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SEQUENCE_OF, 0)
}

func (s *Expr_navigateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_navigateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_navigateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_navigate(s)
	}
}

func (s *Expr_navigateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_navigate(s)
	}
}

func (p *SyslParser) Expr_navigate() (localctx IExpr_navigateContext) {
	localctx = NewExpr_navigateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, SyslParserRULE_expr_navigate)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1186)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_QN {
		{
			p.SetState(1185)
			p.Match(SyslParserE_QN)
		}

	}
	{
		p.SetState(1188)
		p.Match(SyslParserE_ARROW_RIGHT)
	}
	p.SetState(1190)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_SEQUENCE_OF || _la == SyslParserE_SET_OF {
		p.SetState(1189)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SyslParserE_SEQUENCE_OF || _la == SyslParserE_SET_OF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	{
		p.SetState(1192)
		p.Expr_navigate_attr()
	}
	p.SetState(1195)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1193)
			p.Match(SyslParserE_VIA)
		}
		{
			p.SetState(1194)
			p.Match(SyslParserE_Name)
		}

	}

	return localctx
}

// IMatching_rhsContext is an interface to support dynamic dispatch.
type IMatching_rhsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMatching_rhsContext differentiates from other interfaces.
	IsMatching_rhsContext()
}

type Matching_rhsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatching_rhsContext() *Matching_rhsContext {
	var p = new(Matching_rhsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_matching_rhs
	return p
}

func (*Matching_rhsContext) IsMatching_rhsContext() {}

func NewMatching_rhsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Matching_rhsContext {
	var p = new(Matching_rhsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_matching_rhs

	return p
}

func (s *Matching_rhsContext) GetParser() antlr.Parser { return s.parser }

func (s *Matching_rhsContext) Expr_table_of_op() IExpr_table_of_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_table_of_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_table_of_opContext)
}

func (s *Matching_rhsContext) Expr_navigate() IExpr_navigateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigateContext)
}

func (s *Matching_rhsContext) AtomT_paren() IAtomT_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomT_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomT_parenContext)
}

func (s *Matching_rhsContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Matching_rhsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Matching_rhsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Matching_rhsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterMatching_rhs(s)
	}
}

func (s *Matching_rhsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitMatching_rhs(s)
	}
}

func (p *SyslParser) Matching_rhs() (localctx IMatching_rhsContext) {
	localctx = NewMatching_rhsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, SyslParserRULE_matching_rhs)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1201)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_NULLSAFE_DOT, SyslParserE_DOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1197)
			p.Expr_table_of_op()
		}

	case SyslParserE_ARROW_RIGHT, SyslParserE_QN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1198)
			p.Expr_navigate()
		}

	case SyslParserE_OPEN_PAREN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1199)
			p.AtomT_paren()
		}

	case SyslParserE_Name:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1200)
			p.Match(SyslParserE_Name)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISquiggly_argsContext is an interface to support dynamic dispatch.
type ISquiggly_argsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSquiggly_argsContext differentiates from other interfaces.
	IsSquiggly_argsContext()
}

type Squiggly_argsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySquiggly_argsContext() *Squiggly_argsContext {
	var p = new(Squiggly_argsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_squiggly_args
	return p
}

func (*Squiggly_argsContext) IsSquiggly_argsContext() {}

func NewSquiggly_argsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Squiggly_argsContext {
	var p = new(Squiggly_argsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_squiggly_args

	return p
}

func (s *Squiggly_argsContext) GetParser() antlr.Parser { return s.parser }

func (s *Squiggly_argsContext) E_SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SQ_OPEN, 0)
}

func (s *Squiggly_argsContext) AllE_Name() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_Name)
}

func (s *Squiggly_argsContext) E_Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, i)
}

func (s *Squiggly_argsContext) E_SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SQ_CLOSE, 0)
}

func (s *Squiggly_argsContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *Squiggly_argsContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *Squiggly_argsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Squiggly_argsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Squiggly_argsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSquiggly_args(s)
	}
}

func (s *Squiggly_argsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSquiggly_args(s)
	}
}

func (p *SyslParser) Squiggly_args() (localctx ISquiggly_argsContext) {
	localctx = NewSquiggly_argsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, SyslParserRULE_squiggly_args)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1203)
		p.Match(SyslParserE_SQ_OPEN)
	}
	{
		p.SetState(1204)
		p.Match(SyslParserE_Name)
	}
	p.SetState(1209)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1205)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1206)
			p.Match(SyslParserE_Name)
		}

		p.SetState(1211)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1212)
		p.Match(SyslParserE_SQ_CLOSE)
	}

	return localctx
}

// IExpr_matchingContext is an interface to support dynamic dispatch.
type IExpr_matchingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_matchingContext differentiates from other interfaces.
	IsExpr_matchingContext()
}

type Expr_matchingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_matchingContext() *Expr_matchingContext {
	var p = new(Expr_matchingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_matching
	return p
}

func (*Expr_matchingContext) IsExpr_matchingContext() {}

func NewExpr_matchingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_matchingContext {
	var p = new(Expr_matchingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_matching

	return p
}

func (s *Expr_matchingContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_matchingContext) E_TILDE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TILDE, 0)
}

func (s *Expr_matchingContext) E_ANGLE_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_CLOSE, 0)
}

func (s *Expr_matchingContext) Matching_rhs() IMatching_rhsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMatching_rhsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMatching_rhsContext)
}

func (s *Expr_matchingContext) E_NOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NOT, 0)
}

func (s *Expr_matchingContext) Squiggly_args() ISquiggly_argsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISquiggly_argsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISquiggly_argsContext)
}

func (s *Expr_matchingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_matchingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_matchingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_matching(s)
	}
}

func (s *Expr_matchingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_matching(s)
	}
}

func (p *SyslParser) Expr_matching() (localctx IExpr_matchingContext) {
	localctx = NewExpr_matchingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, SyslParserRULE_expr_matching)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1215)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_NOT {
		{
			p.SetState(1214)
			p.Match(SyslParserE_NOT)
		}

	}
	{
		p.SetState(1217)
		p.Match(SyslParserE_TILDE)
	}
	p.SetState(1219)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_SQ_OPEN {
		{
			p.SetState(1218)
			p.Squiggly_args()
		}

	}
	{
		p.SetState(1221)
		p.Match(SyslParserE_ANGLE_CLOSE)
	}
	{
		p.SetState(1222)
		p.Matching_rhs()
	}

	return localctx
}

// IRelopContext is an interface to support dynamic dispatch.
type IRelopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelopContext differentiates from other interfaces.
	IsRelopContext()
}

type RelopContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelopContext() *RelopContext {
	var p = new(RelopContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_relop
	return p
}

func (*RelopContext) IsRelopContext() {}

func NewRelopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelopContext {
	var p = new(RelopContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_relop

	return p
}

func (s *RelopContext) GetParser() antlr.Parser { return s.parser }

func (s *RelopContext) Expr_table_of_op() IExpr_table_of_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_table_of_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_table_of_opContext)
}

func (s *RelopContext) Expr_rank_func() IExpr_rank_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_rank_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_rank_funcContext)
}

func (s *RelopContext) Expr_agg_func() IExpr_agg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_agg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_agg_funcContext)
}

func (s *RelopContext) Expr_single_arg_func() IExpr_single_arg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_single_arg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_single_arg_funcContext)
}

func (s *RelopContext) Expr_any_func() IExpr_any_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_any_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_any_funcContext)
}

func (s *RelopContext) Expr_count() IExpr_countContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_countContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_countContext)
}

func (s *RelopContext) Expr_single_or_null() IExpr_single_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_single_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_single_or_nullContext)
}

func (s *RelopContext) Expr_snapshot() IExpr_snapshotContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_snapshotContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_snapshotContext)
}

func (s *RelopContext) Expr_first_func() IExpr_first_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_first_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_first_funcContext)
}

func (s *RelopContext) Expr_navigate() IExpr_navigateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigateContext)
}

func (s *RelopContext) Expr_matching() IExpr_matchingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_matchingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_matchingContext)
}

func (s *RelopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRelop(s)
	}
}

func (s *RelopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRelop(s)
	}
}

func (p *SyslParser) Relop() (localctx IRelopContext) {
	localctx = NewRelopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, SyslParserRULE_relop)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1235)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_NULLSAFE_DOT, SyslParserE_DOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1224)
			p.Expr_table_of_op()
		}

	case SyslParserE_RELOPS_RANK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1225)
			p.Expr_rank_func()
		}

	case SyslParserE_RELOPS_AGG:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1226)
			p.Expr_agg_func()
		}

	case SyslParserE_RELOPS_WHERE, SyslParserE_RELOPS_FLATTEN:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1227)
			p.Expr_single_arg_func()
		}

	case SyslParserE_RELOPS_ANY:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1228)
			p.Expr_any_func()
		}

	case SyslParserE_RELOPS_COUNT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1229)
			p.Expr_count()
		}

	case SyslParserE_RELOPS_SINGLE_NULL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1230)
			p.Expr_single_or_null()
		}

	case SyslParserE_RELOPS_SNAPSHOT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1231)
			p.Expr_snapshot()
		}

	case SyslParserE_RELOPS_FIRST:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1232)
			p.Expr_first_func()
		}

	case SyslParserE_ARROW_RIGHT, SyslParserE_QN:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1233)
			p.Expr_navigate()
		}

	case SyslParserE_TILDE, SyslParserE_NOT:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1234)
			p.Expr_matching()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IList_itemContext is an interface to support dynamic dispatch.
type IList_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_itemContext differentiates from other interfaces.
	IsList_itemContext()
}

type List_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_itemContext() *List_itemContext {
	var p = new(List_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_list_item
	return p
}

func (*List_itemContext) IsList_itemContext() {}

func NewList_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_itemContext {
	var p = new(List_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_list_item

	return p
}

func (s *List_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *List_itemContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *List_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterList_item(s)
	}
}

func (s *List_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitList_item(s)
	}
}

func (p *SyslParser) List_item() (localctx IList_itemContext) {
	localctx = NewList_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, SyslParserRULE_list_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1237)
		p.Expr()
	}

	return localctx
}

// IExpr_listContext is an interface to support dynamic dispatch.
type IExpr_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_listContext differentiates from other interfaces.
	IsExpr_listContext()
}

type Expr_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_listContext() *Expr_listContext {
	var p = new(Expr_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_list
	return p
}

func (*Expr_listContext) IsExpr_listContext() {}

func NewExpr_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_listContext {
	var p = new(Expr_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_list

	return p
}

func (s *Expr_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_listContext) AllList_item() []IList_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IList_itemContext)(nil)).Elem())
	var tst = make([]IList_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IList_itemContext)
		}
	}

	return tst
}

func (s *Expr_listContext) List_item(i int) IList_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IList_itemContext)
}

func (s *Expr_listContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *Expr_listContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *Expr_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_list(s)
	}
}

func (s *Expr_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_list(s)
	}
}

func (p *SyslParser) Expr_list() (localctx IExpr_listContext) {
	localctx = NewExpr_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, SyslParserRULE_expr_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1239)
		p.List_item()
	}
	p.SetState(1244)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1240)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1241)
			p.List_item()
		}

		p.SetState(1246)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpr_setContext is an interface to support dynamic dispatch.
type IExpr_setContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_setContext differentiates from other interfaces.
	IsExpr_setContext()
}

type Expr_setContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_setContext() *Expr_setContext {
	var p = new(Expr_setContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_set
	return p
}

func (*Expr_setContext) IsExpr_setContext() {}

func NewExpr_setContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_setContext {
	var p = new(Expr_setContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_set

	return p
}

func (s *Expr_setContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_setContext) E_CURLY_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CURLY_OPEN, 0)
}

func (s *Expr_setContext) Expr_list() IExpr_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *Expr_setContext) E_CURLY_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CURLY_CLOSE, 0)
}

func (s *Expr_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_setContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_set(s)
	}
}

func (s *Expr_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_set(s)
	}
}

func (p *SyslParser) Expr_set() (localctx IExpr_setContext) {
	localctx = NewExpr_setContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, SyslParserRULE_expr_set)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1247)
		p.Match(SyslParserE_CURLY_OPEN)
	}
	{
		p.SetState(1248)
		p.Expr_list()
	}
	{
		p.SetState(1249)
		p.Match(SyslParserE_CURLY_CLOSE)
	}

	return localctx
}

// IEmpty_tupleContext is an interface to support dynamic dispatch.
type IEmpty_tupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmpty_tupleContext differentiates from other interfaces.
	IsEmpty_tupleContext()
}

type Empty_tupleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmpty_tupleContext() *Empty_tupleContext {
	var p = new(Empty_tupleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_empty_tuple
	return p
}

func (*Empty_tupleContext) IsEmpty_tupleContext() {}

func NewEmpty_tupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Empty_tupleContext {
	var p = new(Empty_tupleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_empty_tuple

	return p
}

func (s *Empty_tupleContext) GetParser() antlr.Parser { return s.parser }

func (s *Empty_tupleContext) E_EMPTY_TUPLE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_EMPTY_TUPLE, 0)
}

func (s *Empty_tupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Empty_tupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Empty_tupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterEmpty_tuple(s)
	}
}

func (s *Empty_tupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitEmpty_tuple(s)
	}
}

func (p *SyslParser) Empty_tuple() (localctx IEmpty_tupleContext) {
	localctx = NewEmpty_tupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, SyslParserRULE_empty_tuple)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1251)
		p.Match(SyslParserE_EMPTY_TUPLE)
	}

	return localctx
}

// IAtom_dot_relopContext is an interface to support dynamic dispatch.
type IAtom_dot_relopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtom_dot_relopContext differentiates from other interfaces.
	IsAtom_dot_relopContext()
}

type Atom_dot_relopContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtom_dot_relopContext() *Atom_dot_relopContext {
	var p = new(Atom_dot_relopContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atom_dot_relop
	return p
}

func (*Atom_dot_relopContext) IsAtom_dot_relopContext() {}

func NewAtom_dot_relopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Atom_dot_relopContext {
	var p = new(Atom_dot_relopContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atom_dot_relop

	return p
}

func (s *Atom_dot_relopContext) GetParser() antlr.Parser { return s.parser }

func (s *Atom_dot_relopContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *Atom_dot_relopContext) Expr_rank_func() IExpr_rank_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_rank_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_rank_funcContext)
}

func (s *Atom_dot_relopContext) Expr_agg_func() IExpr_agg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_agg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_agg_funcContext)
}

func (s *Atom_dot_relopContext) Expr_single_arg_func() IExpr_single_arg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_single_arg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_single_arg_funcContext)
}

func (s *Atom_dot_relopContext) Expr_any_func() IExpr_any_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_any_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_any_funcContext)
}

func (s *Atom_dot_relopContext) Expr_count() IExpr_countContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_countContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_countContext)
}

func (s *Atom_dot_relopContext) Expr_single_or_null() IExpr_single_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_single_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_single_or_nullContext)
}

func (s *Atom_dot_relopContext) Expr_snapshot() IExpr_snapshotContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_snapshotContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_snapshotContext)
}

func (s *Atom_dot_relopContext) Expr_first_func() IExpr_first_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_first_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_first_funcContext)
}

func (s *Atom_dot_relopContext) Expr_navigate() IExpr_navigateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigateContext)
}

func (s *Atom_dot_relopContext) Expr_matching() IExpr_matchingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_matchingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_matchingContext)
}

func (s *Atom_dot_relopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Atom_dot_relopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Atom_dot_relopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtom_dot_relop(s)
	}
}

func (s *Atom_dot_relopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtom_dot_relop(s)
	}
}

func (p *SyslParser) Atom_dot_relop() (localctx IAtom_dot_relopContext) {
	localctx = NewAtom_dot_relopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, SyslParserRULE_atom_dot_relop)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1253)
		p.Match(SyslParserE_DOT)
	}
	p.SetState(1264)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_RELOPS_RANK:
		{
			p.SetState(1254)
			p.Expr_rank_func()
		}

	case SyslParserE_RELOPS_AGG:
		{
			p.SetState(1255)
			p.Expr_agg_func()
		}

	case SyslParserE_RELOPS_WHERE, SyslParserE_RELOPS_FLATTEN:
		{
			p.SetState(1256)
			p.Expr_single_arg_func()
		}

	case SyslParserE_RELOPS_ANY:
		{
			p.SetState(1257)
			p.Expr_any_func()
		}

	case SyslParserE_RELOPS_COUNT:
		{
			p.SetState(1258)
			p.Expr_count()
		}

	case SyslParserE_RELOPS_SINGLE_NULL:
		{
			p.SetState(1259)
			p.Expr_single_or_null()
		}

	case SyslParserE_RELOPS_SNAPSHOT:
		{
			p.SetState(1260)
			p.Expr_snapshot()
		}

	case SyslParserE_RELOPS_FIRST:
		{
			p.SetState(1261)
			p.Expr_first_func()
		}

	case SyslParserE_ARROW_RIGHT, SyslParserE_QN:
		{
			p.SetState(1262)
			p.Expr_navigate()
		}

	case SyslParserE_TILDE, SyslParserE_NOT:
		{
			p.SetState(1263)
			p.Expr_matching()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAtomT_implied_dotContext is an interface to support dynamic dispatch.
type IAtomT_implied_dotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomT_implied_dotContext differentiates from other interfaces.
	IsAtomT_implied_dotContext()
}

type AtomT_implied_dotContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomT_implied_dotContext() *AtomT_implied_dotContext {
	var p = new(AtomT_implied_dotContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atomT_implied_dot
	return p
}

func (*AtomT_implied_dotContext) IsAtomT_implied_dotContext() {}

func NewAtomT_implied_dotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomT_implied_dotContext {
	var p = new(AtomT_implied_dotContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atomT_implied_dot

	return p
}

func (s *AtomT_implied_dotContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomT_implied_dotContext) Atom_dot_relop() IAtom_dot_relopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtom_dot_relopContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtom_dot_relopContext)
}

func (s *AtomT_implied_dotContext) Expr_navigate() IExpr_navigateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigateContext)
}

func (s *AtomT_implied_dotContext) Expr_matching() IExpr_matchingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_matchingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_matchingContext)
}

func (s *AtomT_implied_dotContext) Expr_table_of_op() IExpr_table_of_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_table_of_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_table_of_opContext)
}

func (s *AtomT_implied_dotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomT_implied_dotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomT_implied_dotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtomT_implied_dot(s)
	}
}

func (s *AtomT_implied_dotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtomT_implied_dot(s)
	}
}

func (p *SyslParser) AtomT_implied_dot() (localctx IAtomT_implied_dotContext) {
	localctx = NewAtomT_implied_dotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, SyslParserRULE_atomT_implied_dot)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1270)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1266)
			p.Atom_dot_relop()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1267)
			p.Expr_navigate()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1268)
			p.Expr_matching()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1269)
			p.Expr_table_of_op()
		}

	}

	return localctx
}

// IAtomT_nameContext is an interface to support dynamic dispatch.
type IAtomT_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomT_nameContext differentiates from other interfaces.
	IsAtomT_nameContext()
}

type AtomT_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomT_nameContext() *AtomT_nameContext {
	var p = new(AtomT_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atomT_name
	return p
}

func (*AtomT_nameContext) IsAtomT_nameContext() {}

func NewAtomT_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomT_nameContext {
	var p = new(AtomT_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atomT_name

	return p
}

func (s *AtomT_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomT_nameContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *AtomT_nameContext) E_WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserE_WHATEVER, 0)
}

func (s *AtomT_nameContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *AtomT_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomT_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomT_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtomT_name(s)
	}
}

func (s *AtomT_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtomT_name(s)
	}
}

func (p *SyslParser) AtomT_name() (localctx IAtomT_nameContext) {
	localctx = NewAtomT_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, SyslParserRULE_atomT_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1272)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserE_WHATEVER || _la == SyslParserE_Name || _la == SyslParserE_DOT) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IAtomT_parenContext is an interface to support dynamic dispatch.
type IAtomT_parenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomT_parenContext differentiates from other interfaces.
	IsAtomT_parenContext()
}

type AtomT_parenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomT_parenContext() *AtomT_parenContext {
	var p = new(AtomT_parenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atomT_paren
	return p
}

func (*AtomT_parenContext) IsAtomT_parenContext() {}

func NewAtomT_parenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomT_parenContext {
	var p = new(AtomT_parenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atomT_paren

	return p
}

func (s *AtomT_parenContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomT_parenContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *AtomT_parenContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AtomT_parenContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *AtomT_parenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomT_parenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomT_parenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtomT_paren(s)
	}
}

func (s *AtomT_parenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtomT_paren(s)
	}
}

func (p *SyslParser) AtomT_paren() (localctx IAtomT_parenContext) {
	localctx = NewAtomT_parenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, SyslParserRULE_atomT_paren)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1274)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	{
		p.SetState(1275)
		p.Expr()
	}
	{
		p.SetState(1276)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IExpr_atom_listContext is an interface to support dynamic dispatch.
type IExpr_atom_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_atom_listContext differentiates from other interfaces.
	IsExpr_atom_listContext()
}

type Expr_atom_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_atom_listContext() *Expr_atom_listContext {
	var p = new(Expr_atom_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_atom_list
	return p
}

func (*Expr_atom_listContext) IsExpr_atom_listContext() {}

func NewExpr_atom_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_atom_listContext {
	var p = new(Expr_atom_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_atom_list

	return p
}

func (s *Expr_atom_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_atom_listContext) E_SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SQ_OPEN, 0)
}

func (s *Expr_atom_listContext) Expr_list() IExpr_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *Expr_atom_listContext) E_SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SQ_CLOSE, 0)
}

func (s *Expr_atom_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_atom_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_atom_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_atom_list(s)
	}
}

func (s *Expr_atom_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_atom_list(s)
	}
}

func (p *SyslParser) Expr_atom_list() (localctx IExpr_atom_listContext) {
	localctx = NewExpr_atom_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, SyslParserRULE_expr_atom_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1278)
		p.Match(SyslParserE_SQ_OPEN)
	}
	{
		p.SetState(1279)
		p.Expr_list()
	}
	{
		p.SetState(1280)
		p.Match(SyslParserE_SQ_CLOSE)
	}

	return localctx
}

// IAtomTContext is an interface to support dynamic dispatch.
type IAtomTContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomTContext differentiates from other interfaces.
	IsAtomTContext()
}

type AtomTContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomTContext() *AtomTContext {
	var p = new(AtomTContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atomT
	return p
}

func (*AtomTContext) IsAtomTContext() {}

func NewAtomTContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomTContext {
	var p = new(AtomTContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atomT

	return p
}

func (s *AtomTContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomTContext) Expr_func() IExpr_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *AtomTContext) Expr_set() IExpr_setContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_setContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_setContext)
}

func (s *AtomTContext) Expr_atom_list() IExpr_atom_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_atom_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_atom_listContext)
}

func (s *AtomTContext) Empty_tuple() IEmpty_tupleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmpty_tupleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmpty_tupleContext)
}

func (s *AtomTContext) AtomT_paren() IAtomT_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomT_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomT_parenContext)
}

func (s *AtomTContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AtomTContext) AtomT_implied_dot() IAtomT_implied_dotContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomT_implied_dotContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomT_implied_dotContext)
}

func (s *AtomTContext) AtomT_name() IAtomT_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomT_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomT_nameContext)
}

func (s *AtomTContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomTContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomTContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtomT(s)
	}
}

func (s *AtomTContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtomT(s)
	}
}

func (p *SyslParser) AtomT() (localctx IAtomTContext) {
	localctx = NewAtomTContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, SyslParserRULE_atomT)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1290)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1282)
			p.Expr_func()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1283)
			p.Expr_set()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1284)
			p.Expr_atom_list()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1285)
			p.Empty_tuple()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1286)
			p.AtomT_paren()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1287)
			p.Literal()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1288)
			p.AtomT_implied_dot()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1289)
			p.AtomT_name()
		}

	}

	return localctx
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atom
	return p
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) AtomT() IAtomTContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomTContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomTContext)
}

func (s *AtomContext) AllRelop() []IRelopContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelopContext)(nil)).Elem())
	var tst = make([]IRelopContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelopContext)
		}
	}

	return tst
}

func (s *AtomContext) Relop(i int) IRelopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelopContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelopContext)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtom(s)
	}
}

func (p *SyslParser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, SyslParserRULE_atom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1292)
		p.AtomT()
	}
	p.SetState(1296)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1293)
				p.Relop()
			}

		}
		p.SetState(1298)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext())
	}

	return localctx
}

// IPowerTContext is an interface to support dynamic dispatch.
type IPowerTContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPowerTContext differentiates from other interfaces.
	IsPowerTContext()
}

type PowerTContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowerTContext() *PowerTContext {
	var p = new(PowerTContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_powerT
	return p
}

func (*PowerTContext) IsPowerTContext() {}

func NewPowerTContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowerTContext {
	var p = new(PowerTContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_powerT

	return p
}

func (s *PowerTContext) GetParser() antlr.Parser { return s.parser }

func (s *PowerTContext) E_POW() antlr.TerminalNode {
	return s.GetToken(SyslParserE_POW, 0)
}

func (s *PowerTContext) UnaryTerm() IUnaryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryTermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryTermContext)
}

func (s *PowerTContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerTContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowerTContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterPowerT(s)
	}
}

func (s *PowerTContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitPowerT(s)
	}
}

func (p *SyslParser) PowerT() (localctx IPowerTContext) {
	localctx = NewPowerTContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, SyslParserRULE_powerT)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1299)
		p.Match(SyslParserE_POW)
	}
	{
		p.SetState(1300)
		p.UnaryTerm()
	}

	return localctx
}

// IPowerContext is an interface to support dynamic dispatch.
type IPowerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPowerContext differentiates from other interfaces.
	IsPowerContext()
}

type PowerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowerContext() *PowerContext {
	var p = new(PowerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_power
	return p
}

func (*PowerContext) IsPowerContext() {}

func NewPowerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowerContext {
	var p = new(PowerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_power

	return p
}

func (s *PowerContext) GetParser() antlr.Parser { return s.parser }

func (s *PowerContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *PowerContext) PowerT() IPowerTContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPowerTContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPowerTContext)
}

func (s *PowerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterPower(s)
	}
}

func (s *PowerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitPower(s)
	}
}

func (p *SyslParser) Power() (localctx IPowerContext) {
	localctx = NewPowerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, SyslParserRULE_power)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1302)
		p.Atom()
	}
	p.SetState(1304)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 133, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1303)
			p.PowerT()
		}

	}

	return localctx
}

// IUnaryTermContext is an interface to support dynamic dispatch.
type IUnaryTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnaryTermContext differentiates from other interfaces.
	IsUnaryTermContext()
}

type UnaryTermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryTermContext() *UnaryTermContext {
	var p = new(UnaryTermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_unaryTerm
	return p
}

func (*UnaryTermContext) IsUnaryTermContext() {}

func NewUnaryTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryTermContext {
	var p = new(UnaryTermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_unaryTerm

	return p
}

func (s *UnaryTermContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryTermContext) Power() IPowerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPowerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPowerContext)
}

func (s *UnaryTermContext) E_PLUS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_PLUS, 0)
}

func (s *UnaryTermContext) E_MINUS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_MINUS, 0)
}

func (s *UnaryTermContext) E_NOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NOT, 0)
}

func (s *UnaryTermContext) E_TILDE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TILDE, 0)
}

func (s *UnaryTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterUnaryTerm(s)
	}
}

func (s *UnaryTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitUnaryTerm(s)
	}
}

func (p *SyslParser) UnaryTerm() (localctx IUnaryTermContext) {
	localctx = NewUnaryTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, SyslParserRULE_unaryTerm)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1307)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext()) == 1 {
		p.SetState(1306)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-95)&-(0x1f+1)) == 0 && ((1<<uint((_la-95)))&((1<<(SyslParserE_PLUS-95))|(1<<(SyslParserE_MINUS-95))|(1<<(SyslParserE_TILDE-95))|(1<<(SyslParserE_NOT-95)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	{
		p.SetState(1309)
		p.Power()
	}

	return localctx
}

// ITermTContext is an interface to support dynamic dispatch.
type ITermTContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTermTContext differentiates from other interfaces.
	IsTermTContext()
}

type TermTContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermTContext() *TermTContext {
	var p = new(TermTContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_termT
	return p
}

func (*TermTContext) IsTermTContext() {}

func NewTermTContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermTContext {
	var p = new(TermTContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_termT

	return p
}

func (s *TermTContext) GetParser() antlr.Parser { return s.parser }

func (s *TermTContext) UnaryTerm() IUnaryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryTermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryTermContext)
}

func (s *TermTContext) E_STAR() antlr.TerminalNode {
	return s.GetToken(SyslParserE_STAR, 0)
}

func (s *TermTContext) E_DIVIDE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DIVIDE, 0)
}

func (s *TermTContext) E_MOD() antlr.TerminalNode {
	return s.GetToken(SyslParserE_MOD, 0)
}

func (s *TermTContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermTContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermTContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTermT(s)
	}
}

func (s *TermTContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTermT(s)
	}
}

func (p *SyslParser) TermT() (localctx ITermTContext) {
	localctx = NewTermTContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, SyslParserRULE_termT)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1311)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(SyslParserE_DIVIDE-96))|(1<<(SyslParserE_MOD-96))|(1<<(SyslParserE_STAR-96)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(1312)
		p.UnaryTerm()
	}

	return localctx
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_term
	return p
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) UnaryTerm() IUnaryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryTermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryTermContext)
}

func (s *TermContext) AllTermT() []ITermTContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermTContext)(nil)).Elem())
	var tst = make([]ITermTContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermTContext)
		}
	}

	return tst
}

func (s *TermContext) TermT(i int) ITermTContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermTContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermTContext)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTerm(s)
	}
}

func (p *SyslParser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, SyslParserRULE_term)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1314)
		p.UnaryTerm()
	}
	p.SetState(1318)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1315)
				p.TermT()
			}

		}
		p.SetState(1320)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext())
	}

	return localctx
}

// IBinexprTContext is an interface to support dynamic dispatch.
type IBinexprTContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinexprTContext differentiates from other interfaces.
	IsBinexprTContext()
}

type BinexprTContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinexprTContext() *BinexprTContext {
	var p = new(BinexprTContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_binexprT
	return p
}

func (*BinexprTContext) IsBinexprTContext() {}

func NewBinexprTContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinexprTContext {
	var p = new(BinexprTContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_binexprT

	return p
}

func (s *BinexprTContext) GetParser() antlr.Parser { return s.parser }

func (s *BinexprTContext) Term() ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *BinexprTContext) E_PLUS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_PLUS, 0)
}

func (s *BinexprTContext) E_MINUS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_MINUS, 0)
}

func (s *BinexprTContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinexprTContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinexprTContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterBinexprT(s)
	}
}

func (s *BinexprTContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitBinexprT(s)
	}
}

func (p *SyslParser) BinexprT() (localctx IBinexprTContext) {
	localctx = NewBinexprTContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, SyslParserRULE_binexprT)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1321)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserE_PLUS || _la == SyslParserE_MINUS) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(1322)
		p.Term()
	}

	return localctx
}

// IBinexprContext is an interface to support dynamic dispatch.
type IBinexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinexprContext differentiates from other interfaces.
	IsBinexprContext()
}

type BinexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinexprContext() *BinexprContext {
	var p = new(BinexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_binexpr
	return p
}

func (*BinexprContext) IsBinexprContext() {}

func NewBinexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinexprContext {
	var p = new(BinexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_binexpr

	return p
}

func (s *BinexprContext) GetParser() antlr.Parser { return s.parser }

func (s *BinexprContext) Term() ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *BinexprContext) AllBinexprT() []IBinexprTContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBinexprTContext)(nil)).Elem())
	var tst = make([]IBinexprTContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBinexprTContext)
		}
	}

	return tst
}

func (s *BinexprContext) BinexprT(i int) IBinexprTContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinexprTContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBinexprTContext)
}

func (s *BinexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterBinexpr(s)
	}
}

func (s *BinexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitBinexpr(s)
	}
}

func (p *SyslParser) Binexpr() (localctx IBinexprContext) {
	localctx = NewBinexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, SyslParserRULE_binexpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1324)
		p.Term()
	}
	p.SetState(1328)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1325)
				p.BinexprT()
			}

		}
		p.SetState(1330)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext())
	}

	return localctx
}

// IE_compare_opsContext is an interface to support dynamic dispatch.
type IE_compare_opsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsE_compare_opsContext differentiates from other interfaces.
	IsE_compare_opsContext()
}

type E_compare_opsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyE_compare_opsContext() *E_compare_opsContext {
	var p = new(E_compare_opsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_e_compare_ops
	return p
}

func (*E_compare_opsContext) IsE_compare_opsContext() {}

func NewE_compare_opsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *E_compare_opsContext {
	var p = new(E_compare_opsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_e_compare_ops

	return p
}

func (s *E_compare_opsContext) GetParser() antlr.Parser { return s.parser }

func (s *E_compare_opsContext) E_REL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_REL, 0)
}

func (s *E_compare_opsContext) E_ANGLE_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_OPEN, 0)
}

func (s *E_compare_opsContext) E_ANGLE_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_CLOSE, 0)
}

func (s *E_compare_opsContext) E_DOUBLE_EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOUBLE_EQ, 0)
}

func (s *E_compare_opsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *E_compare_opsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *E_compare_opsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterE_compare_ops(s)
	}
}

func (s *E_compare_opsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitE_compare_ops(s)
	}
}

func (p *SyslParser) E_compare_ops() (localctx IE_compare_opsContext) {
	localctx = NewE_compare_opsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, SyslParserRULE_e_compare_ops)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1331)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-77)&-(0x1f+1)) == 0 && ((1<<uint((_la-77)))&((1<<(SyslParserE_DOUBLE_EQ-77))|(1<<(SyslParserE_REL-77))|(1<<(SyslParserE_ANGLE_OPEN-77))|(1<<(SyslParserE_ANGLE_CLOSE-77)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IExpr_relContext is an interface to support dynamic dispatch.
type IExpr_relContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_relContext differentiates from other interfaces.
	IsExpr_relContext()
}

type Expr_relContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_relContext() *Expr_relContext {
	var p = new(Expr_relContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_rel
	return p
}

func (*Expr_relContext) IsExpr_relContext() {}

func NewExpr_relContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_relContext {
	var p = new(Expr_relContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_rel

	return p
}

func (s *Expr_relContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_relContext) AllBinexpr() []IBinexprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBinexprContext)(nil)).Elem())
	var tst = make([]IBinexprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBinexprContext)
		}
	}

	return tst
}

func (s *Expr_relContext) Binexpr(i int) IBinexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinexprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBinexprContext)
}

func (s *Expr_relContext) AllE_compare_ops() []IE_compare_opsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IE_compare_opsContext)(nil)).Elem())
	var tst = make([]IE_compare_opsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IE_compare_opsContext)
		}
	}

	return tst
}

func (s *Expr_relContext) E_compare_ops(i int) IE_compare_opsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_compare_opsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IE_compare_opsContext)
}

func (s *Expr_relContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_relContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_relContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_rel(s)
	}
}

func (s *Expr_relContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_rel(s)
	}
}

func (p *SyslParser) Expr_rel() (localctx IExpr_relContext) {
	localctx = NewExpr_relContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, SyslParserRULE_expr_rel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1333)
		p.Binexpr()
	}
	p.SetState(1339)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1334)
				p.E_compare_ops()
			}
			{
				p.SetState(1335)
				p.Binexpr()
			}

		}
		p.SetState(1341)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_bitandContext is an interface to support dynamic dispatch.
type IExpr_bitandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_bitandContext differentiates from other interfaces.
	IsExpr_bitandContext()
}

type Expr_bitandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_bitandContext() *Expr_bitandContext {
	var p = new(Expr_bitandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_bitand
	return p
}

func (*Expr_bitandContext) IsExpr_bitandContext() {}

func NewExpr_bitandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_bitandContext {
	var p = new(Expr_bitandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_bitand

	return p
}

func (s *Expr_bitandContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_bitandContext) AllExpr_rel() []IExpr_relContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_relContext)(nil)).Elem())
	var tst = make([]IExpr_relContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_relContext)
		}
	}

	return tst
}

func (s *Expr_bitandContext) Expr_rel(i int) IExpr_relContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_relContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_relContext)
}

func (s *Expr_bitandContext) AllE_AMP() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_AMP)
}

func (s *Expr_bitandContext) E_AMP(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_AMP, i)
}

func (s *Expr_bitandContext) AllE_AND() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_AND)
}

func (s *Expr_bitandContext) E_AND(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_AND, i)
}

func (s *Expr_bitandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_bitandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_bitandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_bitand(s)
	}
}

func (s *Expr_bitandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_bitand(s)
	}
}

func (p *SyslParser) Expr_bitand() (localctx IExpr_bitandContext) {
	localctx = NewExpr_bitandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, SyslParserRULE_expr_bitand)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1342)
		p.Expr_rel()
	}
	p.SetState(1347)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1343)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SyslParserE_AMP || _la == SyslParserE_AND) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
			{
				p.SetState(1344)
				p.Expr_rel()
			}

		}
		p.SetState(1349)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_bitxorContext is an interface to support dynamic dispatch.
type IExpr_bitxorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_bitxorContext differentiates from other interfaces.
	IsExpr_bitxorContext()
}

type Expr_bitxorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_bitxorContext() *Expr_bitxorContext {
	var p = new(Expr_bitxorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_bitxor
	return p
}

func (*Expr_bitxorContext) IsExpr_bitxorContext() {}

func NewExpr_bitxorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_bitxorContext {
	var p = new(Expr_bitxorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_bitxor

	return p
}

func (s *Expr_bitxorContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_bitxorContext) AllExpr_bitand() []IExpr_bitandContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_bitandContext)(nil)).Elem())
	var tst = make([]IExpr_bitandContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_bitandContext)
		}
	}

	return tst
}

func (s *Expr_bitxorContext) Expr_bitand(i int) IExpr_bitandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_bitandContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_bitandContext)
}

func (s *Expr_bitxorContext) AllE_XOR() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_XOR)
}

func (s *Expr_bitxorContext) E_XOR(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_XOR, i)
}

func (s *Expr_bitxorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_bitxorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_bitxorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_bitxor(s)
	}
}

func (s *Expr_bitxorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_bitxor(s)
	}
}

func (p *SyslParser) Expr_bitxor() (localctx IExpr_bitxorContext) {
	localctx = NewExpr_bitxorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, SyslParserRULE_expr_bitxor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1350)
		p.Expr_bitand()
	}
	p.SetState(1355)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1351)
				p.Match(SyslParserE_XOR)
			}
			{
				p.SetState(1352)
				p.Expr_bitand()
			}

		}
		p.SetState(1357)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_bitorContext is an interface to support dynamic dispatch.
type IExpr_bitorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_bitorContext differentiates from other interfaces.
	IsExpr_bitorContext()
}

type Expr_bitorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_bitorContext() *Expr_bitorContext {
	var p = new(Expr_bitorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_bitor
	return p
}

func (*Expr_bitorContext) IsExpr_bitorContext() {}

func NewExpr_bitorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_bitorContext {
	var p = new(Expr_bitorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_bitor

	return p
}

func (s *Expr_bitorContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_bitorContext) AllExpr_bitxor() []IExpr_bitxorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_bitxorContext)(nil)).Elem())
	var tst = make([]IExpr_bitxorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_bitxorContext)
		}
	}

	return tst
}

func (s *Expr_bitorContext) Expr_bitxor(i int) IExpr_bitxorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_bitxorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_bitxorContext)
}

func (s *Expr_bitorContext) AllE_BITOR() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_BITOR)
}

func (s *Expr_bitorContext) E_BITOR(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_BITOR, i)
}

func (s *Expr_bitorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_bitorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_bitorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_bitor(s)
	}
}

func (s *Expr_bitorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_bitor(s)
	}
}

func (p *SyslParser) Expr_bitor() (localctx IExpr_bitorContext) {
	localctx = NewExpr_bitorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, SyslParserRULE_expr_bitor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1358)
		p.Expr_bitxor()
	}
	p.SetState(1363)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1359)
				p.Match(SyslParserE_BITOR)
			}
			{
				p.SetState(1360)
				p.Expr_bitxor()
			}

		}
		p.SetState(1365)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_andContext is an interface to support dynamic dispatch.
type IExpr_andContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_andContext differentiates from other interfaces.
	IsExpr_andContext()
}

type Expr_andContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_andContext() *Expr_andContext {
	var p = new(Expr_andContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_and
	return p
}

func (*Expr_andContext) IsExpr_andContext() {}

func NewExpr_andContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_andContext {
	var p = new(Expr_andContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_and

	return p
}

func (s *Expr_andContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_andContext) AllExpr_bitor() []IExpr_bitorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_bitorContext)(nil)).Elem())
	var tst = make([]IExpr_bitorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_bitorContext)
		}
	}

	return tst
}

func (s *Expr_andContext) Expr_bitor(i int) IExpr_bitorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_bitorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_bitorContext)
}

func (s *Expr_andContext) AllE_DOUBLE_AMP() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_DOUBLE_AMP)
}

func (s *Expr_andContext) E_DOUBLE_AMP(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOUBLE_AMP, i)
}

func (s *Expr_andContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_andContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_andContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_and(s)
	}
}

func (s *Expr_andContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_and(s)
	}
}

func (p *SyslParser) Expr_and() (localctx IExpr_andContext) {
	localctx = NewExpr_andContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, SyslParserRULE_expr_and)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1366)
		p.Expr_bitor()
	}
	p.SetState(1371)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1367)
				p.Match(SyslParserE_DOUBLE_AMP)
			}
			{
				p.SetState(1368)
				p.Expr_bitor()
			}

		}
		p.SetState(1373)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_orContext is an interface to support dynamic dispatch.
type IExpr_orContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_orContext differentiates from other interfaces.
	IsExpr_orContext()
}

type Expr_orContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_orContext() *Expr_orContext {
	var p = new(Expr_orContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_or
	return p
}

func (*Expr_orContext) IsExpr_orContext() {}

func NewExpr_orContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_orContext {
	var p = new(Expr_orContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_or

	return p
}

func (s *Expr_orContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_orContext) AllExpr_and() []IExpr_andContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_andContext)(nil)).Elem())
	var tst = make([]IExpr_andContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_andContext)
		}
	}

	return tst
}

func (s *Expr_orContext) Expr_and(i int) IExpr_andContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_andContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_andContext)
}

func (s *Expr_orContext) AllE_LOGIC_OR() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_LOGIC_OR)
}

func (s *Expr_orContext) E_LOGIC_OR(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_LOGIC_OR, i)
}

func (s *Expr_orContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_orContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_orContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_or(s)
	}
}

func (s *Expr_orContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_or(s)
	}
}

func (p *SyslParser) Expr_or() (localctx IExpr_orContext) {
	localctx = NewExpr_orContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, SyslParserRULE_expr_or)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1374)
		p.Expr_and()
	}
	p.SetState(1379)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1375)
				p.Match(SyslParserE_LOGIC_OR)
			}
			{
				p.SetState(1376)
				p.Expr_and()
			}

		}
		p.SetState(1381)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_but_notContext is an interface to support dynamic dispatch.
type IExpr_but_notContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_but_notContext differentiates from other interfaces.
	IsExpr_but_notContext()
}

type Expr_but_notContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_but_notContext() *Expr_but_notContext {
	var p = new(Expr_but_notContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_but_not
	return p
}

func (*Expr_but_notContext) IsExpr_but_notContext() {}

func NewExpr_but_notContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_but_notContext {
	var p = new(Expr_but_notContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_but_not

	return p
}

func (s *Expr_but_notContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_but_notContext) AllExpr_or() []IExpr_orContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_orContext)(nil)).Elem())
	var tst = make([]IExpr_orContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_orContext)
		}
	}

	return tst
}

func (s *Expr_but_notContext) Expr_or(i int) IExpr_orContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_orContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_orContext)
}

func (s *Expr_but_notContext) AllE_BUTNOT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_BUTNOT)
}

func (s *Expr_but_notContext) E_BUTNOT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_BUTNOT, i)
}

func (s *Expr_but_notContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_but_notContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_but_notContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_but_not(s)
	}
}

func (s *Expr_but_notContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_but_not(s)
	}
}

func (p *SyslParser) Expr_but_not() (localctx IExpr_but_notContext) {
	localctx = NewExpr_but_notContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, SyslParserRULE_expr_but_not)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1382)
		p.Expr_or()
	}
	p.SetState(1387)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1383)
				p.Match(SyslParserE_BUTNOT)
			}
			{
				p.SetState(1384)
				p.Expr_or()
			}

		}
		p.SetState(1389)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_coalesceContext is an interface to support dynamic dispatch.
type IExpr_coalesceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_coalesceContext differentiates from other interfaces.
	IsExpr_coalesceContext()
}

type Expr_coalesceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_coalesceContext() *Expr_coalesceContext {
	var p = new(Expr_coalesceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_coalesce
	return p
}

func (*Expr_coalesceContext) IsExpr_coalesceContext() {}

func NewExpr_coalesceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_coalesceContext {
	var p = new(Expr_coalesceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_coalesce

	return p
}

func (s *Expr_coalesceContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_coalesceContext) AllExpr_but_not() []IExpr_but_notContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_but_notContext)(nil)).Elem())
	var tst = make([]IExpr_but_notContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_but_notContext)
		}
	}

	return tst
}

func (s *Expr_coalesceContext) Expr_but_not(i int) IExpr_but_notContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_but_notContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_but_notContext)
}

func (s *Expr_coalesceContext) AllE_COALESCE() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COALESCE)
}

func (s *Expr_coalesceContext) E_COALESCE(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COALESCE, i)
}

func (s *Expr_coalesceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_coalesceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_coalesceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_coalesce(s)
	}
}

func (s *Expr_coalesceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_coalesce(s)
	}
}

func (p *SyslParser) Expr_coalesce() (localctx IExpr_coalesceContext) {
	localctx = NewExpr_coalesceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, SyslParserRULE_expr_coalesce)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1390)
		p.Expr_but_not()
	}
	p.SetState(1395)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 144, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1391)
				p.Match(SyslParserE_COALESCE)
			}
			{
				p.SetState(1392)
				p.Expr_but_not()
			}

		}
		p.SetState(1397)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 144, p.GetParserRuleContext())
	}

	return localctx
}

// IIf_one_linerContext is an interface to support dynamic dispatch.
type IIf_one_linerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_one_linerContext differentiates from other interfaces.
	IsIf_one_linerContext()
}

type If_one_linerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_one_linerContext() *If_one_linerContext {
	var p = new(If_one_linerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_one_liner
	return p
}

func (*If_one_linerContext) IsIf_one_linerContext() {}

func NewIf_one_linerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_one_linerContext {
	var p = new(If_one_linerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_one_liner

	return p
}

func (s *If_one_linerContext) GetParser() antlr.Parser { return s.parser }

func (s *If_one_linerContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *If_one_linerContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *If_one_linerContext) E_THEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_THEN, 0)
}

func (s *If_one_linerContext) E_ELSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ELSE, 0)
}

func (s *If_one_linerContext) E_QN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_QN, 0)
}

func (s *If_one_linerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_one_linerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_one_linerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_one_liner(s)
	}
}

func (s *If_one_linerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_one_liner(s)
	}
}

func (p *SyslParser) If_one_liner() (localctx IIf_one_linerContext) {
	localctx = NewIf_one_linerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, SyslParserRULE_if_one_liner)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1398)
		p.Expr()
	}
	p.SetState(1400)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_QN {
		{
			p.SetState(1399)
			p.Match(SyslParserE_QN)
		}

	}
	{
		p.SetState(1402)
		p.Match(SyslParserE_THEN)
	}
	{
		p.SetState(1403)
		p.Expr()
	}
	{
		p.SetState(1404)
		p.Match(SyslParserE_ELSE)
	}
	{
		p.SetState(1405)
		p.Expr()
	}

	return localctx
}

// IElse_block_stmtContext is an interface to support dynamic dispatch.
type IElse_block_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsElse_block_stmtContext differentiates from other interfaces.
	IsElse_block_stmtContext()
}

type Else_block_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	nested bool
	_expr  IExprContext
}

func NewEmptyElse_block_stmtContext() *Else_block_stmtContext {
	var p = new(Else_block_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_else_block_stmt
	return p
}

func (*Else_block_stmtContext) IsElse_block_stmtContext() {}

func NewElse_block_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Else_block_stmtContext {
	var p = new(Else_block_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_else_block_stmt

	return p
}

func (s *Else_block_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Else_block_stmtContext) Get_expr() IExprContext { return s._expr }

func (s *Else_block_stmtContext) Set_expr(v IExprContext) { s._expr = v }

func (s *Else_block_stmtContext) GetNested() bool { return s.nested }

func (s *Else_block_stmtContext) SetNested(v bool) { s.nested = v }

func (s *Else_block_stmtContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Else_block_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Else_block_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Else_block_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterElse_block_stmt(s)
	}
}

func (s *Else_block_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitElse_block_stmt(s)
	}
}

func (p *SyslParser) Else_block_stmt() (localctx IElse_block_stmtContext) {
	localctx = NewElse_block_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, SyslParserRULE_else_block_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1407)

		var _x = p.Expr()

		localctx.(*Else_block_stmtContext)._expr = _x
	}
	localctx.(*Else_block_stmtContext).SetNested(localctx.(*Else_block_stmtContext).Get_expr().GetNested())

	return localctx
}

// IControl_itemContext is an interface to support dynamic dispatch.
type IControl_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsControl_itemContext differentiates from other interfaces.
	IsControl_itemContext()
}

type Control_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyControl_itemContext() *Control_itemContext {
	var p = new(Control_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_control_item
	return p
}

func (*Control_itemContext) IsControl_itemContext() {}

func NewControl_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Control_itemContext {
	var p = new(Control_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_control_item

	return p
}

func (s *Control_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Control_itemContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Control_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Control_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Control_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterControl_item(s)
	}
}

func (s *Control_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitControl_item(s)
	}
}

func (p *SyslParser) Control_item() (localctx IControl_itemContext) {
	localctx = NewControl_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, SyslParserRULE_control_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1410)
		p.Expr()
	}

	return localctx
}

// IIf_controlsContext is an interface to support dynamic dispatch.
type IIf_controlsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_controlsContext differentiates from other interfaces.
	IsIf_controlsContext()
}

type If_controlsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_controlsContext() *If_controlsContext {
	var p = new(If_controlsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_controls
	return p
}

func (*If_controlsContext) IsIf_controlsContext() {}

func NewIf_controlsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_controlsContext {
	var p = new(If_controlsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_controls

	return p
}

func (s *If_controlsContext) GetParser() antlr.Parser { return s.parser }

func (s *If_controlsContext) AllControl_item() []IControl_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IControl_itemContext)(nil)).Elem())
	var tst = make([]IControl_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IControl_itemContext)
		}
	}

	return tst
}

func (s *If_controlsContext) Control_item(i int) IControl_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IControl_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IControl_itemContext)
}

func (s *If_controlsContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *If_controlsContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *If_controlsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_controlsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_controlsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_controls(s)
	}
}

func (s *If_controlsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_controls(s)
	}
}

func (p *SyslParser) If_controls() (localctx IIf_controlsContext) {
	localctx = NewIf_controlsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, SyslParserRULE_if_controls)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1412)
		p.Control_item()
	}
	p.SetState(1417)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1413)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1414)
			p.Control_item()
		}

		p.SetState(1419)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICond_blockContext is an interface to support dynamic dispatch.
type ICond_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_else_block_stmt returns the _else_block_stmt rule contexts.
	Get_else_block_stmt() IElse_block_stmtContext

	// Set_else_block_stmt sets the _else_block_stmt rule contexts.
	Set_else_block_stmt(IElse_block_stmtContext)

	// IsCond_blockContext differentiates from other interfaces.
	IsCond_blockContext()
}

type Cond_blockContext struct {
	*antlr.BaseParserRuleContext
	parser           antlr.Parser
	_else_block_stmt IElse_block_stmtContext
}

func NewEmptyCond_blockContext() *Cond_blockContext {
	var p = new(Cond_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_cond_block
	return p
}

func (*Cond_blockContext) IsCond_blockContext() {}

func NewCond_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cond_blockContext {
	var p = new(Cond_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_cond_block

	return p
}

func (s *Cond_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Cond_blockContext) Get_else_block_stmt() IElse_block_stmtContext { return s._else_block_stmt }

func (s *Cond_blockContext) Set_else_block_stmt(v IElse_block_stmtContext) { s._else_block_stmt = v }

func (s *Cond_blockContext) If_controls() IIf_controlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_controlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_controlsContext)
}

func (s *Cond_blockContext) E_EQ_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_EQ_RIGHT, 0)
}

func (s *Cond_blockContext) Else_block_stmt() IElse_block_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElse_block_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElse_block_stmtContext)
}

func (s *Cond_blockContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *Cond_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cond_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cond_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCond_block(s)
	}
}

func (s *Cond_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCond_block(s)
	}
}

func (p *SyslParser) Cond_block() (localctx ICond_blockContext) {
	localctx = NewCond_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, SyslParserRULE_cond_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1420)
		p.If_controls()
	}
	{
		p.SetState(1421)
		p.Match(SyslParserE_EQ_RIGHT)
	}
	{
		p.SetState(1422)

		var _x = p.Else_block_stmt()

		localctx.(*Cond_blockContext)._else_block_stmt = _x
	}
	p.SetState(1425)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 147, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1423)

		if !(localctx.(*Cond_blockContext).Get_else_block_stmt().GetNested() == true) {
			panic(antlr.NewFailedPredicateException(p, "$else_block_stmt.nested == true", ""))
		}

	case 2:
		{
			p.SetState(1424)
			p.Match(SyslParserE_NL)
		}

	}

	return localctx
}

// IFinal_elseContext is an interface to support dynamic dispatch.
type IFinal_elseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// IsFinal_elseContext differentiates from other interfaces.
	IsFinal_elseContext()
}

type Final_elseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	_expr  IExprContext
}

func NewEmptyFinal_elseContext() *Final_elseContext {
	var p = new(Final_elseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_final_else
	return p
}

func (*Final_elseContext) IsFinal_elseContext() {}

func NewFinal_elseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Final_elseContext {
	var p = new(Final_elseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_final_else

	return p
}

func (s *Final_elseContext) GetParser() antlr.Parser { return s.parser }

func (s *Final_elseContext) Get_expr() IExprContext { return s._expr }

func (s *Final_elseContext) Set_expr(v IExprContext) { s._expr = v }

func (s *Final_elseContext) E_ELSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ELSE, 0)
}

func (s *Final_elseContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Final_elseContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *Final_elseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Final_elseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Final_elseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFinal_else(s)
	}
}

func (s *Final_elseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFinal_else(s)
	}
}

func (p *SyslParser) Final_else() (localctx IFinal_elseContext) {
	localctx = NewFinal_elseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, SyslParserRULE_final_else)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1427)
		p.Match(SyslParserE_ELSE)
	}
	{
		p.SetState(1428)

		var _x = p.Expr()

		localctx.(*Final_elseContext)._expr = _x
	}
	p.SetState(1431)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 148, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1429)

		if !(localctx.(*Final_elseContext).Get_expr().GetNested() == true) {
			panic(antlr.NewFailedPredicateException(p, "$expr.nested == true", ""))
		}

	case 2:
		{
			p.SetState(1430)
			p.Match(SyslParserE_NL)
		}

	}

	return localctx
}

// IIfvarContext is an interface to support dynamic dispatch.
type IIfvarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfvarContext differentiates from other interfaces.
	IsIfvarContext()
}

type IfvarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfvarContext() *IfvarContext {
	var p = new(IfvarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_ifvar
	return p
}

func (*IfvarContext) IsIfvarContext() {}

func NewIfvarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfvarContext {
	var p = new(IfvarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_ifvar

	return p
}

func (s *IfvarContext) GetParser() antlr.Parser { return s.parser }

func (s *IfvarContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *IfvarContext) E_DOUBLE_EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOUBLE_EQ, 0)
}

func (s *IfvarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfvarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfvarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIfvar(s)
	}
}

func (s *IfvarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIfvar(s)
	}
}

func (p *SyslParser) Ifvar() (localctx IIfvarContext) {
	localctx = NewIfvarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, SyslParserRULE_ifvar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1433)
		p.Expr()
	}
	{
		p.SetState(1434)
		p.Match(SyslParserE_DOUBLE_EQ)
	}

	return localctx
}

// IIf_multiple_linesContext is an interface to support dynamic dispatch.
type IIf_multiple_linesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_multiple_linesContext differentiates from other interfaces.
	IsIf_multiple_linesContext()
}

type If_multiple_linesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_multiple_linesContext() *If_multiple_linesContext {
	var p = new(If_multiple_linesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_multiple_lines
	return p
}

func (*If_multiple_linesContext) IsIf_multiple_linesContext() {}

func NewIf_multiple_linesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_multiple_linesContext {
	var p = new(If_multiple_linesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_multiple_lines

	return p
}

func (s *If_multiple_linesContext) GetParser() antlr.Parser { return s.parser }

func (s *If_multiple_linesContext) E_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserE_COLON, 0)
}

func (s *If_multiple_linesContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *If_multiple_linesContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *If_multiple_linesContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *If_multiple_linesContext) Ifvar() IIfvarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfvarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfvarContext)
}

func (s *If_multiple_linesContext) AllCond_block() []ICond_blockContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICond_blockContext)(nil)).Elem())
	var tst = make([]ICond_blockContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICond_blockContext)
		}
	}

	return tst
}

func (s *If_multiple_linesContext) Cond_block(i int) ICond_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICond_blockContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICond_blockContext)
}

func (s *If_multiple_linesContext) Final_else() IFinal_elseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinal_elseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinal_elseContext)
}

func (s *If_multiple_linesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_multiple_linesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_multiple_linesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_multiple_lines(s)
	}
}

func (s *If_multiple_linesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_multiple_lines(s)
	}
}

func (p *SyslParser) If_multiple_lines() (localctx IIf_multiple_linesContext) {
	localctx = NewIf_multiple_linesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, SyslParserRULE_if_multiple_lines)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1437)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserNativeDataTypes || (((_la-74)&-(0x1f+1)) == 0 && ((1<<uint((_la-74)))&((1<<(SyslParserE_WHATEVER-74))|(1<<(SyslParserE_ARROW_RIGHT-74))|(1<<(SyslParserE_SQ_OPEN-74))|(1<<(SyslParserE_EMPTY_TUPLE-74))|(1<<(SyslParserE_CURLY_OPEN-74))|(1<<(SyslParserE_NULLSAFE_DOT-74))|(1<<(SyslParserE_OPEN_PAREN-74))|(1<<(SyslParserE_PLUS-74))|(1<<(SyslParserE_MINUS-74))|(1<<(SyslParserE_QN-74))|(1<<(SyslParserE_TILDE-74))|(1<<(SyslParserE_NOT-74)))) != 0) || (((_la-112)&-(0x1f+1)) == 0 && ((1<<uint((_la-112)))&((1<<(SyslParserE_IF-112))|(1<<(SyslParserE_TRUE-112))|(1<<(SyslParserE_FALSE-112))|(1<<(SyslParserE_NULL-112))|(1<<(SyslParserE_FUNC-112))|(1<<(SyslParserE_STRING_DBL-112))|(1<<(SyslParserE_STRING_SINGLE-112))|(1<<(SyslParserE_DECIMAL-112))|(1<<(SyslParserE_DIGITS-112))|(1<<(SyslParserE_Name-112))|(1<<(SyslParserE_DOT-112)))) != 0) {
		{
			p.SetState(1436)
			p.Ifvar()
		}

	}
	{
		p.SetState(1439)
		p.Match(SyslParserE_COLON)
	}
	{
		p.SetState(1440)
		p.Match(SyslParserE_NL)
	}
	{
		p.SetState(1441)
		p.Match(SyslParserINDENT)
	}
	p.SetState(1443)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserNativeDataTypes || (((_la-74)&-(0x1f+1)) == 0 && ((1<<uint((_la-74)))&((1<<(SyslParserE_WHATEVER-74))|(1<<(SyslParserE_ARROW_RIGHT-74))|(1<<(SyslParserE_SQ_OPEN-74))|(1<<(SyslParserE_EMPTY_TUPLE-74))|(1<<(SyslParserE_CURLY_OPEN-74))|(1<<(SyslParserE_NULLSAFE_DOT-74))|(1<<(SyslParserE_OPEN_PAREN-74))|(1<<(SyslParserE_PLUS-74))|(1<<(SyslParserE_MINUS-74))|(1<<(SyslParserE_QN-74))|(1<<(SyslParserE_TILDE-74))|(1<<(SyslParserE_NOT-74)))) != 0) || (((_la-112)&-(0x1f+1)) == 0 && ((1<<uint((_la-112)))&((1<<(SyslParserE_IF-112))|(1<<(SyslParserE_TRUE-112))|(1<<(SyslParserE_FALSE-112))|(1<<(SyslParserE_NULL-112))|(1<<(SyslParserE_FUNC-112))|(1<<(SyslParserE_STRING_DBL-112))|(1<<(SyslParserE_STRING_SINGLE-112))|(1<<(SyslParserE_DECIMAL-112))|(1<<(SyslParserE_DIGITS-112))|(1<<(SyslParserE_Name-112))|(1<<(SyslParserE_DOT-112)))) != 0) {
		{
			p.SetState(1442)
			p.Cond_block()
		}

		p.SetState(1445)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1448)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_ELSE {
		{
			p.SetState(1447)
			p.Final_else()
		}

	}
	{
		p.SetState(1450)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IExpr_if_elseContext is an interface to support dynamic dispatch.
type IExpr_if_elseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_if_elseContext differentiates from other interfaces.
	IsExpr_if_elseContext()
}

type Expr_if_elseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	nested bool
}

func NewEmptyExpr_if_elseContext() *Expr_if_elseContext {
	var p = new(Expr_if_elseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_if_else
	return p
}

func (*Expr_if_elseContext) IsExpr_if_elseContext() {}

func NewExpr_if_elseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_if_elseContext {
	var p = new(Expr_if_elseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_if_else

	return p
}

func (s *Expr_if_elseContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_if_elseContext) GetNested() bool { return s.nested }

func (s *Expr_if_elseContext) SetNested(v bool) { s.nested = v }

func (s *Expr_if_elseContext) E_IF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_IF, 0)
}

func (s *Expr_if_elseContext) If_one_liner() IIf_one_linerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_one_linerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_one_linerContext)
}

func (s *Expr_if_elseContext) If_multiple_lines() IIf_multiple_linesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_multiple_linesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_multiple_linesContext)
}

func (s *Expr_if_elseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_if_elseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_if_elseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_if_else(s)
	}
}

func (s *Expr_if_elseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_if_else(s)
	}
}

func (p *SyslParser) Expr_if_else() (localctx IExpr_if_elseContext) {
	localctx = NewExpr_if_elseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, SyslParserRULE_expr_if_else)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1452)
		p.Match(SyslParserE_IF)
	}
	p.SetState(1457)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1453)
			p.If_one_liner()
		}

	case 2:
		{
			p.SetState(1454)
			p.If_multiple_lines()
		}
		localctx.(*Expr_if_elseContext).SetNested(true)

	}

	return localctx
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_if_else returns the _expr_if_else rule contexts.
	Get_expr_if_else() IExpr_if_elseContext

	// Set_expr_if_else sets the _expr_if_else rule contexts.
	Set_expr_if_else(IExpr_if_elseContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	*antlr.BaseParserRuleContext
	parser        antlr.Parser
	nested        bool
	_expr_if_else IExpr_if_elseContext
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr
	return p
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) Get_expr_if_else() IExpr_if_elseContext { return s._expr_if_else }

func (s *ExprContext) Set_expr_if_else(v IExpr_if_elseContext) { s._expr_if_else = v }

func (s *ExprContext) GetNested() bool { return s.nested }

func (s *ExprContext) SetNested(v bool) { s.nested = v }

func (s *ExprContext) Expr_if_else() IExpr_if_elseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_if_elseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_if_elseContext)
}

func (s *ExprContext) Expr_coalesce() IExpr_coalesceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_coalesceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_coalesceContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (p *SyslParser) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, SyslParserRULE_expr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1463)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_IF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1459)

			var _x = p.Expr_if_else()

			localctx.(*ExprContext)._expr_if_else = _x
		}
		localctx.(*ExprContext).SetNested(localctx.(*ExprContext).Get_expr_if_else().GetNested())

	case SyslParserNativeDataTypes, SyslParserE_WHATEVER, SyslParserE_ARROW_RIGHT, SyslParserE_SQ_OPEN, SyslParserE_EMPTY_TUPLE, SyslParserE_CURLY_OPEN, SyslParserE_NULLSAFE_DOT, SyslParserE_OPEN_PAREN, SyslParserE_PLUS, SyslParserE_MINUS, SyslParserE_QN, SyslParserE_TILDE, SyslParserE_NOT, SyslParserE_TRUE, SyslParserE_FALSE, SyslParserE_NULL, SyslParserE_FUNC, SyslParserE_STRING_DBL, SyslParserE_STRING_SINGLE, SyslParserE_DECIMAL, SyslParserE_DIGITS, SyslParserE_Name, SyslParserE_DOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1462)
			p.Expr_coalesce()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExpr_assignContext is an interface to support dynamic dispatch.
type IExpr_assignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_assignContext differentiates from other interfaces.
	IsExpr_assignContext()
}

type Expr_assignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	nested bool
	_expr  IExprContext
}

func NewEmptyExpr_assignContext() *Expr_assignContext {
	var p = new(Expr_assignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_assign
	return p
}

func (*Expr_assignContext) IsExpr_assignContext() {}

func NewExpr_assignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_assignContext {
	var p = new(Expr_assignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_assign

	return p
}

func (s *Expr_assignContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_assignContext) Get_expr() IExprContext { return s._expr }

func (s *Expr_assignContext) Set_expr(v IExprContext) { s._expr = v }

func (s *Expr_assignContext) GetNested() bool { return s.nested }

func (s *Expr_assignContext) SetNested(v bool) { s.nested = v }

func (s *Expr_assignContext) E_EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserE_EQ, 0)
}

func (s *Expr_assignContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_assignContext) Transform() ITransformContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransformContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransformContext)
}

func (s *Expr_assignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_assignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_assignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_assign(s)
	}
}

func (s *Expr_assignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_assign(s)
	}
}

func (p *SyslParser) Expr_assign() (localctx IExpr_assignContext) {
	localctx = NewExpr_assignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, SyslParserRULE_expr_assign)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1465)
		p.Match(SyslParserE_EQ)
	}
	p.SetState(1472)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1466)

			var _x = p.Expr()

			localctx.(*Expr_assignContext)._expr = _x
		}
		localctx.(*Expr_assignContext).SetNested(localctx.(*Expr_assignContext).Get_expr().GetNested())

	case 2:
		{
			p.SetState(1469)
			p.Transform()
		}
		localctx.(*Expr_assignContext).SetNested(true)

	}

	return localctx
}

// IExpr_simple_assignContext is an interface to support dynamic dispatch.
type IExpr_simple_assignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_assign returns the _expr_assign rule contexts.
	Get_expr_assign() IExpr_assignContext

	// Set_expr_assign sets the _expr_assign rule contexts.
	Set_expr_assign(IExpr_assignContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_simple_assignContext differentiates from other interfaces.
	IsExpr_simple_assignContext()
}

type Expr_simple_assignContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	nested       bool
	_expr_assign IExpr_assignContext
}

func NewEmptyExpr_simple_assignContext() *Expr_simple_assignContext {
	var p = new(Expr_simple_assignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_simple_assign
	return p
}

func (*Expr_simple_assignContext) IsExpr_simple_assignContext() {}

func NewExpr_simple_assignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_simple_assignContext {
	var p = new(Expr_simple_assignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_simple_assign

	return p
}

func (s *Expr_simple_assignContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_simple_assignContext) Get_expr_assign() IExpr_assignContext { return s._expr_assign }

func (s *Expr_simple_assignContext) Set_expr_assign(v IExpr_assignContext) { s._expr_assign = v }

func (s *Expr_simple_assignContext) GetNested() bool { return s.nested }

func (s *Expr_simple_assignContext) SetNested(v bool) { s.nested = v }

func (s *Expr_simple_assignContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_simple_assignContext) Expr_assign() IExpr_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_assignContext)
}

func (s *Expr_simple_assignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_simple_assignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_simple_assignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_simple_assign(s)
	}
}

func (s *Expr_simple_assignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_simple_assign(s)
	}
}

func (p *SyslParser) Expr_simple_assign() (localctx IExpr_simple_assignContext) {
	localctx = NewExpr_simple_assignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, SyslParserRULE_expr_simple_assign)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1474)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1475)

		var _x = p.Expr_assign()

		localctx.(*Expr_simple_assignContext)._expr_assign = _x
	}
	localctx.(*Expr_simple_assignContext).SetNested(localctx.(*Expr_simple_assignContext).Get_expr_assign().GetNested())

	return localctx
}

// IExpr_let_statementContext is an interface to support dynamic dispatch.
type IExpr_let_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_assign returns the _expr_assign rule contexts.
	Get_expr_assign() IExpr_assignContext

	// Set_expr_assign sets the _expr_assign rule contexts.
	Set_expr_assign(IExpr_assignContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_let_statementContext differentiates from other interfaces.
	IsExpr_let_statementContext()
}

type Expr_let_statementContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	nested       bool
	_expr_assign IExpr_assignContext
}

func NewEmptyExpr_let_statementContext() *Expr_let_statementContext {
	var p = new(Expr_let_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_let_statement
	return p
}

func (*Expr_let_statementContext) IsExpr_let_statementContext() {}

func NewExpr_let_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_let_statementContext {
	var p = new(Expr_let_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_let_statement

	return p
}

func (s *Expr_let_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_let_statementContext) Get_expr_assign() IExpr_assignContext { return s._expr_assign }

func (s *Expr_let_statementContext) Set_expr_assign(v IExpr_assignContext) { s._expr_assign = v }

func (s *Expr_let_statementContext) GetNested() bool { return s.nested }

func (s *Expr_let_statementContext) SetNested(v bool) { s.nested = v }

func (s *Expr_let_statementContext) E_LET() antlr.TerminalNode {
	return s.GetToken(SyslParserE_LET, 0)
}

func (s *Expr_let_statementContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_let_statementContext) Expr_assign() IExpr_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_assignContext)
}

func (s *Expr_let_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_let_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_let_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_let_statement(s)
	}
}

func (s *Expr_let_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_let_statement(s)
	}
}

func (p *SyslParser) Expr_let_statement() (localctx IExpr_let_statementContext) {
	localctx = NewExpr_let_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, SyslParserRULE_expr_let_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1478)
		p.Match(SyslParserE_LET)
	}
	{
		p.SetState(1479)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1480)

		var _x = p.Expr_assign()

		localctx.(*Expr_let_statementContext)._expr_assign = _x
	}
	localctx.(*Expr_let_statementContext).SetNested(localctx.(*Expr_let_statementContext).Get_expr_assign().GetNested())

	return localctx
}

// IExpr_table_of_statementContext is an interface to support dynamic dispatch.
type IExpr_table_of_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_assign returns the _expr_assign rule contexts.
	Get_expr_assign() IExpr_assignContext

	// Set_expr_assign sets the _expr_assign rule contexts.
	Set_expr_assign(IExpr_assignContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_table_of_statementContext differentiates from other interfaces.
	IsExpr_table_of_statementContext()
}

type Expr_table_of_statementContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	nested       bool
	_expr_assign IExpr_assignContext
}

func NewEmptyExpr_table_of_statementContext() *Expr_table_of_statementContext {
	var p = new(Expr_table_of_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_table_of_statement
	return p
}

func (*Expr_table_of_statementContext) IsExpr_table_of_statementContext() {}

func NewExpr_table_of_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_table_of_statementContext {
	var p = new(Expr_table_of_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_table_of_statement

	return p
}

func (s *Expr_table_of_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_table_of_statementContext) Get_expr_assign() IExpr_assignContext { return s._expr_assign }

func (s *Expr_table_of_statementContext) Set_expr_assign(v IExpr_assignContext) { s._expr_assign = v }

func (s *Expr_table_of_statementContext) GetNested() bool { return s.nested }

func (s *Expr_table_of_statementContext) SetNested(v bool) { s.nested = v }

func (s *Expr_table_of_statementContext) E_TABLE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TABLE_OF, 0)
}

func (s *Expr_table_of_statementContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_table_of_statementContext) Expr_assign() IExpr_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_assignContext)
}

func (s *Expr_table_of_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_table_of_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_table_of_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_table_of_statement(s)
	}
}

func (s *Expr_table_of_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_table_of_statement(s)
	}
}

func (p *SyslParser) Expr_table_of_statement() (localctx IExpr_table_of_statementContext) {
	localctx = NewExpr_table_of_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, SyslParserRULE_expr_table_of_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1483)
		p.Match(SyslParserE_TABLE_OF)
	}
	{
		p.SetState(1484)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1485)

		var _x = p.Expr_assign()

		localctx.(*Expr_table_of_statementContext)._expr_assign = _x
	}
	localctx.(*Expr_table_of_statementContext).SetNested(localctx.(*Expr_table_of_statementContext).Get_expr_assign().GetNested())

	return localctx
}

// IExpr_dot_assignContext is an interface to support dynamic dispatch.
type IExpr_dot_assignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_dot_assignContext differentiates from other interfaces.
	IsExpr_dot_assignContext()
}

type Expr_dot_assignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_dot_assignContext() *Expr_dot_assignContext {
	var p = new(Expr_dot_assignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_dot_assign
	return p
}

func (*Expr_dot_assignContext) IsExpr_dot_assignContext() {}

func NewExpr_dot_assignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_dot_assignContext {
	var p = new(Expr_dot_assignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_dot_assign

	return p
}

func (s *Expr_dot_assignContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_dot_assignContext) E_DOT_NAME_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT_NAME_NL, 0)
}

func (s *Expr_dot_assignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_dot_assignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_dot_assignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_dot_assign(s)
	}
}

func (s *Expr_dot_assignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_dot_assign(s)
	}
}

func (p *SyslParser) Expr_dot_assign() (localctx IExpr_dot_assignContext) {
	localctx = NewExpr_dot_assignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, SyslParserRULE_expr_dot_assign)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1488)
		p.Match(SyslParserE_DOT_NAME_NL)
	}

	return localctx
}

// IExpr_statement_no_nlContext is an interface to support dynamic dispatch.
type IExpr_statement_no_nlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_statement_no_nlContext differentiates from other interfaces.
	IsExpr_statement_no_nlContext()
}

type Expr_statement_no_nlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_statement_no_nlContext() *Expr_statement_no_nlContext {
	var p = new(Expr_statement_no_nlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_statement_no_nl
	return p
}

func (*Expr_statement_no_nlContext) IsExpr_statement_no_nlContext() {}

func NewExpr_statement_no_nlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_statement_no_nlContext {
	var p = new(Expr_statement_no_nlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_statement_no_nl

	return p
}

func (s *Expr_statement_no_nlContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_statement_no_nlContext) Expr_dot_assign() IExpr_dot_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_dot_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_dot_assignContext)
}

func (s *Expr_statement_no_nlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_statement_no_nlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_statement_no_nlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_statement_no_nl(s)
	}
}

func (s *Expr_statement_no_nlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_statement_no_nl(s)
	}
}

func (p *SyslParser) Expr_statement_no_nl() (localctx IExpr_statement_no_nlContext) {
	localctx = NewExpr_statement_no_nlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, SyslParserRULE_expr_statement_no_nl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1490)
		p.Expr_dot_assign()
	}

	return localctx
}

// ITemplate_expressionContext is an interface to support dynamic dispatch.
type ITemplate_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTemplate_expressionContext differentiates from other interfaces.
	IsTemplate_expressionContext()
}

type Template_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplate_expressionContext() *Template_expressionContext {
	var p = new(Template_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_template_expression
	return p
}

func (*Template_expressionContext) IsTemplate_expressionContext() {}

func NewTemplate_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Template_expressionContext {
	var p = new(Template_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_template_expression

	return p
}

func (s *Template_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Template_expressionContext) TMPL_TEXT() antlr.TerminalNode {
	return s.GetToken(SyslParserTMPL_TEXT, 0)
}

func (s *Template_expressionContext) E_RAW_TEXT_END() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RAW_TEXT_END, 0)
}

func (s *Template_expressionContext) E_RAW_TEXT_START() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RAW_TEXT_START, 0)
}

func (s *Template_expressionContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *Template_expressionContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Template_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Template_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Template_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTemplate_expression(s)
	}
}

func (s *Template_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTemplate_expression(s)
	}
}

func (p *SyslParser) Template_expression() (localctx ITemplate_expressionContext) {
	localctx = NewTemplate_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, SyslParserRULE_template_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1501)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserTMPL_TEXT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1492)
			p.Match(SyslParserTMPL_TEXT)
		}

	case SyslParserE_RAW_TEXT_END:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1493)
			p.Match(SyslParserE_RAW_TEXT_END)
		}
		p.SetState(1497)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SyslParserNativeDataTypes || (((_la-74)&-(0x1f+1)) == 0 && ((1<<uint((_la-74)))&((1<<(SyslParserE_WHATEVER-74))|(1<<(SyslParserE_ARROW_RIGHT-74))|(1<<(SyslParserE_SQ_OPEN-74))|(1<<(SyslParserE_EMPTY_TUPLE-74))|(1<<(SyslParserE_CURLY_OPEN-74))|(1<<(SyslParserE_NULLSAFE_DOT-74))|(1<<(SyslParserE_OPEN_PAREN-74))|(1<<(SyslParserE_PLUS-74))|(1<<(SyslParserE_MINUS-74))|(1<<(SyslParserE_QN-74))|(1<<(SyslParserE_TILDE-74))|(1<<(SyslParserE_NOT-74)))) != 0) || (((_la-112)&-(0x1f+1)) == 0 && ((1<<uint((_la-112)))&((1<<(SyslParserE_IF-112))|(1<<(SyslParserE_TRUE-112))|(1<<(SyslParserE_FALSE-112))|(1<<(SyslParserE_NULL-112))|(1<<(SyslParserE_FUNC-112))|(1<<(SyslParserE_STRING_DBL-112))|(1<<(SyslParserE_STRING_SINGLE-112))|(1<<(SyslParserE_DECIMAL-112))|(1<<(SyslParserE_DIGITS-112))|(1<<(SyslParserE_Name-112))|(1<<(SyslParserE_DOT-112)))) != 0) {
			{
				p.SetState(1494)
				p.Expr()
			}

			p.SetState(1499)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1500)
			p.Match(SyslParserE_RAW_TEXT_START)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITemplate_statementContext is an interface to support dynamic dispatch.
type ITemplate_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTemplate_statementContext differentiates from other interfaces.
	IsTemplate_statementContext()
}

type Template_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplate_statementContext() *Template_statementContext {
	var p = new(Template_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_template_statement
	return p
}

func (*Template_statementContext) IsTemplate_statementContext() {}

func NewTemplate_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Template_statementContext {
	var p = new(Template_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_template_statement

	return p
}

func (s *Template_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Template_statementContext) E_RAW_TEXT_START() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RAW_TEXT_START, 0)
}

func (s *Template_statementContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *Template_statementContext) TMPL_DEBUG() antlr.TerminalNode {
	return s.GetToken(SyslParserTMPL_DEBUG, 0)
}

func (s *Template_statementContext) AllTemplate_expression() []ITemplate_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITemplate_expressionContext)(nil)).Elem())
	var tst = make([]ITemplate_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITemplate_expressionContext)
		}
	}

	return tst
}

func (s *Template_statementContext) Template_expression(i int) ITemplate_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITemplate_expressionContext)
}

func (s *Template_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Template_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Template_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTemplate_statement(s)
	}
}

func (s *Template_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTemplate_statement(s)
	}
}

func (p *SyslParser) Template_statement() (localctx ITemplate_statementContext) {
	localctx = NewTemplate_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, SyslParserRULE_template_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1503)
		p.Match(SyslParserE_RAW_TEXT_START)
	}
	p.SetState(1505)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserTMPL_DEBUG {
		{
			p.SetState(1504)
			p.Match(SyslParserTMPL_DEBUG)
		}

	}
	p.SetState(1510)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_RAW_TEXT_END || _la == SyslParserTMPL_TEXT {
		{
			p.SetState(1507)
			p.Template_expression()
		}

		p.SetState(1512)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1513)
		p.Match(SyslParserE_NL)
	}

	return localctx
}

// IExpr_statementContext is an interface to support dynamic dispatch.
type IExpr_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_let_statement returns the _expr_let_statement rule contexts.
	Get_expr_let_statement() IExpr_let_statementContext

	// Get_expr_table_of_statement returns the _expr_table_of_statement rule contexts.
	Get_expr_table_of_statement() IExpr_table_of_statementContext

	// Get_expr_simple_assign returns the _expr_simple_assign rule contexts.
	Get_expr_simple_assign() IExpr_simple_assignContext

	// Set_expr_let_statement sets the _expr_let_statement rule contexts.
	Set_expr_let_statement(IExpr_let_statementContext)

	// Set_expr_table_of_statement sets the _expr_table_of_statement rule contexts.
	Set_expr_table_of_statement(IExpr_table_of_statementContext)

	// Set_expr_simple_assign sets the _expr_simple_assign rule contexts.
	Set_expr_simple_assign(IExpr_simple_assignContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_statementContext differentiates from other interfaces.
	IsExpr_statementContext()
}

type Expr_statementContext struct {
	*antlr.BaseParserRuleContext
	parser                   antlr.Parser
	nested                   bool
	_expr_let_statement      IExpr_let_statementContext
	_expr_table_of_statement IExpr_table_of_statementContext
	_expr_simple_assign      IExpr_simple_assignContext
}

func NewEmptyExpr_statementContext() *Expr_statementContext {
	var p = new(Expr_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_statement
	return p
}

func (*Expr_statementContext) IsExpr_statementContext() {}

func NewExpr_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_statementContext {
	var p = new(Expr_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_statement

	return p
}

func (s *Expr_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_statementContext) Get_expr_let_statement() IExpr_let_statementContext {
	return s._expr_let_statement
}

func (s *Expr_statementContext) Get_expr_table_of_statement() IExpr_table_of_statementContext {
	return s._expr_table_of_statement
}

func (s *Expr_statementContext) Get_expr_simple_assign() IExpr_simple_assignContext {
	return s._expr_simple_assign
}

func (s *Expr_statementContext) Set_expr_let_statement(v IExpr_let_statementContext) {
	s._expr_let_statement = v
}

func (s *Expr_statementContext) Set_expr_table_of_statement(v IExpr_table_of_statementContext) {
	s._expr_table_of_statement = v
}

func (s *Expr_statementContext) Set_expr_simple_assign(v IExpr_simple_assignContext) {
	s._expr_simple_assign = v
}

func (s *Expr_statementContext) GetNested() bool { return s.nested }

func (s *Expr_statementContext) SetNested(v bool) { s.nested = v }

func (s *Expr_statementContext) Expr_let_statement() IExpr_let_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_let_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_let_statementContext)
}

func (s *Expr_statementContext) Expr_table_of_statement() IExpr_table_of_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_table_of_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_table_of_statementContext)
}

func (s *Expr_statementContext) Expr_simple_assign() IExpr_simple_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_simple_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_simple_assignContext)
}

func (s *Expr_statementContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *Expr_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_statement(s)
	}
}

func (s *Expr_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_statement(s)
	}
}

func (p *SyslParser) Expr_statement() (localctx IExpr_statementContext) {
	localctx = NewExpr_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, SyslParserRULE_expr_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1524)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_LET:
		{
			p.SetState(1515)

			var _x = p.Expr_let_statement()

			localctx.(*Expr_statementContext)._expr_let_statement = _x
		}
		localctx.(*Expr_statementContext).SetNested(localctx.(*Expr_statementContext).Get_expr_let_statement().GetNested())

	case SyslParserE_TABLE_OF:
		{
			p.SetState(1518)

			var _x = p.Expr_table_of_statement()

			localctx.(*Expr_statementContext)._expr_table_of_statement = _x
		}
		localctx.(*Expr_statementContext).SetNested(localctx.(*Expr_statementContext).Get_expr_table_of_statement().GetNested())

	case SyslParserE_Name:
		{
			p.SetState(1521)

			var _x = p.Expr_simple_assign()

			localctx.(*Expr_statementContext)._expr_simple_assign = _x
		}
		localctx.(*Expr_statementContext).SetNested(localctx.(*Expr_statementContext).Get_expr_simple_assign().GetNested())

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1528)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 160, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1526)

		if !(localctx.(*Expr_statementContext).nested == true) {
			panic(antlr.NewFailedPredicateException(p, "$nested == true", ""))
		}

	case 2:
		{
			p.SetState(1527)
			p.Match(SyslParserE_NL)
		}

	}

	return localctx
}

// IExpr_inject_stmtContext is an interface to support dynamic dispatch.
type IExpr_inject_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_inject_stmtContext differentiates from other interfaces.
	IsExpr_inject_stmtContext()
}

type Expr_inject_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_inject_stmtContext() *Expr_inject_stmtContext {
	var p = new(Expr_inject_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_inject_stmt
	return p
}

func (*Expr_inject_stmtContext) IsExpr_inject_stmtContext() {}

func NewExpr_inject_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_inject_stmtContext {
	var p = new(Expr_inject_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_inject_stmt

	return p
}

func (s *Expr_inject_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_inject_stmtContext) Expr_func() IExpr_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *Expr_inject_stmtContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *Expr_inject_stmtContext) E_STAR() antlr.TerminalNode {
	return s.GetToken(SyslParserE_STAR, 0)
}

func (s *Expr_inject_stmtContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *Expr_inject_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_inject_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_inject_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_inject_stmt(s)
	}
}

func (s *Expr_inject_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_inject_stmt(s)
	}
}

func (p *SyslParser) Expr_inject_stmt() (localctx IExpr_inject_stmtContext) {
	localctx = NewExpr_inject_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, SyslParserRULE_expr_inject_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1530)
		p.Expr_func()
	}
	{
		p.SetState(1531)
		p.Match(SyslParserE_DOT)
	}
	{
		p.SetState(1532)
		p.Match(SyslParserE_STAR)
	}
	{
		p.SetState(1533)
		p.Match(SyslParserE_NL)
	}

	return localctx
}

// IExpr_stmtContext is an interface to support dynamic dispatch.
type IExpr_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_stmtContext differentiates from other interfaces.
	IsExpr_stmtContext()
}

type Expr_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_stmtContext() *Expr_stmtContext {
	var p = new(Expr_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_stmt
	return p
}

func (*Expr_stmtContext) IsExpr_stmtContext() {}

func NewExpr_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_stmtContext {
	var p = new(Expr_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_stmt

	return p
}

func (s *Expr_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_stmtContext) Expr_statement_no_nl() IExpr_statement_no_nlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_statement_no_nlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_statement_no_nlContext)
}

func (s *Expr_stmtContext) Expr_statement() IExpr_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_statementContext)
}

func (s *Expr_stmtContext) Expr_inject_stmt() IExpr_inject_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_inject_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_inject_stmtContext)
}

func (s *Expr_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_stmt(s)
	}
}

func (s *Expr_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_stmt(s)
	}
}

func (p *SyslParser) Expr_stmt() (localctx IExpr_stmtContext) {
	localctx = NewExpr_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, SyslParserRULE_expr_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1538)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 161, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1535)
			p.Expr_statement_no_nl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1536)
			p.Expr_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1537)
			p.Expr_inject_stmt()
		}

	}

	return localctx
}

// ITransform_return_typeContext is an interface to support dynamic dispatch.
type ITransform_return_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransform_return_typeContext differentiates from other interfaces.
	IsTransform_return_typeContext()
}

type Transform_return_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransform_return_typeContext() *Transform_return_typeContext {
	var p = new(Transform_return_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_transform_return_type
	return p
}

func (*Transform_return_typeContext) IsTransform_return_typeContext() {}

func NewTransform_return_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transform_return_typeContext {
	var p = new(Transform_return_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_transform_return_type

	return p
}

func (s *Transform_return_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Transform_return_typeContext) Set_of() ISet_ofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_ofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_ofContext)
}

func (s *Transform_return_typeContext) Sequence_of() ISequence_ofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_ofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_ofContext)
}

func (s *Transform_return_typeContext) View_type_spec() IView_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_type_specContext)
}

func (s *Transform_return_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transform_return_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transform_return_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTransform_return_type(s)
	}
}

func (s *Transform_return_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTransform_return_type(s)
	}
}

func (p *SyslParser) Transform_return_type() (localctx ITransform_return_typeContext) {
	localctx = NewTransform_return_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, SyslParserRULE_transform_return_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1543)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 162, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1540)
			p.Set_of()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1541)
			p.Sequence_of()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1542)
			p.View_type_spec()
		}

	}

	return localctx
}

// IView_return_typeContext is an interface to support dynamic dispatch.
type IView_return_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsView_return_typeContext differentiates from other interfaces.
	IsView_return_typeContext()
}

type View_return_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyView_return_typeContext() *View_return_typeContext {
	var p = new(View_return_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view_return_type
	return p
}

func (*View_return_typeContext) IsView_return_typeContext() {}

func NewView_return_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *View_return_typeContext {
	var p = new(View_return_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view_return_type

	return p
}

func (s *View_return_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *View_return_typeContext) View_type_spec() IView_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_type_specContext)
}

func (s *View_return_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *View_return_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *View_return_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView_return_type(s)
	}
}

func (s *View_return_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView_return_type(s)
	}
}

func (p *SyslParser) View_return_type() (localctx IView_return_typeContext) {
	localctx = NewView_return_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, SyslParserRULE_view_return_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1545)
		p.View_type_spec()
	}

	return localctx
}

// ITransform_scope_varContext is an interface to support dynamic dispatch.
type ITransform_scope_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransform_scope_varContext differentiates from other interfaces.
	IsTransform_scope_varContext()
}

type Transform_scope_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransform_scope_varContext() *Transform_scope_varContext {
	var p = new(Transform_scope_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_transform_scope_var
	return p
}

func (*Transform_scope_varContext) IsTransform_scope_varContext() {}

func NewTransform_scope_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transform_scope_varContext {
	var p = new(Transform_scope_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_transform_scope_var

	return p
}

func (s *Transform_scope_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Transform_scope_varContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Transform_scope_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transform_scope_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transform_scope_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTransform_scope_var(s)
	}
}

func (s *Transform_scope_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTransform_scope_var(s)
	}
}

func (p *SyslParser) Transform_scope_var() (localctx ITransform_scope_varContext) {
	localctx = NewTransform_scope_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, SyslParserRULE_transform_scope_var)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1547)
		p.Match(SyslParserE_Name)
	}

	return localctx
}

// ITransform_argContext is an interface to support dynamic dispatch.
type ITransform_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransform_argContext differentiates from other interfaces.
	IsTransform_argContext()
}

type Transform_argContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransform_argContext() *Transform_argContext {
	var p = new(Transform_argContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_transform_arg
	return p
}

func (*Transform_argContext) IsTransform_argContext() {}

func NewTransform_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transform_argContext {
	var p = new(Transform_argContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_transform_arg

	return p
}

func (s *Transform_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Transform_argContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Transform_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transform_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transform_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTransform_arg(s)
	}
}

func (s *Transform_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTransform_arg(s)
	}
}

func (p *SyslParser) Transform_arg() (localctx ITransform_argContext) {
	localctx = NewTransform_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, SyslParserRULE_transform_arg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1549)
		p.Expr()
	}

	return localctx
}

// ITransformContext is an interface to support dynamic dispatch.
type ITransformContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransformContext differentiates from other interfaces.
	IsTransformContext()
}

type TransformContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransformContext() *TransformContext {
	var p = new(TransformContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_transform
	return p
}

func (*TransformContext) IsTransformContext() {}

func NewTransformContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransformContext {
	var p = new(TransformContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_transform

	return p
}

func (s *TransformContext) GetParser() antlr.Parser { return s.parser }

func (s *TransformContext) E_ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ARROW_RIGHT, 0)
}

func (s *TransformContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *TransformContext) E_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserE_COLON, 0)
}

func (s *TransformContext) AllE_NL() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_NL)
}

func (s *TransformContext) E_NL(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, i)
}

func (s *TransformContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *TransformContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *TransformContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *TransformContext) Transform_arg() ITransform_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransform_argContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransform_argContext)
}

func (s *TransformContext) E_ANGLE_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_OPEN, 0)
}

func (s *TransformContext) Transform_return_type() ITransform_return_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransform_return_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransform_return_typeContext)
}

func (s *TransformContext) E_ANGLE_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_CLOSE, 0)
}

func (s *TransformContext) Transform_scope_var() ITransform_scope_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransform_scope_varContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransform_scope_varContext)
}

func (s *TransformContext) AllExpr_stmt() []IExpr_stmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_stmtContext)(nil)).Elem())
	var tst = make([]IExpr_stmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_stmtContext)
		}
	}

	return tst
}

func (s *TransformContext) Expr_stmt(i int) IExpr_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_stmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_stmtContext)
}

func (s *TransformContext) AllTemplate_statement() []ITemplate_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITemplate_statementContext)(nil)).Elem())
	var tst = make([]ITemplate_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITemplate_statementContext)
		}
	}

	return tst
}

func (s *TransformContext) Template_statement(i int) ITemplate_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITemplate_statementContext)
}

func (s *TransformContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransformContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransformContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTransform(s)
	}
}

func (s *TransformContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTransform(s)
	}
}

func (p *SyslParser) Transform() (localctx ITransformContext) {
	localctx = NewTransformContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, SyslParserRULE_transform)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1552)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 163, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1551)
			p.Transform_arg()
		}

	}
	{
		p.SetState(1554)
		p.Match(SyslParserE_ARROW_RIGHT)
	}
	p.SetState(1559)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_ANGLE_OPEN {
		{
			p.SetState(1555)
			p.Match(SyslParserE_ANGLE_OPEN)
		}
		{
			p.SetState(1556)
			p.Transform_return_type()
		}
		{
			p.SetState(1557)
			p.Match(SyslParserE_ANGLE_CLOSE)
		}

	}
	{
		p.SetState(1561)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1563)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_Name {
		{
			p.SetState(1562)
			p.Transform_scope_var()
		}

	}
	{
		p.SetState(1565)
		p.Match(SyslParserE_COLON)
	}
	{
		p.SetState(1566)
		p.Match(SyslParserE_NL)
	}
	{
		p.SetState(1567)
		p.Match(SyslParserINDENT)
	}
	p.SetState(1570)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserNativeDataTypes || _la == SyslParserE_TABLE_OF || _la == SyslParserE_LET || (((_la-133)&-(0x1f+1)) == 0 && ((1<<uint((_la-133)))&((1<<(SyslParserE_FUNC-133))|(1<<(SyslParserE_RAW_TEXT_START-133))|(1<<(SyslParserE_DOT_NAME_NL-133))|(1<<(SyslParserE_Name-133)))) != 0) {
		p.SetState(1570)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserNativeDataTypes, SyslParserE_TABLE_OF, SyslParserE_LET, SyslParserE_FUNC, SyslParserE_DOT_NAME_NL, SyslParserE_Name:
			{
				p.SetState(1568)
				p.Expr_stmt()
			}

		case SyslParserE_RAW_TEXT_START:
			{
				p.SetState(1569)
				p.Template_statement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1572)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1574)
		p.Match(SyslParserDEDENT)
	}
	{
		p.SetState(1575)
		p.Match(SyslParserE_CLOSE_PAREN)
	}
	{
		p.SetState(1576)
		p.Match(SyslParserE_NL)
	}

	return localctx
}

// IExpr_blockContext is an interface to support dynamic dispatch.
type IExpr_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_blockContext differentiates from other interfaces.
	IsExpr_blockContext()
}

type Expr_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_blockContext() *Expr_blockContext {
	var p = new(Expr_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_block
	return p
}

func (*Expr_blockContext) IsExpr_blockContext() {}

func NewExpr_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_blockContext {
	var p = new(Expr_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_block

	return p
}

func (s *Expr_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_blockContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Expr_blockContext) Transform() ITransformContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransformContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransformContext)
}

func (s *Expr_blockContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Expr_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_block(s)
	}
}

func (s *Expr_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_block(s)
	}
}

func (p *SyslParser) Expr_block() (localctx IExpr_blockContext) {
	localctx = NewExpr_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, SyslParserRULE_expr_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1578)
		p.Match(SyslParserINDENT)
	}
	{
		p.SetState(1579)
		p.Transform()
	}
	{
		p.SetState(1580)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IView_paramContext is an interface to support dynamic dispatch.
type IView_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsView_paramContext differentiates from other interfaces.
	IsView_paramContext()
}

type View_paramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyView_paramContext() *View_paramContext {
	var p = new(View_paramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view_param
	return p
}

func (*View_paramContext) IsView_paramContext() {}

func NewView_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *View_paramContext {
	var p = new(View_paramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view_param

	return p
}

func (s *View_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *View_paramContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *View_paramContext) LESS_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserLESS_COLON, 0)
}

func (s *View_paramContext) View_type_spec() IView_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_type_specContext)
}

func (s *View_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *View_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *View_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView_param(s)
	}
}

func (s *View_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView_param(s)
	}
}

func (p *SyslParser) View_param() (localctx IView_paramContext) {
	localctx = NewView_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, SyslParserRULE_view_param)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1582)
		p.Name_str()
	}
	{
		p.SetState(1583)
		p.Match(SyslParserLESS_COLON)
	}
	{
		p.SetState(1584)
		p.View_type_spec()
	}

	return localctx
}

// IView_paramsContext is an interface to support dynamic dispatch.
type IView_paramsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsView_paramsContext differentiates from other interfaces.
	IsView_paramsContext()
}

type View_paramsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyView_paramsContext() *View_paramsContext {
	var p = new(View_paramsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view_params
	return p
}

func (*View_paramsContext) IsView_paramsContext() {}

func NewView_paramsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *View_paramsContext {
	var p = new(View_paramsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view_params

	return p
}

func (s *View_paramsContext) GetParser() antlr.Parser { return s.parser }

func (s *View_paramsContext) AllView_param() []IView_paramContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IView_paramContext)(nil)).Elem())
	var tst = make([]IView_paramContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IView_paramContext)
		}
	}

	return tst
}

func (s *View_paramsContext) View_param(i int) IView_paramContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_paramContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IView_paramContext)
}

func (s *View_paramsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *View_paramsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *View_paramsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *View_paramsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *View_paramsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView_params(s)
	}
}

func (s *View_paramsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView_params(s)
	}
}

func (p *SyslParser) View_params() (localctx IView_paramsContext) {
	localctx = NewView_paramsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, SyslParserRULE_view_params)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1586)
		p.View_param()
	}
	p.SetState(1591)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(1587)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(1588)
			p.View_param()
		}

		p.SetState(1593)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAbstract_viewContext is an interface to support dynamic dispatch.
type IAbstract_viewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbstract_viewContext differentiates from other interfaces.
	IsAbstract_viewContext()
}

type Abstract_viewContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstract_viewContext() *Abstract_viewContext {
	var p = new(Abstract_viewContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_abstract_view
	return p
}

func (*Abstract_viewContext) IsAbstract_viewContext() {}

func NewAbstract_viewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Abstract_viewContext {
	var p = new(Abstract_viewContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_abstract_view

	return p
}

func (s *Abstract_viewContext) GetParser() antlr.Parser { return s.parser }

func (s *Abstract_viewContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(SyslParserABSTRACT, 0)
}

func (s *Abstract_viewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Abstract_viewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Abstract_viewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAbstract_view(s)
	}
}

func (s *Abstract_viewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAbstract_view(s)
	}
}

func (p *SyslParser) Abstract_view() (localctx IAbstract_viewContext) {
	localctx = NewAbstract_viewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, SyslParserRULE_abstract_view)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1594)
		p.Match(SyslParserABSTRACT)
	}

	return localctx
}

// IViewContext is an interface to support dynamic dispatch.
type IViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAbstractView returns the abstractView attribute.
	GetAbstractView() bool

	// SetAbstractView sets the abstractView attribute.
	SetAbstractView(bool)

	// IsViewContext differentiates from other interfaces.
	IsViewContext()
}

type ViewContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	abstractView bool
}

func NewEmptyViewContext() *ViewContext {
	var p = new(ViewContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view
	return p
}

func (*ViewContext) IsViewContext() {}

func NewViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewContext {
	var p = new(ViewContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view

	return p
}

func (s *ViewContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewContext) GetAbstractView() bool { return s.abstractView }

func (s *ViewContext) SetAbstractView(v bool) { s.abstractView = v }

func (s *ViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SyslParserVIEW, 0)
}

func (s *ViewContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *ViewContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *ViewContext) View_params() IView_paramsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_paramsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_paramsContext)
}

func (s *ViewContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *ViewContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *ViewContext) Expr_block() IExpr_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_blockContext)
}

func (s *ViewContext) Abstract_view() IAbstract_viewContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbstract_viewContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbstract_viewContext)
}

func (s *ViewContext) ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_RIGHT, 0)
}

func (s *ViewContext) View_return_type() IView_return_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_return_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_return_typeContext)
}

func (s *ViewContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *ViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView(s)
	}
}

func (s *ViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView(s)
	}
}

func (p *SyslParser) View() (localctx IViewContext) {
	localctx = NewViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, SyslParserRULE_view)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1596)
		p.Match(SyslParserVIEW)
	}
	{
		p.SetState(1597)
		p.Name_str()
	}
	{
		p.SetState(1598)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(1599)
		p.View_params()
	}
	{
		p.SetState(1600)
		p.Match(SyslParserCLOSE_PAREN)
	}
	p.SetState(1603)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserARROW_RIGHT {
		{
			p.SetState(1601)
			p.Match(SyslParserARROW_RIGHT)
		}
		{
			p.SetState(1602)
			p.View_return_type()
		}

	}
	p.SetState(1613)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserCOLON, SyslParserSQ_OPEN:
		p.SetState(1606)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserSQ_OPEN {
			{
				p.SetState(1605)
				p.Attribs_or_modifiers()
			}

		}
		{
			p.SetState(1608)
			p.Match(SyslParserCOLON)
		}
		{
			p.SetState(1609)
			p.Expr_block()
		}

	case SyslParserABSTRACT:
		{
			p.SetState(1610)
			p.Abstract_view()
		}
		localctx.(*ViewContext).SetAbstractView(true)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAliasContext is an interface to support dynamic dispatch.
type IAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAliasContext differentiates from other interfaces.
	IsAliasContext()
}

type AliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasContext() *AliasContext {
	var p = new(AliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_alias
	return p
}

func (*AliasContext) IsAliasContext() {}

func NewAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasContext {
	var p = new(AliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_alias

	return p
}

func (s *AliasContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(SyslParserALIAS, 0)
}

func (s *AliasContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *AliasContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *AliasContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *AliasContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *AliasContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *AliasContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *AliasContext) Collection_type() ICollection_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollection_typeContext)
}

func (s *AliasContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *AliasContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAlias(s)
	}
}

func (s *AliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAlias(s)
	}
}

func (p *SyslParser) Alias() (localctx IAliasContext) {
	localctx = NewAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, SyslParserRULE_alias)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1615)
		p.Match(SyslParserALIAS)
	}
	{
		p.SetState(1616)
		p.Name_str()
	}
	p.SetState(1618)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(1617)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(1620)
		p.Match(SyslParserCOLON)
	}
	p.SetState(1644)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserNativeDataTypes, SyslParserSEQUENCE_OF, SyslParserSET_OF, SyslParserAT, SyslParserTEXT_LINE, SyslParserName, SyslParserE_SEQUENCE_OF, SyslParserE_SET_OF, SyslParserE_Name:
		p.SetState(1624)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SyslParserAT {
			{
				p.SetState(1621)
				p.Annotation()
			}

			p.SetState(1626)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1629)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserNativeDataTypes, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
			{
				p.SetState(1627)
				p.Types()
			}

		case SyslParserSEQUENCE_OF, SyslParserSET_OF, SyslParserE_SEQUENCE_OF, SyslParserE_SET_OF:
			{
				p.SetState(1628)
				p.Collection_type()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case SyslParserINDENT:
		{
			p.SetState(1631)
			p.Match(SyslParserINDENT)
		}
		p.SetState(1635)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SyslParserAT {
			{
				p.SetState(1632)
				p.Annotation()
			}

			p.SetState(1637)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1640)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserNativeDataTypes, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
			{
				p.SetState(1638)
				p.Types()
			}

		case SyslParserSEQUENCE_OF, SyslParserSET_OF, SyslParserE_SEQUENCE_OF, SyslParserE_SET_OF:
			{
				p.SetState(1639)
				p.Collection_type()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(1642)
			p.Match(SyslParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IApp_declContext is an interface to support dynamic dispatch.
type IApp_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_view returns the _view rule contexts.
	Get_view() IViewContext

	// Set_view sets the _view rule contexts.
	Set_view(IViewContext)

	// GetCheck returns the check attribute.
	GetCheck() bool

	// SetCheck sets the check attribute.
	SetCheck(bool)

	// IsApp_declContext differentiates from other interfaces.
	IsApp_declContext()
}

type App_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	check  bool
	_view  IViewContext
}

func NewEmptyApp_declContext() *App_declContext {
	var p = new(App_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_app_decl
	return p
}

func (*App_declContext) IsApp_declContext() {}

func NewApp_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *App_declContext {
	var p = new(App_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_app_decl

	return p
}

func (s *App_declContext) GetParser() antlr.Parser { return s.parser }

func (s *App_declContext) Get_view() IViewContext { return s._view }

func (s *App_declContext) Set_view(v IViewContext) { s._view = v }

func (s *App_declContext) GetCheck() bool { return s.check }

func (s *App_declContext) SetCheck(v bool) { s.check = v }

func (s *App_declContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *App_declContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *App_declContext) AllAlias() []IAliasContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAliasContext)(nil)).Elem())
	var tst = make([]IAliasContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAliasContext)
		}
	}

	return tst
}

func (s *App_declContext) Alias(i int) IAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *App_declContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *App_declContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *App_declContext) AllCollector() []ICollectorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICollectorContext)(nil)).Elem())
	var tst = make([]ICollectorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICollectorContext)
		}
	}

	return tst
}

func (s *App_declContext) Collector(i int) ICollectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollectorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICollectorContext)
}

func (s *App_declContext) AllEvent() []IEventContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEventContext)(nil)).Elem())
	var tst = make([]IEventContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEventContext)
		}
	}

	return tst
}

func (s *App_declContext) Event(i int) IEventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEventContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEventContext)
}

func (s *App_declContext) AllFacade() []IFacadeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFacadeContext)(nil)).Elem())
	var tst = make([]IFacadeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFacadeContext)
		}
	}

	return tst
}

func (s *App_declContext) Facade(i int) IFacadeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFacadeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFacadeContext)
}

func (s *App_declContext) AllMixin() []IMixinContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMixinContext)(nil)).Elem())
	var tst = make([]IMixinContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMixinContext)
		}
	}

	return tst
}

func (s *App_declContext) Mixin(i int) IMixinContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMixinContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMixinContext)
}

func (s *App_declContext) AllRest_endpoint() []IRest_endpointContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRest_endpointContext)(nil)).Elem())
	var tst = make([]IRest_endpointContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRest_endpointContext)
		}
	}

	return tst
}

func (s *App_declContext) Rest_endpoint(i int) IRest_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRest_endpointContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRest_endpointContext)
}

func (s *App_declContext) AllSimple_endpoint() []ISimple_endpointContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_endpointContext)(nil)).Elem())
	var tst = make([]ISimple_endpointContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_endpointContext)
		}
	}

	return tst
}

func (s *App_declContext) Simple_endpoint(i int) ISimple_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_endpointContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_endpointContext)
}

func (s *App_declContext) AllSubscribe() []ISubscribeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubscribeContext)(nil)).Elem())
	var tst = make([]ISubscribeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubscribeContext)
		}
	}

	return tst
}

func (s *App_declContext) Subscribe(i int) ISubscribeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscribeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubscribeContext)
}

func (s *App_declContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *App_declContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *App_declContext) AllUnion() []IUnionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnionContext)(nil)).Elem())
	var tst = make([]IUnionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnionContext)
		}
	}

	return tst
}

func (s *App_declContext) Union(i int) IUnionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnionContext)
}

func (s *App_declContext) AllView() []IViewContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IViewContext)(nil)).Elem())
	var tst = make([]IViewContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IViewContext)
		}
	}

	return tst
}

func (s *App_declContext) View(i int) IViewContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IViewContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IViewContext)
}

func (s *App_declContext) AllTable() []ITableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableContext)(nil)).Elem())
	var tst = make([]ITableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITableContext)
		}
	}

	return tst
}

func (s *App_declContext) Table(i int) ITableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *App_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *App_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *App_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterApp_decl(s)
	}
}

func (s *App_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitApp_decl(s)
	}
}

func (p *SyslParser) App_decl() (localctx IApp_declContext) {
	localctx = NewApp_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, SyslParserRULE_app_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1646)
		p.Match(SyslParserINDENT)
	}
	p.SetState(1662)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(1662)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 178, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1647)
					p.Alias()
				}

			case 2:
				{
					p.SetState(1648)
					p.Annotation()
				}

			case 3:
				{
					p.SetState(1649)
					p.Collector()
				}

			case 4:
				{
					p.SetState(1650)
					p.Event()
				}

			case 5:
				{
					p.SetState(1651)
					p.Facade()
				}

			case 6:
				{
					p.SetState(1652)
					p.Mixin()
				}

			case 7:
				{
					p.SetState(1653)
					p.Rest_endpoint()
				}

			case 8:
				{
					p.SetState(1654)
					p.Simple_endpoint()
				}

			case 9:
				{
					p.SetState(1655)
					p.Subscribe()
				}

			case 10:
				{
					p.SetState(1656)
					p.Match(SyslParserSYSL_COMMENT)
				}

			case 11:
				{
					p.SetState(1657)
					p.Union()
				}

			case 12:
				{
					p.SetState(1658)

					var _x = p.View()

					localctx.(*App_declContext)._view = _x
				}
				localctx.(*App_declContext).SetCheck(localctx.(*App_declContext).Get_view().GetAbstractView())

			case 13:
				{
					p.SetState(1661)
					p.Table()
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1664)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 179, p.GetParserRuleContext())
	}
	p.SetState(1668)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 180, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1666)

		if !(localctx.(*App_declContext).check) {
			panic(antlr.NewFailedPredicateException(p, "$check", ""))
		}

	case 2:
		{
			p.SetState(1667)
			p.Match(SyslParserDEDENT)
		}

	}

	return localctx
}

// IApplicationContext is an interface to support dynamic dispatch.
type IApplicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsApplicationContext differentiates from other interfaces.
	IsApplicationContext()
}

type ApplicationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyApplicationContext() *ApplicationContext {
	var p = new(ApplicationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_application
	return p
}

func (*ApplicationContext) IsApplicationContext() {}

func NewApplicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ApplicationContext {
	var p = new(ApplicationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_application

	return p
}

func (s *ApplicationContext) GetParser() antlr.Parser { return s.parser }

func (s *ApplicationContext) Name_with_attribs() IName_with_attribsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_with_attribsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_with_attribsContext)
}

func (s *ApplicationContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *ApplicationContext) App_decl() IApp_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_declContext)
}

func (s *ApplicationContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *ApplicationContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *ApplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ApplicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ApplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterApplication(s)
	}
}

func (s *ApplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitApplication(s)
	}
}

func (p *SyslParser) Application() (localctx IApplicationContext) {
	localctx = NewApplicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, SyslParserRULE_application)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1673)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserSYSL_COMMENT {
		{
			p.SetState(1670)
			p.Match(SyslParserSYSL_COMMENT)
		}

		p.SetState(1675)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1676)
		p.Name_with_attribs()
	}
	{
		p.SetState(1677)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(1678)
		p.App_decl()
	}

	return localctx
}

// IImport_modeContext is an interface to support dynamic dispatch.
type IImport_modeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_modeContext differentiates from other interfaces.
	IsImport_modeContext()
}

type Import_modeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_modeContext() *Import_modeContext {
	var p = new(Import_modeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_import_mode
	return p
}

func (*Import_modeContext) IsImport_modeContext() {}

func NewImport_modeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_modeContext {
	var p = new(Import_modeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_import_mode

	return p
}

func (s *Import_modeContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_modeContext) TILDE() antlr.TerminalNode {
	return s.GetToken(SyslParserTILDE, 0)
}

func (s *Import_modeContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Import_modeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_modeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_modeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterImport_mode(s)
	}
}

func (s *Import_modeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitImport_mode(s)
	}
}

func (p *SyslParser) Import_mode() (localctx IImport_modeContext) {
	localctx = NewImport_modeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, SyslParserRULE_import_mode)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1680)
		p.Match(SyslParserTILDE)
	}
	{
		p.SetState(1681)
		p.Match(SyslParserName)
	}

	return localctx
}

// IImport_stmtContext is an interface to support dynamic dispatch.
type IImport_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_stmtContext differentiates from other interfaces.
	IsImport_stmtContext()
}

type Import_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_stmtContext() *Import_stmtContext {
	var p = new(Import_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_import_stmt
	return p
}

func (*Import_stmtContext) IsImport_stmtContext() {}

func NewImport_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_stmtContext {
	var p = new(Import_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_import_stmt

	return p
}

func (s *Import_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_stmtContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(SyslParserIMPORT, 0)
}

func (s *Import_stmtContext) IMPORT_PATH() antlr.TerminalNode {
	return s.GetToken(SyslParserIMPORT_PATH, 0)
}

func (s *Import_stmtContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(SyslParserNEWLINE, 0)
}

func (s *Import_stmtContext) AS() antlr.TerminalNode {
	return s.GetToken(SyslParserAS, 0)
}

func (s *Import_stmtContext) AllName() []antlr.TerminalNode {
	return s.GetTokens(SyslParserName)
}

func (s *Import_stmtContext) Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserName, i)
}

func (s *Import_stmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(SyslParserWS)
}

func (s *Import_stmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserWS, i)
}

func (s *Import_stmtContext) Import_mode() IImport_modeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_modeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_modeContext)
}

func (s *Import_stmtContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *Import_stmtContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *Import_stmtContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserDOT)
}

func (s *Import_stmtContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserDOT, i)
}

func (s *Import_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterImport_stmt(s)
	}
}

func (s *Import_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitImport_stmt(s)
	}
}

func (p *SyslParser) Import_stmt() (localctx IImport_stmtContext) {
	localctx = NewImport_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, SyslParserRULE_import_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1683)
		p.Match(SyslParserIMPORT)
	}
	{
		p.SetState(1684)
		p.Match(SyslParserIMPORT_PATH)
	}
	p.SetState(1694)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserAS {
		{
			p.SetState(1685)
			p.Match(SyslParserAS)
		}
		{
			p.SetState(1686)
			p.Match(SyslParserName)
		}
		p.SetState(1691)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SyslParserDOT {
			{
				p.SetState(1687)
				p.Match(SyslParserDOT)
			}
			{
				p.SetState(1688)
				p.Match(SyslParserName)
			}

			p.SetState(1693)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(1699)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserWS {
		{
			p.SetState(1696)
			p.Match(SyslParserWS)
		}

		p.SetState(1701)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1703)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserTILDE {
		{
			p.SetState(1702)
			p.Import_mode()
		}

	}
	p.SetState(1712)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserIMPORT, SyslParserSYSL_COMMENT, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.SetState(1708)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 186, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1705)
					p.Match(SyslParserSYSL_COMMENT)
				}

			}
			p.SetState(1710)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 186, p.GetParserRuleContext())
		}

	case SyslParserNEWLINE:
		{
			p.SetState(1711)
			p.Match(SyslParserNEWLINE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IImports_declContext is an interface to support dynamic dispatch.
type IImports_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImports_declContext differentiates from other interfaces.
	IsImports_declContext()
}

type Imports_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImports_declContext() *Imports_declContext {
	var p = new(Imports_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_imports_decl
	return p
}

func (*Imports_declContext) IsImports_declContext() {}

func NewImports_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Imports_declContext {
	var p = new(Imports_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_imports_decl

	return p
}

func (s *Imports_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Imports_declContext) AllImport_stmt() []IImport_stmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImport_stmtContext)(nil)).Elem())
	var tst = make([]IImport_stmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImport_stmtContext)
		}
	}

	return tst
}

func (s *Imports_declContext) Import_stmt(i int) IImport_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_stmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImport_stmtContext)
}

func (s *Imports_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Imports_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Imports_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterImports_decl(s)
	}
}

func (s *Imports_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitImports_decl(s)
	}
}

func (p *SyslParser) Imports_decl() (localctx IImports_declContext) {
	localctx = NewImports_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, SyslParserRULE_imports_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1715)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserIMPORT {
		{
			p.SetState(1714)
			p.Import_stmt()
		}

		p.SetState(1717)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISysl_fileContext is an interface to support dynamic dispatch.
type ISysl_fileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSysl_fileContext differentiates from other interfaces.
	IsSysl_fileContext()
}

type Sysl_fileContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySysl_fileContext() *Sysl_fileContext {
	var p = new(Sysl_fileContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_sysl_file
	return p
}

func (*Sysl_fileContext) IsSysl_fileContext() {}

func NewSysl_fileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sysl_fileContext {
	var p = new(Sysl_fileContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_sysl_file

	return p
}

func (s *Sysl_fileContext) GetParser() antlr.Parser { return s.parser }

func (s *Sysl_fileContext) EOF() antlr.TerminalNode {
	return s.GetToken(SyslParserEOF, 0)
}

func (s *Sysl_fileContext) Imports_decl() IImports_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImports_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImports_declContext)
}

func (s *Sysl_fileContext) AllApplication() []IApplicationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IApplicationContext)(nil)).Elem())
	var tst = make([]IApplicationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IApplicationContext)
		}
	}

	return tst
}

func (s *Sysl_fileContext) Application(i int) IApplicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApplicationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IApplicationContext)
}

func (s *Sysl_fileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sysl_fileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sysl_fileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSysl_file(s)
	}
}

func (s *Sysl_fileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSysl_file(s)
	}
}

func (p *SyslParser) Sysl_file() (localctx ISysl_fileContext) {
	localctx = NewSysl_fileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, SyslParserRULE_sysl_file)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1720)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserIMPORT {
		{
			p.SetState(1719)
			p.Imports_decl()
		}

	}
	p.SetState(1723)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-60)&-(0x1f+1)) == 0 && ((1<<uint((_la-60)))&((1<<(SyslParserSYSL_COMMENT-60))|(1<<(SyslParserTEXT_LINE-60))|(1<<(SyslParserName-60)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(1722)
			p.Application()
		}

		p.SetState(1725)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1727)
		p.Match(SyslParserEOF)
	}

	return localctx
}

func (p *SyslParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 147:
		var t *Cond_blockContext = nil
		if localctx != nil {
			t = localctx.(*Cond_blockContext)
		}
		return p.Cond_block_Sempred(t, predIndex)

	case 148:
		var t *Final_elseContext = nil
		if localctx != nil {
			t = localctx.(*Final_elseContext)
		}
		return p.Final_else_Sempred(t, predIndex)

	case 161:
		var t *Expr_statementContext = nil
		if localctx != nil {
			t = localctx.(*Expr_statementContext)
		}
		return p.Expr_statement_Sempred(t, predIndex)

	case 175:
		var t *App_declContext = nil
		if localctx != nil {
			t = localctx.(*App_declContext)
		}
		return p.App_decl_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *SyslParser) Cond_block_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return localctx.(*Cond_blockContext).Get_else_block_stmt().GetNested() == true

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SyslParser) Final_else_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return localctx.(*Final_elseContext).Get_expr().GetNested() == true

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SyslParser) Expr_statement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return localctx.(*Expr_statementContext).nested == true

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SyslParser) App_decl_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return localctx.(*App_declContext).check

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
