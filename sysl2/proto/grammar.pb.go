// Code generated by protoc-gen-go. DO NOT EDIT.
// source: grammar.proto

/*
Package sysl is a generated protocol buffer package.

It is generated from these files:
	grammar.proto

It has these top-level messages:
	Grammar
	Flags
	Flag
	Rule
	RuleName
	Choice
	Sequence
	Term
	Atom
	Quantifier
*/
package sysl

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/protoc-gen-go/descriptor"
import google_protobuf1 "github.com/golang/protobuf/ptypes/empty"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Grammar struct {
	// "!grammar" NAME ":" INDENT Rule* OUTDENT
	Name  string           `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Flags *Flags           `protobuf:"bytes,2,opt,name=flags" json:"flags,omitempty"`
	Rules map[string]*Rule `protobuf:"bytes,3,rep,name=rules" json:"rules,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Start string           `protobuf:"bytes,4,opt,name=start" json:"start,omitempty"`
}

func (m *Grammar) Reset()                    { *m = Grammar{} }
func (m *Grammar) String() string            { return proto.CompactTextString(m) }
func (*Grammar) ProtoMessage()               {}
func (*Grammar) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Grammar) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Grammar) GetFlags() *Flags {
	if m != nil {
		return m.Flags
	}
	return nil
}

func (m *Grammar) GetRules() map[string]*Rule {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *Grammar) GetStart() string {
	if m != nil {
		return m.Start
	}
	return ""
}

type Flags struct {
	// "[" Flag:"," "]"
	Flag []*Flag `protobuf:"bytes,1,rep,name=flag" json:"flag,omitempty"`
}

func (m *Flags) Reset()                    { *m = Flags{} }
func (m *Flags) String() string            { return proto.CompactTextString(m) }
func (*Flags) ProtoMessage()               {}
func (*Flags) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Flags) GetFlag() []*Flag {
	if m != nil {
		return m.Flag
	}
	return nil
}

type Flag struct {
	// <sign>/[-+]/ <token>NAME
	Sign  string `protobuf:"bytes,1,opt,name=sign" json:"sign,omitempty"`
	Token string `protobuf:"bytes,2,opt,name=token" json:"token,omitempty"`
}

func (m *Flag) Reset()                    { *m = Flag{} }
func (m *Flag) String() string            { return proto.CompactTextString(m) }
func (*Flag) ProtoMessage()               {}
func (*Flag) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Flag) GetSign() string {
	if m != nil {
		return m.Sign
	}
	return ""
}

func (m *Flag) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type Rule struct {
	// RuleName Flags? ":" INDENT Body OUTDENT
	Name    *RuleName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Choices *Choice   `protobuf:"bytes,2,opt,name=choices" json:"choices,omitempty"`
}

func (m *Rule) Reset()                    { *m = Rule{} }
func (m *Rule) String() string            { return proto.CompactTextString(m) }
func (*Rule) ProtoMessage()               {}
func (*Rule) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Rule) GetName() *RuleName {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *Rule) GetChoices() *Choice {
	if m != nil {
		return m.Choices
	}
	return nil
}

type RuleName struct {
	// NAME ":" INDENT Body OUTDENT
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Alias string `protobuf:"bytes,2,opt,name=alias" json:"alias,omitempty"`
}

func (m *RuleName) Reset()                    { *m = RuleName{} }
func (m *RuleName) String() string            { return proto.CompactTextString(m) }
func (*RuleName) ProtoMessage()               {}
func (*RuleName) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *RuleName) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RuleName) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

type Choice struct {
	// ("<" NAME ">")? Sequence:":"
	Sequence []*Sequence `protobuf:"bytes,1,rep,name=sequence" json:"sequence,omitempty"`
}

func (m *Choice) Reset()                    { *m = Choice{} }
func (m *Choice) String() string            { return proto.CompactTextString(m) }
func (*Choice) ProtoMessage()               {}
func (*Choice) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Choice) GetSequence() []*Sequence {
	if m != nil {
		return m.Sequence
	}
	return nil
}

type Sequence struct {
	// Term*:"|"
	Term []*Term `protobuf:"bytes,1,rep,name=term" json:"term,omitempty"`
}

func (m *Sequence) Reset()                    { *m = Sequence{} }
func (m *Sequence) String() string            { return proto.CompactTextString(m) }
func (*Sequence) ProtoMessage()               {}
func (*Sequence) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Sequence) GetTerm() []*Term {
	if m != nil {
		return m.Term
	}
	return nil
}

type Term struct {
	// Atom Quantifier
	Atom       *Atom       `protobuf:"bytes,1,opt,name=atom" json:"atom,omitempty"`
	Quantifier *Quantifier `protobuf:"bytes,2,opt,name=quantifier" json:"quantifier,omitempty"`
}

func (m *Term) Reset()                    { *m = Term{} }
func (m *Term) String() string            { return proto.CompactTextString(m) }
func (*Term) ProtoMessage()               {}
func (*Term) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Term) GetAtom() *Atom {
	if m != nil {
		return m.Atom
	}
	return nil
}

func (m *Term) GetQuantifier() *Quantifier {
	if m != nil {
		return m.Quantifier
	}
	return nil
}

type Atom struct {
	Id int32 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// ("<" NAME ">")? ( string | regexp | "(" NestedBody ")" )
	//
	// Types that are valid to be assigned to Union:
	//	*Atom_String_
	//	*Atom_Regexp
	//	*Atom_Rulename
	//	*Atom_Choices
	Union isAtom_Union `protobuf_oneof:"union"`
}

func (m *Atom) Reset()                    { *m = Atom{} }
func (m *Atom) String() string            { return proto.CompactTextString(m) }
func (*Atom) ProtoMessage()               {}
func (*Atom) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type isAtom_Union interface {
	isAtom_Union()
}

type Atom_String_ struct {
	String_ string `protobuf:"bytes,2,opt,name=string,oneof"`
}
type Atom_Regexp struct {
	Regexp string `protobuf:"bytes,3,opt,name=regexp,oneof"`
}
type Atom_Rulename struct {
	Rulename *RuleName `protobuf:"bytes,4,opt,name=rulename,oneof"`
}
type Atom_Choices struct {
	Choices *Choice `protobuf:"bytes,5,opt,name=choices,oneof"`
}

func (*Atom_String_) isAtom_Union()  {}
func (*Atom_Regexp) isAtom_Union()   {}
func (*Atom_Rulename) isAtom_Union() {}
func (*Atom_Choices) isAtom_Union()  {}

func (m *Atom) GetUnion() isAtom_Union {
	if m != nil {
		return m.Union
	}
	return nil
}

func (m *Atom) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Atom) GetString_() string {
	if x, ok := m.GetUnion().(*Atom_String_); ok {
		return x.String_
	}
	return ""
}

func (m *Atom) GetRegexp() string {
	if x, ok := m.GetUnion().(*Atom_Regexp); ok {
		return x.Regexp
	}
	return ""
}

func (m *Atom) GetRulename() *RuleName {
	if x, ok := m.GetUnion().(*Atom_Rulename); ok {
		return x.Rulename
	}
	return nil
}

func (m *Atom) GetChoices() *Choice {
	if x, ok := m.GetUnion().(*Atom_Choices); ok {
		return x.Choices
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Atom) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Atom_OneofMarshaler, _Atom_OneofUnmarshaler, _Atom_OneofSizer, []interface{}{
		(*Atom_String_)(nil),
		(*Atom_Regexp)(nil),
		(*Atom_Rulename)(nil),
		(*Atom_Choices)(nil),
	}
}

func _Atom_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Atom)
	// union
	switch x := m.Union.(type) {
	case *Atom_String_:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.String_)
	case *Atom_Regexp:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Regexp)
	case *Atom_Rulename:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Rulename); err != nil {
			return err
		}
	case *Atom_Choices:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Choices); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Atom.Union has unexpected type %T", x)
	}
	return nil
}

func _Atom_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Atom)
	switch tag {
	case 2: // union.string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Union = &Atom_String_{x}
		return true, err
	case 3: // union.regexp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Union = &Atom_Regexp{x}
		return true, err
	case 4: // union.rulename
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RuleName)
		err := b.DecodeMessage(msg)
		m.Union = &Atom_Rulename{msg}
		return true, err
	case 5: // union.choices
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Choice)
		err := b.DecodeMessage(msg)
		m.Union = &Atom_Choices{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Atom_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Atom)
	// union
	switch x := m.Union.(type) {
	case *Atom_String_:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.String_)))
		n += len(x.String_)
	case *Atom_Regexp:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Regexp)))
		n += len(x.Regexp)
	case *Atom_Rulename:
		s := proto.Size(x.Rulename)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Atom_Choices:
		s := proto.Size(x.Choices)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Quantifier struct {
	// ( <opt>"?" | <zero_plus>"*" | <one_plus>"+" | ":" <separator>Atom )*
	//
	// Types that are valid to be assigned to Union:
	//	*Quantifier_Optional
	//	*Quantifier_ZeroPlus
	//	*Quantifier_OnePlus
	//	*Quantifier_Separator
	Union isQuantifier_Union `protobuf_oneof:"union"`
}

func (m *Quantifier) Reset()                    { *m = Quantifier{} }
func (m *Quantifier) String() string            { return proto.CompactTextString(m) }
func (*Quantifier) ProtoMessage()               {}
func (*Quantifier) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type isQuantifier_Union interface {
	isQuantifier_Union()
}

type Quantifier_Optional struct {
	Optional *google_protobuf1.Empty `protobuf:"bytes,1,opt,name=optional,oneof"`
}
type Quantifier_ZeroPlus struct {
	ZeroPlus *google_protobuf1.Empty `protobuf:"bytes,2,opt,name=zero_plus,json=zeroPlus,oneof"`
}
type Quantifier_OnePlus struct {
	OnePlus *google_protobuf1.Empty `protobuf:"bytes,3,opt,name=one_plus,json=onePlus,oneof"`
}
type Quantifier_Separator struct {
	Separator *Atom `protobuf:"bytes,4,opt,name=separator,oneof"`
}

func (*Quantifier_Optional) isQuantifier_Union()  {}
func (*Quantifier_ZeroPlus) isQuantifier_Union()  {}
func (*Quantifier_OnePlus) isQuantifier_Union()   {}
func (*Quantifier_Separator) isQuantifier_Union() {}

func (m *Quantifier) GetUnion() isQuantifier_Union {
	if m != nil {
		return m.Union
	}
	return nil
}

func (m *Quantifier) GetOptional() *google_protobuf1.Empty {
	if x, ok := m.GetUnion().(*Quantifier_Optional); ok {
		return x.Optional
	}
	return nil
}

func (m *Quantifier) GetZeroPlus() *google_protobuf1.Empty {
	if x, ok := m.GetUnion().(*Quantifier_ZeroPlus); ok {
		return x.ZeroPlus
	}
	return nil
}

func (m *Quantifier) GetOnePlus() *google_protobuf1.Empty {
	if x, ok := m.GetUnion().(*Quantifier_OnePlus); ok {
		return x.OnePlus
	}
	return nil
}

func (m *Quantifier) GetSeparator() *Atom {
	if x, ok := m.GetUnion().(*Quantifier_Separator); ok {
		return x.Separator
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Quantifier) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Quantifier_OneofMarshaler, _Quantifier_OneofUnmarshaler, _Quantifier_OneofSizer, []interface{}{
		(*Quantifier_Optional)(nil),
		(*Quantifier_ZeroPlus)(nil),
		(*Quantifier_OnePlus)(nil),
		(*Quantifier_Separator)(nil),
	}
}

func _Quantifier_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Quantifier)
	// union
	switch x := m.Union.(type) {
	case *Quantifier_Optional:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Optional); err != nil {
			return err
		}
	case *Quantifier_ZeroPlus:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ZeroPlus); err != nil {
			return err
		}
	case *Quantifier_OnePlus:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OnePlus); err != nil {
			return err
		}
	case *Quantifier_Separator:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Separator); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Quantifier.Union has unexpected type %T", x)
	}
	return nil
}

func _Quantifier_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Quantifier)
	switch tag {
	case 1: // union.optional
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.Empty)
		err := b.DecodeMessage(msg)
		m.Union = &Quantifier_Optional{msg}
		return true, err
	case 2: // union.zero_plus
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.Empty)
		err := b.DecodeMessage(msg)
		m.Union = &Quantifier_ZeroPlus{msg}
		return true, err
	case 3: // union.one_plus
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.Empty)
		err := b.DecodeMessage(msg)
		m.Union = &Quantifier_OnePlus{msg}
		return true, err
	case 4: // union.separator
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Atom)
		err := b.DecodeMessage(msg)
		m.Union = &Quantifier_Separator{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Quantifier_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Quantifier)
	// union
	switch x := m.Union.(type) {
	case *Quantifier_Optional:
		s := proto.Size(x.Optional)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Quantifier_ZeroPlus:
		s := proto.Size(x.ZeroPlus)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Quantifier_OnePlus:
		s := proto.Size(x.OnePlus)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Quantifier_Separator:
		s := proto.Size(x.Separator)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

var E_Base = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.FileOptions)(nil),
	ExtensionType: (*Grammar)(nil),
	Field:         50000,
	Name:          "sysl.base",
	Tag:           "bytes,50000,opt,name=base",
	Filename:      "grammar.proto",
}

func init() {
	proto.RegisterType((*Grammar)(nil), "sysl.Grammar")
	proto.RegisterType((*Flags)(nil), "sysl.Flags")
	proto.RegisterType((*Flag)(nil), "sysl.Flag")
	proto.RegisterType((*Rule)(nil), "sysl.Rule")
	proto.RegisterType((*RuleName)(nil), "sysl.RuleName")
	proto.RegisterType((*Choice)(nil), "sysl.Choice")
	proto.RegisterType((*Sequence)(nil), "sysl.Sequence")
	proto.RegisterType((*Term)(nil), "sysl.Term")
	proto.RegisterType((*Atom)(nil), "sysl.Atom")
	proto.RegisterType((*Quantifier)(nil), "sysl.Quantifier")
	proto.RegisterExtension(E_Base)
}

func init() { proto.RegisterFile("grammar.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 596 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x53, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0x8e, 0x13, 0xbb, 0x49, 0x26, 0xb4, 0xaa, 0x56, 0x15, 0xb2, 0x0a, 0x42, 0xc1, 0x07, 0x88,
	0x2a, 0xe4, 0x56, 0x6d, 0x91, 0x50, 0x6f, 0x05, 0x5a, 0x72, 0xe2, 0x67, 0xe1, 0xc0, 0x0d, 0x6d,
	0xd3, 0xa9, 0x59, 0xd5, 0xde, 0x75, 0x77, 0xd7, 0x88, 0xf0, 0x00, 0xbc, 0x0c, 0xaf, 0xc2, 0x81,
	0x77, 0xe0, 0x45, 0xd0, 0xfe, 0x38, 0x49, 0x69, 0x05, 0x37, 0xcf, 0xcc, 0x37, 0x33, 0xdf, 0xf7,
	0x8d, 0x17, 0xd6, 0x0b, 0xc5, 0xaa, 0x8a, 0xa9, 0xbc, 0x56, 0xd2, 0x48, 0x12, 0xeb, 0xb9, 0x2e,
	0xb7, 0xc7, 0x85, 0x94, 0x45, 0x89, 0xbb, 0x2e, 0x77, 0xd6, 0x5c, 0xec, 0x9e, 0xa3, 0x9e, 0x29,
	0x5e, 0x1b, 0x19, 0x70, 0xdb, 0xf7, 0xfe, 0x46, 0x60, 0x55, 0x9b, 0xb9, 0x2f, 0x66, 0x3f, 0x23,
	0xe8, 0xbf, 0xf2, 0x63, 0x09, 0x81, 0x58, 0xb0, 0x0a, 0xd3, 0x68, 0x1c, 0x4d, 0x86, 0xd4, 0x7d,
	0x93, 0x87, 0x90, 0x5c, 0x94, 0xac, 0xd0, 0x69, 0x77, 0x1c, 0x4d, 0x46, 0xfb, 0xa3, 0xdc, 0x2e,
	0xcd, 0x4f, 0x6d, 0x8a, 0xfa, 0x0a, 0xc9, 0x21, 0x51, 0x4d, 0x89, 0x3a, 0xed, 0x8d, 0x7b, 0x93,
	0xd1, 0x7e, 0xea, 0x21, 0x61, 0x68, 0x4e, 0x6d, 0xe9, 0x44, 0x18, 0x35, 0xa7, 0x1e, 0x46, 0xb6,
	0x20, 0xd1, 0x86, 0x29, 0x93, 0xc6, 0x6e, 0x8f, 0x0f, 0xb6, 0x5f, 0x02, 0x2c, 0xa1, 0x64, 0x13,
	0x7a, 0x97, 0x38, 0x0f, 0x4c, 0xec, 0x27, 0x19, 0x43, 0xf2, 0x85, 0x95, 0x0d, 0x06, 0x22, 0xe0,
	0xb7, 0xd8, 0x16, 0xea, 0x0b, 0x47, 0xdd, 0x67, 0x51, 0xf6, 0x18, 0x12, 0xc7, 0x8d, 0x3c, 0x80,
	0xd8, 0xb2, 0x4b, 0x23, 0xc7, 0x09, 0x96, 0xb4, 0xa9, 0xcb, 0x67, 0x7b, 0x10, 0xdb, 0xc8, 0x6a,
	0xd6, 0xbc, 0x10, 0xad, 0x66, 0xfb, 0x6d, 0x09, 0x1a, 0x79, 0x89, 0xc2, 0xad, 0x1a, 0x52, 0x1f,
	0x64, 0x14, 0x62, 0xbb, 0x8d, 0x64, 0x2b, 0x2e, 0x8d, 0xf6, 0x37, 0x96, 0x3c, 0x5e, 0xb3, 0x0a,
	0x83, 0x6b, 0x8f, 0xa0, 0x3f, 0xfb, 0x2c, 0xf9, 0x0c, 0x5b, 0xdf, 0xee, 0x78, 0xd8, 0x0b, 0x97,
	0xa4, 0x6d, 0x31, 0x3b, 0x84, 0x41, 0xdb, 0x79, 0xab, 0xfb, 0x5b, 0x90, 0xb0, 0x92, 0x33, 0xdd,
	0x32, 0x71, 0x41, 0x76, 0x08, 0x6b, 0x7e, 0x10, 0xd9, 0x81, 0x81, 0xc6, 0xab, 0x06, 0xc5, 0x0c,
	0x83, 0xd2, 0xc0, 0xe7, 0x7d, 0xc8, 0xd2, 0x45, 0x3d, 0xdb, 0x81, 0x41, 0x9b, 0xb5, 0xee, 0x18,
	0x54, 0xd5, 0x75, 0x77, 0x3e, 0xa0, 0xaa, 0xa8, 0xcb, 0x67, 0x1f, 0x21, 0xb6, 0x91, 0xc5, 0x31,
	0x23, 0xab, 0xa0, 0x35, 0xe0, 0x8e, 0x8d, 0xac, 0xa8, 0xcb, 0x93, 0x3d, 0x80, 0xab, 0x86, 0x09,
	0xc3, 0x2f, 0x38, 0xaa, 0x20, 0x75, 0xd3, 0xa3, 0xde, 0x2d, 0xf2, 0x74, 0x05, 0x93, 0xfd, 0x88,
	0x20, 0xb6, 0x03, 0xc8, 0x06, 0x74, 0xf9, 0xb9, 0x1b, 0x9c, 0xd0, 0x2e, 0x3f, 0x27, 0x29, 0xac,
	0x69, 0xa3, 0xb8, 0x28, 0xbc, 0xd6, 0x69, 0x87, 0x86, 0xd8, 0x56, 0x14, 0x16, 0xf8, 0xb5, 0x4e,
	0x7b, 0x6d, 0xc5, 0xc7, 0xe4, 0x09, 0x0c, 0xec, 0x2f, 0xe5, 0x6c, 0x8b, 0x6f, 0x3b, 0xc7, 0xb4,
	0x43, 0x17, 0x08, 0x32, 0x59, 0x1e, 0x25, 0xb9, 0x79, 0x94, 0x69, 0x67, 0x71, 0x96, 0xe7, 0x7d,
	0x48, 0x1a, 0xc1, 0xa5, 0xc8, 0x7e, 0x47, 0x00, 0x4b, 0x21, 0xe4, 0x10, 0x06, 0xb2, 0x36, 0x5c,
	0x0a, 0x56, 0x06, 0x4b, 0xee, 0xe6, 0xfe, 0x71, 0xe5, 0xed, 0xe3, 0xca, 0x4f, 0xec, 0xe3, 0xb2,
	0x7b, 0x5b, 0x24, 0x79, 0x0a, 0xc3, 0x6f, 0xa8, 0xe4, 0xa7, 0xba, 0x6c, 0xda, 0xdf, 0xe1, 0x1f,
	0x6d, 0x16, 0xfa, 0xb6, 0x6c, 0x34, 0x39, 0x80, 0x81, 0x14, 0xe8, 0xbb, 0x7a, 0xff, 0xe9, 0xea,
	0x4b, 0x81, 0xae, 0x69, 0x07, 0x86, 0x1a, 0x6b, 0xa6, 0x98, 0x91, 0x2a, 0x58, 0xb2, 0x72, 0xb5,
	0x69, 0x87, 0x2e, 0xcb, 0x0b, 0x95, 0x47, 0xc7, 0x10, 0x9f, 0x31, 0x8d, 0xe4, 0xfe, 0x8d, 0xf9,
	0xa7, 0xbc, 0xc4, 0x37, 0x4e, 0x87, 0x4e, 0x7f, 0x7d, 0xf7, 0x2c, 0xd6, 0xaf, 0xbd, 0x6f, 0xea,
	0x5a, 0xcf, 0xd6, 0x5c, 0xcb, 0xc1, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x3c, 0xdc, 0xd5, 0x06,
	0xa3, 0x04, 0x00, 0x00,
}
